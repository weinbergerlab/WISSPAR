// Code generated (@generated) by entc, DO NOT EDIT.

package models

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/adverseeventsmodule"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/baselinecategory"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/baselinecharacteristicsmodule"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/baselineclass"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/baselineclassdenom"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/baselineclassdenomcount"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/baselinedenom"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/baselinedenomcount"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/baselinegroup"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/baselinemeasure"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/baselinemeasuredenom"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/baselinemeasuredenomcount"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/baselinemeasurement"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/certainagreement"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/clinicaltrial"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/clinicaltrialmetadata"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/dosedescription"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/eventgroup"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/flowachievement"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/flowdropwithdraw"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/flowgroup"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/flowmilestone"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/flowperiod"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/flowreason"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/immunocompromisedgroups"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/manufacturer"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/moreinfomodule"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/otherevent"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/othereventstats"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/outcomeanalysis"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/outcomeanalysisgroupid"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/outcomecategory"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/outcomeclass"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/outcomeclassdenom"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/outcomeclassdenomcount"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/outcomedenom"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/outcomedenomcount"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/outcomegroup"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/outcomemeasure"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/outcomemeasurement"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/outcomemeasuresmodule"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/outcomeoverview"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/participantflowmodule"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/pointofcontact"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/predicate"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/resultsdefinition"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/schedule"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/seriousevent"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/seriouseventstats"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/studyeligibility"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/studylocation"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/task"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/usecase"
	"gitlab.com/weinbergerlab/immunogenicity-data-project/app/gen/models/vaccine"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAdverseEventsModule           = "AdverseEventsModule"
	TypeBaselineCategory              = "BaselineCategory"
	TypeBaselineCharacteristicsModule = "BaselineCharacteristicsModule"
	TypeBaselineClass                 = "BaselineClass"
	TypeBaselineClassDenom            = "BaselineClassDenom"
	TypeBaselineClassDenomCount       = "BaselineClassDenomCount"
	TypeBaselineDenom                 = "BaselineDenom"
	TypeBaselineDenomCount            = "BaselineDenomCount"
	TypeBaselineGroup                 = "BaselineGroup"
	TypeBaselineMeasure               = "BaselineMeasure"
	TypeBaselineMeasureDenom          = "BaselineMeasureDenom"
	TypeBaselineMeasureDenomCount     = "BaselineMeasureDenomCount"
	TypeBaselineMeasurement           = "BaselineMeasurement"
	TypeCertainAgreement              = "CertainAgreement"
	TypeClinicalTrial                 = "ClinicalTrial"
	TypeClinicalTrialMetadata         = "ClinicalTrialMetadata"
	TypeDoseDescription               = "DoseDescription"
	TypeEventGroup                    = "EventGroup"
	TypeFlowAchievement               = "FlowAchievement"
	TypeFlowDropWithdraw              = "FlowDropWithdraw"
	TypeFlowGroup                     = "FlowGroup"
	TypeFlowMilestone                 = "FlowMilestone"
	TypeFlowPeriod                    = "FlowPeriod"
	TypeFlowReason                    = "FlowReason"
	TypeImmunocompromisedGroups       = "ImmunocompromisedGroups"
	TypeManufacturer                  = "Manufacturer"
	TypeMoreInfoModule                = "MoreInfoModule"
	TypeOtherEvent                    = "OtherEvent"
	TypeOtherEventStats               = "OtherEventStats"
	TypeOutcomeAnalysis               = "OutcomeAnalysis"
	TypeOutcomeAnalysisGroupID        = "OutcomeAnalysisGroupID"
	TypeOutcomeCategory               = "OutcomeCategory"
	TypeOutcomeClass                  = "OutcomeClass"
	TypeOutcomeClassDenom             = "OutcomeClassDenom"
	TypeOutcomeClassDenomCount        = "OutcomeClassDenomCount"
	TypeOutcomeDenom                  = "OutcomeDenom"
	TypeOutcomeDenomCount             = "OutcomeDenomCount"
	TypeOutcomeGroup                  = "OutcomeGroup"
	TypeOutcomeMeasure                = "OutcomeMeasure"
	TypeOutcomeMeasurement            = "OutcomeMeasurement"
	TypeOutcomeMeasuresModule         = "OutcomeMeasuresModule"
	TypeOutcomeOverview               = "OutcomeOverview"
	TypeParticipantFlowModule         = "ParticipantFlowModule"
	TypePointOfContact                = "PointOfContact"
	TypeResultsDefinition             = "ResultsDefinition"
	TypeSchedule                      = "Schedule"
	TypeSeriousEvent                  = "SeriousEvent"
	TypeSeriousEventStats             = "SeriousEventStats"
	TypeStudyEligibility              = "StudyEligibility"
	TypeStudyLocation                 = "StudyLocation"
	TypeTask                          = "Task"
	TypeUseCase                       = "UseCase"
	TypeVaccine                       = "Vaccine"
)

// AdverseEventsModuleMutation represents an operation that mutates the AdverseEventsModule nodes in the graph.
type AdverseEventsModuleMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	events_frequency_threshold *string
	events_time_frame          *string
	events_description         *string
	clearedFields              map[string]struct{}
	parent                     *int
	clearedparent              bool
	event_group_list           map[int]struct{}
	removedevent_group_list    map[int]struct{}
	clearedevent_group_list    bool
	serious_event_list         map[int]struct{}
	removedserious_event_list  map[int]struct{}
	clearedserious_event_list  bool
	other_event_list           map[int]struct{}
	removedother_event_list    map[int]struct{}
	clearedother_event_list    bool
	done                       bool
	oldValue                   func(context.Context) (*AdverseEventsModule, error)
	predicates                 []predicate.AdverseEventsModule
}

var _ ent.Mutation = (*AdverseEventsModuleMutation)(nil)

// adverseeventsmoduleOption allows management of the mutation configuration using functional options.
type adverseeventsmoduleOption func(*AdverseEventsModuleMutation)

// newAdverseEventsModuleMutation creates new mutation for the AdverseEventsModule entity.
func newAdverseEventsModuleMutation(c config, op Op, opts ...adverseeventsmoduleOption) *AdverseEventsModuleMutation {
	m := &AdverseEventsModuleMutation{
		config:        c,
		op:            op,
		typ:           TypeAdverseEventsModule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdverseEventsModuleID sets the ID field of the mutation.
func withAdverseEventsModuleID(id int) adverseeventsmoduleOption {
	return func(m *AdverseEventsModuleMutation) {
		var (
			err   error
			once  sync.Once
			value *AdverseEventsModule
		)
		m.oldValue = func(ctx context.Context) (*AdverseEventsModule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AdverseEventsModule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdverseEventsModule sets the old AdverseEventsModule of the mutation.
func withAdverseEventsModule(node *AdverseEventsModule) adverseeventsmoduleOption {
	return func(m *AdverseEventsModuleMutation) {
		m.oldValue = func(context.Context) (*AdverseEventsModule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdverseEventsModuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdverseEventsModuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdverseEventsModuleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdverseEventsModuleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AdverseEventsModule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEventsFrequencyThreshold sets the "events_frequency_threshold" field.
func (m *AdverseEventsModuleMutation) SetEventsFrequencyThreshold(s string) {
	m.events_frequency_threshold = &s
}

// EventsFrequencyThreshold returns the value of the "events_frequency_threshold" field in the mutation.
func (m *AdverseEventsModuleMutation) EventsFrequencyThreshold() (r string, exists bool) {
	v := m.events_frequency_threshold
	if v == nil {
		return
	}
	return *v, true
}

// OldEventsFrequencyThreshold returns the old "events_frequency_threshold" field's value of the AdverseEventsModule entity.
// If the AdverseEventsModule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdverseEventsModuleMutation) OldEventsFrequencyThreshold(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventsFrequencyThreshold is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventsFrequencyThreshold requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventsFrequencyThreshold: %w", err)
	}
	return oldValue.EventsFrequencyThreshold, nil
}

// ResetEventsFrequencyThreshold resets all changes to the "events_frequency_threshold" field.
func (m *AdverseEventsModuleMutation) ResetEventsFrequencyThreshold() {
	m.events_frequency_threshold = nil
}

// SetEventsTimeFrame sets the "events_time_frame" field.
func (m *AdverseEventsModuleMutation) SetEventsTimeFrame(s string) {
	m.events_time_frame = &s
}

// EventsTimeFrame returns the value of the "events_time_frame" field in the mutation.
func (m *AdverseEventsModuleMutation) EventsTimeFrame() (r string, exists bool) {
	v := m.events_time_frame
	if v == nil {
		return
	}
	return *v, true
}

// OldEventsTimeFrame returns the old "events_time_frame" field's value of the AdverseEventsModule entity.
// If the AdverseEventsModule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdverseEventsModuleMutation) OldEventsTimeFrame(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventsTimeFrame is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventsTimeFrame requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventsTimeFrame: %w", err)
	}
	return oldValue.EventsTimeFrame, nil
}

// ResetEventsTimeFrame resets all changes to the "events_time_frame" field.
func (m *AdverseEventsModuleMutation) ResetEventsTimeFrame() {
	m.events_time_frame = nil
}

// SetEventsDescription sets the "events_description" field.
func (m *AdverseEventsModuleMutation) SetEventsDescription(s string) {
	m.events_description = &s
}

// EventsDescription returns the value of the "events_description" field in the mutation.
func (m *AdverseEventsModuleMutation) EventsDescription() (r string, exists bool) {
	v := m.events_description
	if v == nil {
		return
	}
	return *v, true
}

// OldEventsDescription returns the old "events_description" field's value of the AdverseEventsModule entity.
// If the AdverseEventsModule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdverseEventsModuleMutation) OldEventsDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventsDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventsDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventsDescription: %w", err)
	}
	return oldValue.EventsDescription, nil
}

// ResetEventsDescription resets all changes to the "events_description" field.
func (m *AdverseEventsModuleMutation) ResetEventsDescription() {
	m.events_description = nil
}

// SetParentID sets the "parent" edge to the ResultsDefinition entity by id.
func (m *AdverseEventsModuleMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ResultsDefinition entity.
func (m *AdverseEventsModuleMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ResultsDefinition entity was cleared.
func (m *AdverseEventsModuleMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *AdverseEventsModuleMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *AdverseEventsModuleMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *AdverseEventsModuleMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddEventGroupListIDs adds the "event_group_list" edge to the EventGroup entity by ids.
func (m *AdverseEventsModuleMutation) AddEventGroupListIDs(ids ...int) {
	if m.event_group_list == nil {
		m.event_group_list = make(map[int]struct{})
	}
	for i := range ids {
		m.event_group_list[ids[i]] = struct{}{}
	}
}

// ClearEventGroupList clears the "event_group_list" edge to the EventGroup entity.
func (m *AdverseEventsModuleMutation) ClearEventGroupList() {
	m.clearedevent_group_list = true
}

// EventGroupListCleared reports if the "event_group_list" edge to the EventGroup entity was cleared.
func (m *AdverseEventsModuleMutation) EventGroupListCleared() bool {
	return m.clearedevent_group_list
}

// RemoveEventGroupListIDs removes the "event_group_list" edge to the EventGroup entity by IDs.
func (m *AdverseEventsModuleMutation) RemoveEventGroupListIDs(ids ...int) {
	if m.removedevent_group_list == nil {
		m.removedevent_group_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.event_group_list, ids[i])
		m.removedevent_group_list[ids[i]] = struct{}{}
	}
}

// RemovedEventGroupList returns the removed IDs of the "event_group_list" edge to the EventGroup entity.
func (m *AdverseEventsModuleMutation) RemovedEventGroupListIDs() (ids []int) {
	for id := range m.removedevent_group_list {
		ids = append(ids, id)
	}
	return
}

// EventGroupListIDs returns the "event_group_list" edge IDs in the mutation.
func (m *AdverseEventsModuleMutation) EventGroupListIDs() (ids []int) {
	for id := range m.event_group_list {
		ids = append(ids, id)
	}
	return
}

// ResetEventGroupList resets all changes to the "event_group_list" edge.
func (m *AdverseEventsModuleMutation) ResetEventGroupList() {
	m.event_group_list = nil
	m.clearedevent_group_list = false
	m.removedevent_group_list = nil
}

// AddSeriousEventListIDs adds the "serious_event_list" edge to the SeriousEvent entity by ids.
func (m *AdverseEventsModuleMutation) AddSeriousEventListIDs(ids ...int) {
	if m.serious_event_list == nil {
		m.serious_event_list = make(map[int]struct{})
	}
	for i := range ids {
		m.serious_event_list[ids[i]] = struct{}{}
	}
}

// ClearSeriousEventList clears the "serious_event_list" edge to the SeriousEvent entity.
func (m *AdverseEventsModuleMutation) ClearSeriousEventList() {
	m.clearedserious_event_list = true
}

// SeriousEventListCleared reports if the "serious_event_list" edge to the SeriousEvent entity was cleared.
func (m *AdverseEventsModuleMutation) SeriousEventListCleared() bool {
	return m.clearedserious_event_list
}

// RemoveSeriousEventListIDs removes the "serious_event_list" edge to the SeriousEvent entity by IDs.
func (m *AdverseEventsModuleMutation) RemoveSeriousEventListIDs(ids ...int) {
	if m.removedserious_event_list == nil {
		m.removedserious_event_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.serious_event_list, ids[i])
		m.removedserious_event_list[ids[i]] = struct{}{}
	}
}

// RemovedSeriousEventList returns the removed IDs of the "serious_event_list" edge to the SeriousEvent entity.
func (m *AdverseEventsModuleMutation) RemovedSeriousEventListIDs() (ids []int) {
	for id := range m.removedserious_event_list {
		ids = append(ids, id)
	}
	return
}

// SeriousEventListIDs returns the "serious_event_list" edge IDs in the mutation.
func (m *AdverseEventsModuleMutation) SeriousEventListIDs() (ids []int) {
	for id := range m.serious_event_list {
		ids = append(ids, id)
	}
	return
}

// ResetSeriousEventList resets all changes to the "serious_event_list" edge.
func (m *AdverseEventsModuleMutation) ResetSeriousEventList() {
	m.serious_event_list = nil
	m.clearedserious_event_list = false
	m.removedserious_event_list = nil
}

// AddOtherEventListIDs adds the "other_event_list" edge to the OtherEvent entity by ids.
func (m *AdverseEventsModuleMutation) AddOtherEventListIDs(ids ...int) {
	if m.other_event_list == nil {
		m.other_event_list = make(map[int]struct{})
	}
	for i := range ids {
		m.other_event_list[ids[i]] = struct{}{}
	}
}

// ClearOtherEventList clears the "other_event_list" edge to the OtherEvent entity.
func (m *AdverseEventsModuleMutation) ClearOtherEventList() {
	m.clearedother_event_list = true
}

// OtherEventListCleared reports if the "other_event_list" edge to the OtherEvent entity was cleared.
func (m *AdverseEventsModuleMutation) OtherEventListCleared() bool {
	return m.clearedother_event_list
}

// RemoveOtherEventListIDs removes the "other_event_list" edge to the OtherEvent entity by IDs.
func (m *AdverseEventsModuleMutation) RemoveOtherEventListIDs(ids ...int) {
	if m.removedother_event_list == nil {
		m.removedother_event_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.other_event_list, ids[i])
		m.removedother_event_list[ids[i]] = struct{}{}
	}
}

// RemovedOtherEventList returns the removed IDs of the "other_event_list" edge to the OtherEvent entity.
func (m *AdverseEventsModuleMutation) RemovedOtherEventListIDs() (ids []int) {
	for id := range m.removedother_event_list {
		ids = append(ids, id)
	}
	return
}

// OtherEventListIDs returns the "other_event_list" edge IDs in the mutation.
func (m *AdverseEventsModuleMutation) OtherEventListIDs() (ids []int) {
	for id := range m.other_event_list {
		ids = append(ids, id)
	}
	return
}

// ResetOtherEventList resets all changes to the "other_event_list" edge.
func (m *AdverseEventsModuleMutation) ResetOtherEventList() {
	m.other_event_list = nil
	m.clearedother_event_list = false
	m.removedother_event_list = nil
}

// Where appends a list predicates to the AdverseEventsModuleMutation builder.
func (m *AdverseEventsModuleMutation) Where(ps ...predicate.AdverseEventsModule) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *AdverseEventsModuleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (AdverseEventsModule).
func (m *AdverseEventsModuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdverseEventsModuleMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.events_frequency_threshold != nil {
		fields = append(fields, adverseeventsmodule.FieldEventsFrequencyThreshold)
	}
	if m.events_time_frame != nil {
		fields = append(fields, adverseeventsmodule.FieldEventsTimeFrame)
	}
	if m.events_description != nil {
		fields = append(fields, adverseeventsmodule.FieldEventsDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdverseEventsModuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case adverseeventsmodule.FieldEventsFrequencyThreshold:
		return m.EventsFrequencyThreshold()
	case adverseeventsmodule.FieldEventsTimeFrame:
		return m.EventsTimeFrame()
	case adverseeventsmodule.FieldEventsDescription:
		return m.EventsDescription()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdverseEventsModuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case adverseeventsmodule.FieldEventsFrequencyThreshold:
		return m.OldEventsFrequencyThreshold(ctx)
	case adverseeventsmodule.FieldEventsTimeFrame:
		return m.OldEventsTimeFrame(ctx)
	case adverseeventsmodule.FieldEventsDescription:
		return m.OldEventsDescription(ctx)
	}
	return nil, fmt.Errorf("unknown AdverseEventsModule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdverseEventsModuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case adverseeventsmodule.FieldEventsFrequencyThreshold:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventsFrequencyThreshold(v)
		return nil
	case adverseeventsmodule.FieldEventsTimeFrame:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventsTimeFrame(v)
		return nil
	case adverseeventsmodule.FieldEventsDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventsDescription(v)
		return nil
	}
	return fmt.Errorf("unknown AdverseEventsModule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdverseEventsModuleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdverseEventsModuleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdverseEventsModuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AdverseEventsModule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdverseEventsModuleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdverseEventsModuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdverseEventsModuleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AdverseEventsModule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdverseEventsModuleMutation) ResetField(name string) error {
	switch name {
	case adverseeventsmodule.FieldEventsFrequencyThreshold:
		m.ResetEventsFrequencyThreshold()
		return nil
	case adverseeventsmodule.FieldEventsTimeFrame:
		m.ResetEventsTimeFrame()
		return nil
	case adverseeventsmodule.FieldEventsDescription:
		m.ResetEventsDescription()
		return nil
	}
	return fmt.Errorf("unknown AdverseEventsModule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdverseEventsModuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.parent != nil {
		edges = append(edges, adverseeventsmodule.EdgeParent)
	}
	if m.event_group_list != nil {
		edges = append(edges, adverseeventsmodule.EdgeEventGroupList)
	}
	if m.serious_event_list != nil {
		edges = append(edges, adverseeventsmodule.EdgeSeriousEventList)
	}
	if m.other_event_list != nil {
		edges = append(edges, adverseeventsmodule.EdgeOtherEventList)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdverseEventsModuleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case adverseeventsmodule.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case adverseeventsmodule.EdgeEventGroupList:
		ids := make([]ent.Value, 0, len(m.event_group_list))
		for id := range m.event_group_list {
			ids = append(ids, id)
		}
		return ids
	case adverseeventsmodule.EdgeSeriousEventList:
		ids := make([]ent.Value, 0, len(m.serious_event_list))
		for id := range m.serious_event_list {
			ids = append(ids, id)
		}
		return ids
	case adverseeventsmodule.EdgeOtherEventList:
		ids := make([]ent.Value, 0, len(m.other_event_list))
		for id := range m.other_event_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdverseEventsModuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedevent_group_list != nil {
		edges = append(edges, adverseeventsmodule.EdgeEventGroupList)
	}
	if m.removedserious_event_list != nil {
		edges = append(edges, adverseeventsmodule.EdgeSeriousEventList)
	}
	if m.removedother_event_list != nil {
		edges = append(edges, adverseeventsmodule.EdgeOtherEventList)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdverseEventsModuleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case adverseeventsmodule.EdgeEventGroupList:
		ids := make([]ent.Value, 0, len(m.removedevent_group_list))
		for id := range m.removedevent_group_list {
			ids = append(ids, id)
		}
		return ids
	case adverseeventsmodule.EdgeSeriousEventList:
		ids := make([]ent.Value, 0, len(m.removedserious_event_list))
		for id := range m.removedserious_event_list {
			ids = append(ids, id)
		}
		return ids
	case adverseeventsmodule.EdgeOtherEventList:
		ids := make([]ent.Value, 0, len(m.removedother_event_list))
		for id := range m.removedother_event_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdverseEventsModuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedparent {
		edges = append(edges, adverseeventsmodule.EdgeParent)
	}
	if m.clearedevent_group_list {
		edges = append(edges, adverseeventsmodule.EdgeEventGroupList)
	}
	if m.clearedserious_event_list {
		edges = append(edges, adverseeventsmodule.EdgeSeriousEventList)
	}
	if m.clearedother_event_list {
		edges = append(edges, adverseeventsmodule.EdgeOtherEventList)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdverseEventsModuleMutation) EdgeCleared(name string) bool {
	switch name {
	case adverseeventsmodule.EdgeParent:
		return m.clearedparent
	case adverseeventsmodule.EdgeEventGroupList:
		return m.clearedevent_group_list
	case adverseeventsmodule.EdgeSeriousEventList:
		return m.clearedserious_event_list
	case adverseeventsmodule.EdgeOtherEventList:
		return m.clearedother_event_list
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdverseEventsModuleMutation) ClearEdge(name string) error {
	switch name {
	case adverseeventsmodule.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown AdverseEventsModule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdverseEventsModuleMutation) ResetEdge(name string) error {
	switch name {
	case adverseeventsmodule.EdgeParent:
		m.ResetParent()
		return nil
	case adverseeventsmodule.EdgeEventGroupList:
		m.ResetEventGroupList()
		return nil
	case adverseeventsmodule.EdgeSeriousEventList:
		m.ResetSeriousEventList()
		return nil
	case adverseeventsmodule.EdgeOtherEventList:
		m.ResetOtherEventList()
		return nil
	}
	return fmt.Errorf("unknown AdverseEventsModule edge %s", name)
}

// BaselineCategoryMutation represents an operation that mutates the BaselineCategory nodes in the graph.
type BaselineCategoryMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	baseline_category_title          *string
	clearedFields                    map[string]struct{}
	parent                           *int
	clearedparent                    bool
	baseline_measurement_list        map[int]struct{}
	removedbaseline_measurement_list map[int]struct{}
	clearedbaseline_measurement_list bool
	done                             bool
	oldValue                         func(context.Context) (*BaselineCategory, error)
	predicates                       []predicate.BaselineCategory
}

var _ ent.Mutation = (*BaselineCategoryMutation)(nil)

// baselinecategoryOption allows management of the mutation configuration using functional options.
type baselinecategoryOption func(*BaselineCategoryMutation)

// newBaselineCategoryMutation creates new mutation for the BaselineCategory entity.
func newBaselineCategoryMutation(c config, op Op, opts ...baselinecategoryOption) *BaselineCategoryMutation {
	m := &BaselineCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeBaselineCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBaselineCategoryID sets the ID field of the mutation.
func withBaselineCategoryID(id int) baselinecategoryOption {
	return func(m *BaselineCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *BaselineCategory
		)
		m.oldValue = func(ctx context.Context) (*BaselineCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BaselineCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBaselineCategory sets the old BaselineCategory of the mutation.
func withBaselineCategory(node *BaselineCategory) baselinecategoryOption {
	return func(m *BaselineCategoryMutation) {
		m.oldValue = func(context.Context) (*BaselineCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BaselineCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BaselineCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BaselineCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BaselineCategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BaselineCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBaselineCategoryTitle sets the "baseline_category_title" field.
func (m *BaselineCategoryMutation) SetBaselineCategoryTitle(s string) {
	m.baseline_category_title = &s
}

// BaselineCategoryTitle returns the value of the "baseline_category_title" field in the mutation.
func (m *BaselineCategoryMutation) BaselineCategoryTitle() (r string, exists bool) {
	v := m.baseline_category_title
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselineCategoryTitle returns the old "baseline_category_title" field's value of the BaselineCategory entity.
// If the BaselineCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineCategoryMutation) OldBaselineCategoryTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselineCategoryTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselineCategoryTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselineCategoryTitle: %w", err)
	}
	return oldValue.BaselineCategoryTitle, nil
}

// ResetBaselineCategoryTitle resets all changes to the "baseline_category_title" field.
func (m *BaselineCategoryMutation) ResetBaselineCategoryTitle() {
	m.baseline_category_title = nil
}

// SetParentID sets the "parent" edge to the BaselineClass entity by id.
func (m *BaselineCategoryMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the BaselineClass entity.
func (m *BaselineCategoryMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the BaselineClass entity was cleared.
func (m *BaselineCategoryMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *BaselineCategoryMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *BaselineCategoryMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *BaselineCategoryMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddBaselineMeasurementListIDs adds the "baseline_measurement_list" edge to the BaselineMeasurement entity by ids.
func (m *BaselineCategoryMutation) AddBaselineMeasurementListIDs(ids ...int) {
	if m.baseline_measurement_list == nil {
		m.baseline_measurement_list = make(map[int]struct{})
	}
	for i := range ids {
		m.baseline_measurement_list[ids[i]] = struct{}{}
	}
}

// ClearBaselineMeasurementList clears the "baseline_measurement_list" edge to the BaselineMeasurement entity.
func (m *BaselineCategoryMutation) ClearBaselineMeasurementList() {
	m.clearedbaseline_measurement_list = true
}

// BaselineMeasurementListCleared reports if the "baseline_measurement_list" edge to the BaselineMeasurement entity was cleared.
func (m *BaselineCategoryMutation) BaselineMeasurementListCleared() bool {
	return m.clearedbaseline_measurement_list
}

// RemoveBaselineMeasurementListIDs removes the "baseline_measurement_list" edge to the BaselineMeasurement entity by IDs.
func (m *BaselineCategoryMutation) RemoveBaselineMeasurementListIDs(ids ...int) {
	if m.removedbaseline_measurement_list == nil {
		m.removedbaseline_measurement_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.baseline_measurement_list, ids[i])
		m.removedbaseline_measurement_list[ids[i]] = struct{}{}
	}
}

// RemovedBaselineMeasurementList returns the removed IDs of the "baseline_measurement_list" edge to the BaselineMeasurement entity.
func (m *BaselineCategoryMutation) RemovedBaselineMeasurementListIDs() (ids []int) {
	for id := range m.removedbaseline_measurement_list {
		ids = append(ids, id)
	}
	return
}

// BaselineMeasurementListIDs returns the "baseline_measurement_list" edge IDs in the mutation.
func (m *BaselineCategoryMutation) BaselineMeasurementListIDs() (ids []int) {
	for id := range m.baseline_measurement_list {
		ids = append(ids, id)
	}
	return
}

// ResetBaselineMeasurementList resets all changes to the "baseline_measurement_list" edge.
func (m *BaselineCategoryMutation) ResetBaselineMeasurementList() {
	m.baseline_measurement_list = nil
	m.clearedbaseline_measurement_list = false
	m.removedbaseline_measurement_list = nil
}

// Where appends a list predicates to the BaselineCategoryMutation builder.
func (m *BaselineCategoryMutation) Where(ps ...predicate.BaselineCategory) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BaselineCategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BaselineCategory).
func (m *BaselineCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BaselineCategoryMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.baseline_category_title != nil {
		fields = append(fields, baselinecategory.FieldBaselineCategoryTitle)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BaselineCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case baselinecategory.FieldBaselineCategoryTitle:
		return m.BaselineCategoryTitle()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BaselineCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case baselinecategory.FieldBaselineCategoryTitle:
		return m.OldBaselineCategoryTitle(ctx)
	}
	return nil, fmt.Errorf("unknown BaselineCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BaselineCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case baselinecategory.FieldBaselineCategoryTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselineCategoryTitle(v)
		return nil
	}
	return fmt.Errorf("unknown BaselineCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BaselineCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BaselineCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BaselineCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BaselineCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BaselineCategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BaselineCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BaselineCategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BaselineCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BaselineCategoryMutation) ResetField(name string) error {
	switch name {
	case baselinecategory.FieldBaselineCategoryTitle:
		m.ResetBaselineCategoryTitle()
		return nil
	}
	return fmt.Errorf("unknown BaselineCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BaselineCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.parent != nil {
		edges = append(edges, baselinecategory.EdgeParent)
	}
	if m.baseline_measurement_list != nil {
		edges = append(edges, baselinecategory.EdgeBaselineMeasurementList)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BaselineCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case baselinecategory.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case baselinecategory.EdgeBaselineMeasurementList:
		ids := make([]ent.Value, 0, len(m.baseline_measurement_list))
		for id := range m.baseline_measurement_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BaselineCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedbaseline_measurement_list != nil {
		edges = append(edges, baselinecategory.EdgeBaselineMeasurementList)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BaselineCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case baselinecategory.EdgeBaselineMeasurementList:
		ids := make([]ent.Value, 0, len(m.removedbaseline_measurement_list))
		for id := range m.removedbaseline_measurement_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BaselineCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedparent {
		edges = append(edges, baselinecategory.EdgeParent)
	}
	if m.clearedbaseline_measurement_list {
		edges = append(edges, baselinecategory.EdgeBaselineMeasurementList)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BaselineCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case baselinecategory.EdgeParent:
		return m.clearedparent
	case baselinecategory.EdgeBaselineMeasurementList:
		return m.clearedbaseline_measurement_list
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BaselineCategoryMutation) ClearEdge(name string) error {
	switch name {
	case baselinecategory.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown BaselineCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BaselineCategoryMutation) ResetEdge(name string) error {
	switch name {
	case baselinecategory.EdgeParent:
		m.ResetParent()
		return nil
	case baselinecategory.EdgeBaselineMeasurementList:
		m.ResetBaselineMeasurementList()
		return nil
	}
	return fmt.Errorf("unknown BaselineCategory edge %s", name)
}

// BaselineCharacteristicsModuleMutation represents an operation that mutates the BaselineCharacteristicsModule nodes in the graph.
type BaselineCharacteristicsModuleMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	baseline_population_description *string
	baseline_type_units_analyzed    *string
	clearedFields                   map[string]struct{}
	parent                          *int
	clearedparent                   bool
	baseline_group_list             map[int]struct{}
	removedbaseline_group_list      map[int]struct{}
	clearedbaseline_group_list      bool
	baseline_denom_list             map[int]struct{}
	removedbaseline_denom_list      map[int]struct{}
	clearedbaseline_denom_list      bool
	baseline_measure_list           map[int]struct{}
	removedbaseline_measure_list    map[int]struct{}
	clearedbaseline_measure_list    bool
	done                            bool
	oldValue                        func(context.Context) (*BaselineCharacteristicsModule, error)
	predicates                      []predicate.BaselineCharacteristicsModule
}

var _ ent.Mutation = (*BaselineCharacteristicsModuleMutation)(nil)

// baselinecharacteristicsmoduleOption allows management of the mutation configuration using functional options.
type baselinecharacteristicsmoduleOption func(*BaselineCharacteristicsModuleMutation)

// newBaselineCharacteristicsModuleMutation creates new mutation for the BaselineCharacteristicsModule entity.
func newBaselineCharacteristicsModuleMutation(c config, op Op, opts ...baselinecharacteristicsmoduleOption) *BaselineCharacteristicsModuleMutation {
	m := &BaselineCharacteristicsModuleMutation{
		config:        c,
		op:            op,
		typ:           TypeBaselineCharacteristicsModule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBaselineCharacteristicsModuleID sets the ID field of the mutation.
func withBaselineCharacteristicsModuleID(id int) baselinecharacteristicsmoduleOption {
	return func(m *BaselineCharacteristicsModuleMutation) {
		var (
			err   error
			once  sync.Once
			value *BaselineCharacteristicsModule
		)
		m.oldValue = func(ctx context.Context) (*BaselineCharacteristicsModule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BaselineCharacteristicsModule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBaselineCharacteristicsModule sets the old BaselineCharacteristicsModule of the mutation.
func withBaselineCharacteristicsModule(node *BaselineCharacteristicsModule) baselinecharacteristicsmoduleOption {
	return func(m *BaselineCharacteristicsModuleMutation) {
		m.oldValue = func(context.Context) (*BaselineCharacteristicsModule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BaselineCharacteristicsModuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BaselineCharacteristicsModuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BaselineCharacteristicsModuleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BaselineCharacteristicsModuleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BaselineCharacteristicsModule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBaselinePopulationDescription sets the "baseline_population_description" field.
func (m *BaselineCharacteristicsModuleMutation) SetBaselinePopulationDescription(s string) {
	m.baseline_population_description = &s
}

// BaselinePopulationDescription returns the value of the "baseline_population_description" field in the mutation.
func (m *BaselineCharacteristicsModuleMutation) BaselinePopulationDescription() (r string, exists bool) {
	v := m.baseline_population_description
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselinePopulationDescription returns the old "baseline_population_description" field's value of the BaselineCharacteristicsModule entity.
// If the BaselineCharacteristicsModule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineCharacteristicsModuleMutation) OldBaselinePopulationDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselinePopulationDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselinePopulationDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselinePopulationDescription: %w", err)
	}
	return oldValue.BaselinePopulationDescription, nil
}

// ResetBaselinePopulationDescription resets all changes to the "baseline_population_description" field.
func (m *BaselineCharacteristicsModuleMutation) ResetBaselinePopulationDescription() {
	m.baseline_population_description = nil
}

// SetBaselineTypeUnitsAnalyzed sets the "baseline_type_units_analyzed" field.
func (m *BaselineCharacteristicsModuleMutation) SetBaselineTypeUnitsAnalyzed(s string) {
	m.baseline_type_units_analyzed = &s
}

// BaselineTypeUnitsAnalyzed returns the value of the "baseline_type_units_analyzed" field in the mutation.
func (m *BaselineCharacteristicsModuleMutation) BaselineTypeUnitsAnalyzed() (r string, exists bool) {
	v := m.baseline_type_units_analyzed
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselineTypeUnitsAnalyzed returns the old "baseline_type_units_analyzed" field's value of the BaselineCharacteristicsModule entity.
// If the BaselineCharacteristicsModule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineCharacteristicsModuleMutation) OldBaselineTypeUnitsAnalyzed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselineTypeUnitsAnalyzed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselineTypeUnitsAnalyzed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselineTypeUnitsAnalyzed: %w", err)
	}
	return oldValue.BaselineTypeUnitsAnalyzed, nil
}

// ResetBaselineTypeUnitsAnalyzed resets all changes to the "baseline_type_units_analyzed" field.
func (m *BaselineCharacteristicsModuleMutation) ResetBaselineTypeUnitsAnalyzed() {
	m.baseline_type_units_analyzed = nil
}

// SetParentID sets the "parent" edge to the ResultsDefinition entity by id.
func (m *BaselineCharacteristicsModuleMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ResultsDefinition entity.
func (m *BaselineCharacteristicsModuleMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ResultsDefinition entity was cleared.
func (m *BaselineCharacteristicsModuleMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *BaselineCharacteristicsModuleMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *BaselineCharacteristicsModuleMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *BaselineCharacteristicsModuleMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddBaselineGroupListIDs adds the "baseline_group_list" edge to the BaselineGroup entity by ids.
func (m *BaselineCharacteristicsModuleMutation) AddBaselineGroupListIDs(ids ...int) {
	if m.baseline_group_list == nil {
		m.baseline_group_list = make(map[int]struct{})
	}
	for i := range ids {
		m.baseline_group_list[ids[i]] = struct{}{}
	}
}

// ClearBaselineGroupList clears the "baseline_group_list" edge to the BaselineGroup entity.
func (m *BaselineCharacteristicsModuleMutation) ClearBaselineGroupList() {
	m.clearedbaseline_group_list = true
}

// BaselineGroupListCleared reports if the "baseline_group_list" edge to the BaselineGroup entity was cleared.
func (m *BaselineCharacteristicsModuleMutation) BaselineGroupListCleared() bool {
	return m.clearedbaseline_group_list
}

// RemoveBaselineGroupListIDs removes the "baseline_group_list" edge to the BaselineGroup entity by IDs.
func (m *BaselineCharacteristicsModuleMutation) RemoveBaselineGroupListIDs(ids ...int) {
	if m.removedbaseline_group_list == nil {
		m.removedbaseline_group_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.baseline_group_list, ids[i])
		m.removedbaseline_group_list[ids[i]] = struct{}{}
	}
}

// RemovedBaselineGroupList returns the removed IDs of the "baseline_group_list" edge to the BaselineGroup entity.
func (m *BaselineCharacteristicsModuleMutation) RemovedBaselineGroupListIDs() (ids []int) {
	for id := range m.removedbaseline_group_list {
		ids = append(ids, id)
	}
	return
}

// BaselineGroupListIDs returns the "baseline_group_list" edge IDs in the mutation.
func (m *BaselineCharacteristicsModuleMutation) BaselineGroupListIDs() (ids []int) {
	for id := range m.baseline_group_list {
		ids = append(ids, id)
	}
	return
}

// ResetBaselineGroupList resets all changes to the "baseline_group_list" edge.
func (m *BaselineCharacteristicsModuleMutation) ResetBaselineGroupList() {
	m.baseline_group_list = nil
	m.clearedbaseline_group_list = false
	m.removedbaseline_group_list = nil
}

// AddBaselineDenomListIDs adds the "baseline_denom_list" edge to the BaselineDenom entity by ids.
func (m *BaselineCharacteristicsModuleMutation) AddBaselineDenomListIDs(ids ...int) {
	if m.baseline_denom_list == nil {
		m.baseline_denom_list = make(map[int]struct{})
	}
	for i := range ids {
		m.baseline_denom_list[ids[i]] = struct{}{}
	}
}

// ClearBaselineDenomList clears the "baseline_denom_list" edge to the BaselineDenom entity.
func (m *BaselineCharacteristicsModuleMutation) ClearBaselineDenomList() {
	m.clearedbaseline_denom_list = true
}

// BaselineDenomListCleared reports if the "baseline_denom_list" edge to the BaselineDenom entity was cleared.
func (m *BaselineCharacteristicsModuleMutation) BaselineDenomListCleared() bool {
	return m.clearedbaseline_denom_list
}

// RemoveBaselineDenomListIDs removes the "baseline_denom_list" edge to the BaselineDenom entity by IDs.
func (m *BaselineCharacteristicsModuleMutation) RemoveBaselineDenomListIDs(ids ...int) {
	if m.removedbaseline_denom_list == nil {
		m.removedbaseline_denom_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.baseline_denom_list, ids[i])
		m.removedbaseline_denom_list[ids[i]] = struct{}{}
	}
}

// RemovedBaselineDenomList returns the removed IDs of the "baseline_denom_list" edge to the BaselineDenom entity.
func (m *BaselineCharacteristicsModuleMutation) RemovedBaselineDenomListIDs() (ids []int) {
	for id := range m.removedbaseline_denom_list {
		ids = append(ids, id)
	}
	return
}

// BaselineDenomListIDs returns the "baseline_denom_list" edge IDs in the mutation.
func (m *BaselineCharacteristicsModuleMutation) BaselineDenomListIDs() (ids []int) {
	for id := range m.baseline_denom_list {
		ids = append(ids, id)
	}
	return
}

// ResetBaselineDenomList resets all changes to the "baseline_denom_list" edge.
func (m *BaselineCharacteristicsModuleMutation) ResetBaselineDenomList() {
	m.baseline_denom_list = nil
	m.clearedbaseline_denom_list = false
	m.removedbaseline_denom_list = nil
}

// AddBaselineMeasureListIDs adds the "baseline_measure_list" edge to the BaselineMeasure entity by ids.
func (m *BaselineCharacteristicsModuleMutation) AddBaselineMeasureListIDs(ids ...int) {
	if m.baseline_measure_list == nil {
		m.baseline_measure_list = make(map[int]struct{})
	}
	for i := range ids {
		m.baseline_measure_list[ids[i]] = struct{}{}
	}
}

// ClearBaselineMeasureList clears the "baseline_measure_list" edge to the BaselineMeasure entity.
func (m *BaselineCharacteristicsModuleMutation) ClearBaselineMeasureList() {
	m.clearedbaseline_measure_list = true
}

// BaselineMeasureListCleared reports if the "baseline_measure_list" edge to the BaselineMeasure entity was cleared.
func (m *BaselineCharacteristicsModuleMutation) BaselineMeasureListCleared() bool {
	return m.clearedbaseline_measure_list
}

// RemoveBaselineMeasureListIDs removes the "baseline_measure_list" edge to the BaselineMeasure entity by IDs.
func (m *BaselineCharacteristicsModuleMutation) RemoveBaselineMeasureListIDs(ids ...int) {
	if m.removedbaseline_measure_list == nil {
		m.removedbaseline_measure_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.baseline_measure_list, ids[i])
		m.removedbaseline_measure_list[ids[i]] = struct{}{}
	}
}

// RemovedBaselineMeasureList returns the removed IDs of the "baseline_measure_list" edge to the BaselineMeasure entity.
func (m *BaselineCharacteristicsModuleMutation) RemovedBaselineMeasureListIDs() (ids []int) {
	for id := range m.removedbaseline_measure_list {
		ids = append(ids, id)
	}
	return
}

// BaselineMeasureListIDs returns the "baseline_measure_list" edge IDs in the mutation.
func (m *BaselineCharacteristicsModuleMutation) BaselineMeasureListIDs() (ids []int) {
	for id := range m.baseline_measure_list {
		ids = append(ids, id)
	}
	return
}

// ResetBaselineMeasureList resets all changes to the "baseline_measure_list" edge.
func (m *BaselineCharacteristicsModuleMutation) ResetBaselineMeasureList() {
	m.baseline_measure_list = nil
	m.clearedbaseline_measure_list = false
	m.removedbaseline_measure_list = nil
}

// Where appends a list predicates to the BaselineCharacteristicsModuleMutation builder.
func (m *BaselineCharacteristicsModuleMutation) Where(ps ...predicate.BaselineCharacteristicsModule) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BaselineCharacteristicsModuleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BaselineCharacteristicsModule).
func (m *BaselineCharacteristicsModuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BaselineCharacteristicsModuleMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.baseline_population_description != nil {
		fields = append(fields, baselinecharacteristicsmodule.FieldBaselinePopulationDescription)
	}
	if m.baseline_type_units_analyzed != nil {
		fields = append(fields, baselinecharacteristicsmodule.FieldBaselineTypeUnitsAnalyzed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BaselineCharacteristicsModuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case baselinecharacteristicsmodule.FieldBaselinePopulationDescription:
		return m.BaselinePopulationDescription()
	case baselinecharacteristicsmodule.FieldBaselineTypeUnitsAnalyzed:
		return m.BaselineTypeUnitsAnalyzed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BaselineCharacteristicsModuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case baselinecharacteristicsmodule.FieldBaselinePopulationDescription:
		return m.OldBaselinePopulationDescription(ctx)
	case baselinecharacteristicsmodule.FieldBaselineTypeUnitsAnalyzed:
		return m.OldBaselineTypeUnitsAnalyzed(ctx)
	}
	return nil, fmt.Errorf("unknown BaselineCharacteristicsModule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BaselineCharacteristicsModuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case baselinecharacteristicsmodule.FieldBaselinePopulationDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselinePopulationDescription(v)
		return nil
	case baselinecharacteristicsmodule.FieldBaselineTypeUnitsAnalyzed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselineTypeUnitsAnalyzed(v)
		return nil
	}
	return fmt.Errorf("unknown BaselineCharacteristicsModule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BaselineCharacteristicsModuleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BaselineCharacteristicsModuleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BaselineCharacteristicsModuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BaselineCharacteristicsModule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BaselineCharacteristicsModuleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BaselineCharacteristicsModuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BaselineCharacteristicsModuleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BaselineCharacteristicsModule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BaselineCharacteristicsModuleMutation) ResetField(name string) error {
	switch name {
	case baselinecharacteristicsmodule.FieldBaselinePopulationDescription:
		m.ResetBaselinePopulationDescription()
		return nil
	case baselinecharacteristicsmodule.FieldBaselineTypeUnitsAnalyzed:
		m.ResetBaselineTypeUnitsAnalyzed()
		return nil
	}
	return fmt.Errorf("unknown BaselineCharacteristicsModule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BaselineCharacteristicsModuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.parent != nil {
		edges = append(edges, baselinecharacteristicsmodule.EdgeParent)
	}
	if m.baseline_group_list != nil {
		edges = append(edges, baselinecharacteristicsmodule.EdgeBaselineGroupList)
	}
	if m.baseline_denom_list != nil {
		edges = append(edges, baselinecharacteristicsmodule.EdgeBaselineDenomList)
	}
	if m.baseline_measure_list != nil {
		edges = append(edges, baselinecharacteristicsmodule.EdgeBaselineMeasureList)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BaselineCharacteristicsModuleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case baselinecharacteristicsmodule.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case baselinecharacteristicsmodule.EdgeBaselineGroupList:
		ids := make([]ent.Value, 0, len(m.baseline_group_list))
		for id := range m.baseline_group_list {
			ids = append(ids, id)
		}
		return ids
	case baselinecharacteristicsmodule.EdgeBaselineDenomList:
		ids := make([]ent.Value, 0, len(m.baseline_denom_list))
		for id := range m.baseline_denom_list {
			ids = append(ids, id)
		}
		return ids
	case baselinecharacteristicsmodule.EdgeBaselineMeasureList:
		ids := make([]ent.Value, 0, len(m.baseline_measure_list))
		for id := range m.baseline_measure_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BaselineCharacteristicsModuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedbaseline_group_list != nil {
		edges = append(edges, baselinecharacteristicsmodule.EdgeBaselineGroupList)
	}
	if m.removedbaseline_denom_list != nil {
		edges = append(edges, baselinecharacteristicsmodule.EdgeBaselineDenomList)
	}
	if m.removedbaseline_measure_list != nil {
		edges = append(edges, baselinecharacteristicsmodule.EdgeBaselineMeasureList)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BaselineCharacteristicsModuleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case baselinecharacteristicsmodule.EdgeBaselineGroupList:
		ids := make([]ent.Value, 0, len(m.removedbaseline_group_list))
		for id := range m.removedbaseline_group_list {
			ids = append(ids, id)
		}
		return ids
	case baselinecharacteristicsmodule.EdgeBaselineDenomList:
		ids := make([]ent.Value, 0, len(m.removedbaseline_denom_list))
		for id := range m.removedbaseline_denom_list {
			ids = append(ids, id)
		}
		return ids
	case baselinecharacteristicsmodule.EdgeBaselineMeasureList:
		ids := make([]ent.Value, 0, len(m.removedbaseline_measure_list))
		for id := range m.removedbaseline_measure_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BaselineCharacteristicsModuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedparent {
		edges = append(edges, baselinecharacteristicsmodule.EdgeParent)
	}
	if m.clearedbaseline_group_list {
		edges = append(edges, baselinecharacteristicsmodule.EdgeBaselineGroupList)
	}
	if m.clearedbaseline_denom_list {
		edges = append(edges, baselinecharacteristicsmodule.EdgeBaselineDenomList)
	}
	if m.clearedbaseline_measure_list {
		edges = append(edges, baselinecharacteristicsmodule.EdgeBaselineMeasureList)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BaselineCharacteristicsModuleMutation) EdgeCleared(name string) bool {
	switch name {
	case baselinecharacteristicsmodule.EdgeParent:
		return m.clearedparent
	case baselinecharacteristicsmodule.EdgeBaselineGroupList:
		return m.clearedbaseline_group_list
	case baselinecharacteristicsmodule.EdgeBaselineDenomList:
		return m.clearedbaseline_denom_list
	case baselinecharacteristicsmodule.EdgeBaselineMeasureList:
		return m.clearedbaseline_measure_list
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BaselineCharacteristicsModuleMutation) ClearEdge(name string) error {
	switch name {
	case baselinecharacteristicsmodule.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown BaselineCharacteristicsModule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BaselineCharacteristicsModuleMutation) ResetEdge(name string) error {
	switch name {
	case baselinecharacteristicsmodule.EdgeParent:
		m.ResetParent()
		return nil
	case baselinecharacteristicsmodule.EdgeBaselineGroupList:
		m.ResetBaselineGroupList()
		return nil
	case baselinecharacteristicsmodule.EdgeBaselineDenomList:
		m.ResetBaselineDenomList()
		return nil
	case baselinecharacteristicsmodule.EdgeBaselineMeasureList:
		m.ResetBaselineMeasureList()
		return nil
	}
	return fmt.Errorf("unknown BaselineCharacteristicsModule edge %s", name)
}

// BaselineClassMutation represents an operation that mutates the BaselineClass nodes in the graph.
type BaselineClassMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	baseline_class_title             *string
	clearedFields                    map[string]struct{}
	parent                           *int
	clearedparent                    bool
	baseline_class_denom_list        map[int]struct{}
	removedbaseline_class_denom_list map[int]struct{}
	clearedbaseline_class_denom_list bool
	baseline_category_list           map[int]struct{}
	removedbaseline_category_list    map[int]struct{}
	clearedbaseline_category_list    bool
	done                             bool
	oldValue                         func(context.Context) (*BaselineClass, error)
	predicates                       []predicate.BaselineClass
}

var _ ent.Mutation = (*BaselineClassMutation)(nil)

// baselineclassOption allows management of the mutation configuration using functional options.
type baselineclassOption func(*BaselineClassMutation)

// newBaselineClassMutation creates new mutation for the BaselineClass entity.
func newBaselineClassMutation(c config, op Op, opts ...baselineclassOption) *BaselineClassMutation {
	m := &BaselineClassMutation{
		config:        c,
		op:            op,
		typ:           TypeBaselineClass,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBaselineClassID sets the ID field of the mutation.
func withBaselineClassID(id int) baselineclassOption {
	return func(m *BaselineClassMutation) {
		var (
			err   error
			once  sync.Once
			value *BaselineClass
		)
		m.oldValue = func(ctx context.Context) (*BaselineClass, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BaselineClass.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBaselineClass sets the old BaselineClass of the mutation.
func withBaselineClass(node *BaselineClass) baselineclassOption {
	return func(m *BaselineClassMutation) {
		m.oldValue = func(context.Context) (*BaselineClass, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BaselineClassMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BaselineClassMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BaselineClassMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BaselineClassMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BaselineClass.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBaselineClassTitle sets the "baseline_class_title" field.
func (m *BaselineClassMutation) SetBaselineClassTitle(s string) {
	m.baseline_class_title = &s
}

// BaselineClassTitle returns the value of the "baseline_class_title" field in the mutation.
func (m *BaselineClassMutation) BaselineClassTitle() (r string, exists bool) {
	v := m.baseline_class_title
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselineClassTitle returns the old "baseline_class_title" field's value of the BaselineClass entity.
// If the BaselineClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineClassMutation) OldBaselineClassTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselineClassTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselineClassTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselineClassTitle: %w", err)
	}
	return oldValue.BaselineClassTitle, nil
}

// ResetBaselineClassTitle resets all changes to the "baseline_class_title" field.
func (m *BaselineClassMutation) ResetBaselineClassTitle() {
	m.baseline_class_title = nil
}

// SetParentID sets the "parent" edge to the BaselineMeasure entity by id.
func (m *BaselineClassMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the BaselineMeasure entity.
func (m *BaselineClassMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the BaselineMeasure entity was cleared.
func (m *BaselineClassMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *BaselineClassMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *BaselineClassMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *BaselineClassMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddBaselineClassDenomListIDs adds the "baseline_class_denom_list" edge to the BaselineClassDenom entity by ids.
func (m *BaselineClassMutation) AddBaselineClassDenomListIDs(ids ...int) {
	if m.baseline_class_denom_list == nil {
		m.baseline_class_denom_list = make(map[int]struct{})
	}
	for i := range ids {
		m.baseline_class_denom_list[ids[i]] = struct{}{}
	}
}

// ClearBaselineClassDenomList clears the "baseline_class_denom_list" edge to the BaselineClassDenom entity.
func (m *BaselineClassMutation) ClearBaselineClassDenomList() {
	m.clearedbaseline_class_denom_list = true
}

// BaselineClassDenomListCleared reports if the "baseline_class_denom_list" edge to the BaselineClassDenom entity was cleared.
func (m *BaselineClassMutation) BaselineClassDenomListCleared() bool {
	return m.clearedbaseline_class_denom_list
}

// RemoveBaselineClassDenomListIDs removes the "baseline_class_denom_list" edge to the BaselineClassDenom entity by IDs.
func (m *BaselineClassMutation) RemoveBaselineClassDenomListIDs(ids ...int) {
	if m.removedbaseline_class_denom_list == nil {
		m.removedbaseline_class_denom_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.baseline_class_denom_list, ids[i])
		m.removedbaseline_class_denom_list[ids[i]] = struct{}{}
	}
}

// RemovedBaselineClassDenomList returns the removed IDs of the "baseline_class_denom_list" edge to the BaselineClassDenom entity.
func (m *BaselineClassMutation) RemovedBaselineClassDenomListIDs() (ids []int) {
	for id := range m.removedbaseline_class_denom_list {
		ids = append(ids, id)
	}
	return
}

// BaselineClassDenomListIDs returns the "baseline_class_denom_list" edge IDs in the mutation.
func (m *BaselineClassMutation) BaselineClassDenomListIDs() (ids []int) {
	for id := range m.baseline_class_denom_list {
		ids = append(ids, id)
	}
	return
}

// ResetBaselineClassDenomList resets all changes to the "baseline_class_denom_list" edge.
func (m *BaselineClassMutation) ResetBaselineClassDenomList() {
	m.baseline_class_denom_list = nil
	m.clearedbaseline_class_denom_list = false
	m.removedbaseline_class_denom_list = nil
}

// AddBaselineCategoryListIDs adds the "baseline_category_list" edge to the BaselineCategory entity by ids.
func (m *BaselineClassMutation) AddBaselineCategoryListIDs(ids ...int) {
	if m.baseline_category_list == nil {
		m.baseline_category_list = make(map[int]struct{})
	}
	for i := range ids {
		m.baseline_category_list[ids[i]] = struct{}{}
	}
}

// ClearBaselineCategoryList clears the "baseline_category_list" edge to the BaselineCategory entity.
func (m *BaselineClassMutation) ClearBaselineCategoryList() {
	m.clearedbaseline_category_list = true
}

// BaselineCategoryListCleared reports if the "baseline_category_list" edge to the BaselineCategory entity was cleared.
func (m *BaselineClassMutation) BaselineCategoryListCleared() bool {
	return m.clearedbaseline_category_list
}

// RemoveBaselineCategoryListIDs removes the "baseline_category_list" edge to the BaselineCategory entity by IDs.
func (m *BaselineClassMutation) RemoveBaselineCategoryListIDs(ids ...int) {
	if m.removedbaseline_category_list == nil {
		m.removedbaseline_category_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.baseline_category_list, ids[i])
		m.removedbaseline_category_list[ids[i]] = struct{}{}
	}
}

// RemovedBaselineCategoryList returns the removed IDs of the "baseline_category_list" edge to the BaselineCategory entity.
func (m *BaselineClassMutation) RemovedBaselineCategoryListIDs() (ids []int) {
	for id := range m.removedbaseline_category_list {
		ids = append(ids, id)
	}
	return
}

// BaselineCategoryListIDs returns the "baseline_category_list" edge IDs in the mutation.
func (m *BaselineClassMutation) BaselineCategoryListIDs() (ids []int) {
	for id := range m.baseline_category_list {
		ids = append(ids, id)
	}
	return
}

// ResetBaselineCategoryList resets all changes to the "baseline_category_list" edge.
func (m *BaselineClassMutation) ResetBaselineCategoryList() {
	m.baseline_category_list = nil
	m.clearedbaseline_category_list = false
	m.removedbaseline_category_list = nil
}

// Where appends a list predicates to the BaselineClassMutation builder.
func (m *BaselineClassMutation) Where(ps ...predicate.BaselineClass) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BaselineClassMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BaselineClass).
func (m *BaselineClassMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BaselineClassMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.baseline_class_title != nil {
		fields = append(fields, baselineclass.FieldBaselineClassTitle)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BaselineClassMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case baselineclass.FieldBaselineClassTitle:
		return m.BaselineClassTitle()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BaselineClassMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case baselineclass.FieldBaselineClassTitle:
		return m.OldBaselineClassTitle(ctx)
	}
	return nil, fmt.Errorf("unknown BaselineClass field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BaselineClassMutation) SetField(name string, value ent.Value) error {
	switch name {
	case baselineclass.FieldBaselineClassTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselineClassTitle(v)
		return nil
	}
	return fmt.Errorf("unknown BaselineClass field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BaselineClassMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BaselineClassMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BaselineClassMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BaselineClass numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BaselineClassMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BaselineClassMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BaselineClassMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BaselineClass nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BaselineClassMutation) ResetField(name string) error {
	switch name {
	case baselineclass.FieldBaselineClassTitle:
		m.ResetBaselineClassTitle()
		return nil
	}
	return fmt.Errorf("unknown BaselineClass field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BaselineClassMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent != nil {
		edges = append(edges, baselineclass.EdgeParent)
	}
	if m.baseline_class_denom_list != nil {
		edges = append(edges, baselineclass.EdgeBaselineClassDenomList)
	}
	if m.baseline_category_list != nil {
		edges = append(edges, baselineclass.EdgeBaselineCategoryList)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BaselineClassMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case baselineclass.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case baselineclass.EdgeBaselineClassDenomList:
		ids := make([]ent.Value, 0, len(m.baseline_class_denom_list))
		for id := range m.baseline_class_denom_list {
			ids = append(ids, id)
		}
		return ids
	case baselineclass.EdgeBaselineCategoryList:
		ids := make([]ent.Value, 0, len(m.baseline_category_list))
		for id := range m.baseline_category_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BaselineClassMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedbaseline_class_denom_list != nil {
		edges = append(edges, baselineclass.EdgeBaselineClassDenomList)
	}
	if m.removedbaseline_category_list != nil {
		edges = append(edges, baselineclass.EdgeBaselineCategoryList)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BaselineClassMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case baselineclass.EdgeBaselineClassDenomList:
		ids := make([]ent.Value, 0, len(m.removedbaseline_class_denom_list))
		for id := range m.removedbaseline_class_denom_list {
			ids = append(ids, id)
		}
		return ids
	case baselineclass.EdgeBaselineCategoryList:
		ids := make([]ent.Value, 0, len(m.removedbaseline_category_list))
		for id := range m.removedbaseline_category_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BaselineClassMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent {
		edges = append(edges, baselineclass.EdgeParent)
	}
	if m.clearedbaseline_class_denom_list {
		edges = append(edges, baselineclass.EdgeBaselineClassDenomList)
	}
	if m.clearedbaseline_category_list {
		edges = append(edges, baselineclass.EdgeBaselineCategoryList)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BaselineClassMutation) EdgeCleared(name string) bool {
	switch name {
	case baselineclass.EdgeParent:
		return m.clearedparent
	case baselineclass.EdgeBaselineClassDenomList:
		return m.clearedbaseline_class_denom_list
	case baselineclass.EdgeBaselineCategoryList:
		return m.clearedbaseline_category_list
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BaselineClassMutation) ClearEdge(name string) error {
	switch name {
	case baselineclass.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown BaselineClass unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BaselineClassMutation) ResetEdge(name string) error {
	switch name {
	case baselineclass.EdgeParent:
		m.ResetParent()
		return nil
	case baselineclass.EdgeBaselineClassDenomList:
		m.ResetBaselineClassDenomList()
		return nil
	case baselineclass.EdgeBaselineCategoryList:
		m.ResetBaselineCategoryList()
		return nil
	}
	return fmt.Errorf("unknown BaselineClass edge %s", name)
}

// BaselineClassDenomMutation represents an operation that mutates the BaselineClassDenom nodes in the graph.
type BaselineClassDenomMutation struct {
	config
	op                                     Op
	typ                                    string
	id                                     *int
	baseline_class_denom_units             *string
	clearedFields                          map[string]struct{}
	parent                                 *int
	clearedparent                          bool
	baseline_class_denom_count_list        map[int]struct{}
	removedbaseline_class_denom_count_list map[int]struct{}
	clearedbaseline_class_denom_count_list bool
	done                                   bool
	oldValue                               func(context.Context) (*BaselineClassDenom, error)
	predicates                             []predicate.BaselineClassDenom
}

var _ ent.Mutation = (*BaselineClassDenomMutation)(nil)

// baselineclassdenomOption allows management of the mutation configuration using functional options.
type baselineclassdenomOption func(*BaselineClassDenomMutation)

// newBaselineClassDenomMutation creates new mutation for the BaselineClassDenom entity.
func newBaselineClassDenomMutation(c config, op Op, opts ...baselineclassdenomOption) *BaselineClassDenomMutation {
	m := &BaselineClassDenomMutation{
		config:        c,
		op:            op,
		typ:           TypeBaselineClassDenom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBaselineClassDenomID sets the ID field of the mutation.
func withBaselineClassDenomID(id int) baselineclassdenomOption {
	return func(m *BaselineClassDenomMutation) {
		var (
			err   error
			once  sync.Once
			value *BaselineClassDenom
		)
		m.oldValue = func(ctx context.Context) (*BaselineClassDenom, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BaselineClassDenom.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBaselineClassDenom sets the old BaselineClassDenom of the mutation.
func withBaselineClassDenom(node *BaselineClassDenom) baselineclassdenomOption {
	return func(m *BaselineClassDenomMutation) {
		m.oldValue = func(context.Context) (*BaselineClassDenom, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BaselineClassDenomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BaselineClassDenomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BaselineClassDenomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BaselineClassDenomMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BaselineClassDenom.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBaselineClassDenomUnits sets the "baseline_class_denom_units" field.
func (m *BaselineClassDenomMutation) SetBaselineClassDenomUnits(s string) {
	m.baseline_class_denom_units = &s
}

// BaselineClassDenomUnits returns the value of the "baseline_class_denom_units" field in the mutation.
func (m *BaselineClassDenomMutation) BaselineClassDenomUnits() (r string, exists bool) {
	v := m.baseline_class_denom_units
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselineClassDenomUnits returns the old "baseline_class_denom_units" field's value of the BaselineClassDenom entity.
// If the BaselineClassDenom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineClassDenomMutation) OldBaselineClassDenomUnits(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselineClassDenomUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselineClassDenomUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselineClassDenomUnits: %w", err)
	}
	return oldValue.BaselineClassDenomUnits, nil
}

// ResetBaselineClassDenomUnits resets all changes to the "baseline_class_denom_units" field.
func (m *BaselineClassDenomMutation) ResetBaselineClassDenomUnits() {
	m.baseline_class_denom_units = nil
}

// SetParentID sets the "parent" edge to the BaselineClass entity by id.
func (m *BaselineClassDenomMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the BaselineClass entity.
func (m *BaselineClassDenomMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the BaselineClass entity was cleared.
func (m *BaselineClassDenomMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *BaselineClassDenomMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *BaselineClassDenomMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *BaselineClassDenomMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddBaselineClassDenomCountListIDs adds the "baseline_class_denom_count_list" edge to the BaselineClassDenomCount entity by ids.
func (m *BaselineClassDenomMutation) AddBaselineClassDenomCountListIDs(ids ...int) {
	if m.baseline_class_denom_count_list == nil {
		m.baseline_class_denom_count_list = make(map[int]struct{})
	}
	for i := range ids {
		m.baseline_class_denom_count_list[ids[i]] = struct{}{}
	}
}

// ClearBaselineClassDenomCountList clears the "baseline_class_denom_count_list" edge to the BaselineClassDenomCount entity.
func (m *BaselineClassDenomMutation) ClearBaselineClassDenomCountList() {
	m.clearedbaseline_class_denom_count_list = true
}

// BaselineClassDenomCountListCleared reports if the "baseline_class_denom_count_list" edge to the BaselineClassDenomCount entity was cleared.
func (m *BaselineClassDenomMutation) BaselineClassDenomCountListCleared() bool {
	return m.clearedbaseline_class_denom_count_list
}

// RemoveBaselineClassDenomCountListIDs removes the "baseline_class_denom_count_list" edge to the BaselineClassDenomCount entity by IDs.
func (m *BaselineClassDenomMutation) RemoveBaselineClassDenomCountListIDs(ids ...int) {
	if m.removedbaseline_class_denom_count_list == nil {
		m.removedbaseline_class_denom_count_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.baseline_class_denom_count_list, ids[i])
		m.removedbaseline_class_denom_count_list[ids[i]] = struct{}{}
	}
}

// RemovedBaselineClassDenomCountList returns the removed IDs of the "baseline_class_denom_count_list" edge to the BaselineClassDenomCount entity.
func (m *BaselineClassDenomMutation) RemovedBaselineClassDenomCountListIDs() (ids []int) {
	for id := range m.removedbaseline_class_denom_count_list {
		ids = append(ids, id)
	}
	return
}

// BaselineClassDenomCountListIDs returns the "baseline_class_denom_count_list" edge IDs in the mutation.
func (m *BaselineClassDenomMutation) BaselineClassDenomCountListIDs() (ids []int) {
	for id := range m.baseline_class_denom_count_list {
		ids = append(ids, id)
	}
	return
}

// ResetBaselineClassDenomCountList resets all changes to the "baseline_class_denom_count_list" edge.
func (m *BaselineClassDenomMutation) ResetBaselineClassDenomCountList() {
	m.baseline_class_denom_count_list = nil
	m.clearedbaseline_class_denom_count_list = false
	m.removedbaseline_class_denom_count_list = nil
}

// Where appends a list predicates to the BaselineClassDenomMutation builder.
func (m *BaselineClassDenomMutation) Where(ps ...predicate.BaselineClassDenom) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BaselineClassDenomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BaselineClassDenom).
func (m *BaselineClassDenomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BaselineClassDenomMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.baseline_class_denom_units != nil {
		fields = append(fields, baselineclassdenom.FieldBaselineClassDenomUnits)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BaselineClassDenomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case baselineclassdenom.FieldBaselineClassDenomUnits:
		return m.BaselineClassDenomUnits()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BaselineClassDenomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case baselineclassdenom.FieldBaselineClassDenomUnits:
		return m.OldBaselineClassDenomUnits(ctx)
	}
	return nil, fmt.Errorf("unknown BaselineClassDenom field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BaselineClassDenomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case baselineclassdenom.FieldBaselineClassDenomUnits:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselineClassDenomUnits(v)
		return nil
	}
	return fmt.Errorf("unknown BaselineClassDenom field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BaselineClassDenomMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BaselineClassDenomMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BaselineClassDenomMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BaselineClassDenom numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BaselineClassDenomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BaselineClassDenomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BaselineClassDenomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BaselineClassDenom nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BaselineClassDenomMutation) ResetField(name string) error {
	switch name {
	case baselineclassdenom.FieldBaselineClassDenomUnits:
		m.ResetBaselineClassDenomUnits()
		return nil
	}
	return fmt.Errorf("unknown BaselineClassDenom field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BaselineClassDenomMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.parent != nil {
		edges = append(edges, baselineclassdenom.EdgeParent)
	}
	if m.baseline_class_denom_count_list != nil {
		edges = append(edges, baselineclassdenom.EdgeBaselineClassDenomCountList)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BaselineClassDenomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case baselineclassdenom.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case baselineclassdenom.EdgeBaselineClassDenomCountList:
		ids := make([]ent.Value, 0, len(m.baseline_class_denom_count_list))
		for id := range m.baseline_class_denom_count_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BaselineClassDenomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedbaseline_class_denom_count_list != nil {
		edges = append(edges, baselineclassdenom.EdgeBaselineClassDenomCountList)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BaselineClassDenomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case baselineclassdenom.EdgeBaselineClassDenomCountList:
		ids := make([]ent.Value, 0, len(m.removedbaseline_class_denom_count_list))
		for id := range m.removedbaseline_class_denom_count_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BaselineClassDenomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedparent {
		edges = append(edges, baselineclassdenom.EdgeParent)
	}
	if m.clearedbaseline_class_denom_count_list {
		edges = append(edges, baselineclassdenom.EdgeBaselineClassDenomCountList)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BaselineClassDenomMutation) EdgeCleared(name string) bool {
	switch name {
	case baselineclassdenom.EdgeParent:
		return m.clearedparent
	case baselineclassdenom.EdgeBaselineClassDenomCountList:
		return m.clearedbaseline_class_denom_count_list
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BaselineClassDenomMutation) ClearEdge(name string) error {
	switch name {
	case baselineclassdenom.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown BaselineClassDenom unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BaselineClassDenomMutation) ResetEdge(name string) error {
	switch name {
	case baselineclassdenom.EdgeParent:
		m.ResetParent()
		return nil
	case baselineclassdenom.EdgeBaselineClassDenomCountList:
		m.ResetBaselineClassDenomCountList()
		return nil
	}
	return fmt.Errorf("unknown BaselineClassDenom edge %s", name)
}

// BaselineClassDenomCountMutation represents an operation that mutates the BaselineClassDenomCount nodes in the graph.
type BaselineClassDenomCountMutation struct {
	config
	op                                  Op
	typ                                 string
	id                                  *int
	baseline_class_denom_count_group_id *string
	baseline_class_denom_count_value    *string
	clearedFields                       map[string]struct{}
	parent                              *int
	clearedparent                       bool
	done                                bool
	oldValue                            func(context.Context) (*BaselineClassDenomCount, error)
	predicates                          []predicate.BaselineClassDenomCount
}

var _ ent.Mutation = (*BaselineClassDenomCountMutation)(nil)

// baselineclassdenomcountOption allows management of the mutation configuration using functional options.
type baselineclassdenomcountOption func(*BaselineClassDenomCountMutation)

// newBaselineClassDenomCountMutation creates new mutation for the BaselineClassDenomCount entity.
func newBaselineClassDenomCountMutation(c config, op Op, opts ...baselineclassdenomcountOption) *BaselineClassDenomCountMutation {
	m := &BaselineClassDenomCountMutation{
		config:        c,
		op:            op,
		typ:           TypeBaselineClassDenomCount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBaselineClassDenomCountID sets the ID field of the mutation.
func withBaselineClassDenomCountID(id int) baselineclassdenomcountOption {
	return func(m *BaselineClassDenomCountMutation) {
		var (
			err   error
			once  sync.Once
			value *BaselineClassDenomCount
		)
		m.oldValue = func(ctx context.Context) (*BaselineClassDenomCount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BaselineClassDenomCount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBaselineClassDenomCount sets the old BaselineClassDenomCount of the mutation.
func withBaselineClassDenomCount(node *BaselineClassDenomCount) baselineclassdenomcountOption {
	return func(m *BaselineClassDenomCountMutation) {
		m.oldValue = func(context.Context) (*BaselineClassDenomCount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BaselineClassDenomCountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BaselineClassDenomCountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BaselineClassDenomCountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BaselineClassDenomCountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BaselineClassDenomCount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBaselineClassDenomCountGroupID sets the "baseline_class_denom_count_group_id" field.
func (m *BaselineClassDenomCountMutation) SetBaselineClassDenomCountGroupID(s string) {
	m.baseline_class_denom_count_group_id = &s
}

// BaselineClassDenomCountGroupID returns the value of the "baseline_class_denom_count_group_id" field in the mutation.
func (m *BaselineClassDenomCountMutation) BaselineClassDenomCountGroupID() (r string, exists bool) {
	v := m.baseline_class_denom_count_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselineClassDenomCountGroupID returns the old "baseline_class_denom_count_group_id" field's value of the BaselineClassDenomCount entity.
// If the BaselineClassDenomCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineClassDenomCountMutation) OldBaselineClassDenomCountGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselineClassDenomCountGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselineClassDenomCountGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselineClassDenomCountGroupID: %w", err)
	}
	return oldValue.BaselineClassDenomCountGroupID, nil
}

// ResetBaselineClassDenomCountGroupID resets all changes to the "baseline_class_denom_count_group_id" field.
func (m *BaselineClassDenomCountMutation) ResetBaselineClassDenomCountGroupID() {
	m.baseline_class_denom_count_group_id = nil
}

// SetBaselineClassDenomCountValue sets the "baseline_class_denom_count_value" field.
func (m *BaselineClassDenomCountMutation) SetBaselineClassDenomCountValue(s string) {
	m.baseline_class_denom_count_value = &s
}

// BaselineClassDenomCountValue returns the value of the "baseline_class_denom_count_value" field in the mutation.
func (m *BaselineClassDenomCountMutation) BaselineClassDenomCountValue() (r string, exists bool) {
	v := m.baseline_class_denom_count_value
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselineClassDenomCountValue returns the old "baseline_class_denom_count_value" field's value of the BaselineClassDenomCount entity.
// If the BaselineClassDenomCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineClassDenomCountMutation) OldBaselineClassDenomCountValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselineClassDenomCountValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselineClassDenomCountValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselineClassDenomCountValue: %w", err)
	}
	return oldValue.BaselineClassDenomCountValue, nil
}

// ResetBaselineClassDenomCountValue resets all changes to the "baseline_class_denom_count_value" field.
func (m *BaselineClassDenomCountMutation) ResetBaselineClassDenomCountValue() {
	m.baseline_class_denom_count_value = nil
}

// SetParentID sets the "parent" edge to the BaselineClassDenom entity by id.
func (m *BaselineClassDenomCountMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the BaselineClassDenom entity.
func (m *BaselineClassDenomCountMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the BaselineClassDenom entity was cleared.
func (m *BaselineClassDenomCountMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *BaselineClassDenomCountMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *BaselineClassDenomCountMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *BaselineClassDenomCountMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// Where appends a list predicates to the BaselineClassDenomCountMutation builder.
func (m *BaselineClassDenomCountMutation) Where(ps ...predicate.BaselineClassDenomCount) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BaselineClassDenomCountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BaselineClassDenomCount).
func (m *BaselineClassDenomCountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BaselineClassDenomCountMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.baseline_class_denom_count_group_id != nil {
		fields = append(fields, baselineclassdenomcount.FieldBaselineClassDenomCountGroupID)
	}
	if m.baseline_class_denom_count_value != nil {
		fields = append(fields, baselineclassdenomcount.FieldBaselineClassDenomCountValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BaselineClassDenomCountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case baselineclassdenomcount.FieldBaselineClassDenomCountGroupID:
		return m.BaselineClassDenomCountGroupID()
	case baselineclassdenomcount.FieldBaselineClassDenomCountValue:
		return m.BaselineClassDenomCountValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BaselineClassDenomCountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case baselineclassdenomcount.FieldBaselineClassDenomCountGroupID:
		return m.OldBaselineClassDenomCountGroupID(ctx)
	case baselineclassdenomcount.FieldBaselineClassDenomCountValue:
		return m.OldBaselineClassDenomCountValue(ctx)
	}
	return nil, fmt.Errorf("unknown BaselineClassDenomCount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BaselineClassDenomCountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case baselineclassdenomcount.FieldBaselineClassDenomCountGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselineClassDenomCountGroupID(v)
		return nil
	case baselineclassdenomcount.FieldBaselineClassDenomCountValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselineClassDenomCountValue(v)
		return nil
	}
	return fmt.Errorf("unknown BaselineClassDenomCount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BaselineClassDenomCountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BaselineClassDenomCountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BaselineClassDenomCountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BaselineClassDenomCount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BaselineClassDenomCountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BaselineClassDenomCountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BaselineClassDenomCountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BaselineClassDenomCount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BaselineClassDenomCountMutation) ResetField(name string) error {
	switch name {
	case baselineclassdenomcount.FieldBaselineClassDenomCountGroupID:
		m.ResetBaselineClassDenomCountGroupID()
		return nil
	case baselineclassdenomcount.FieldBaselineClassDenomCountValue:
		m.ResetBaselineClassDenomCountValue()
		return nil
	}
	return fmt.Errorf("unknown BaselineClassDenomCount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BaselineClassDenomCountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.parent != nil {
		edges = append(edges, baselineclassdenomcount.EdgeParent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BaselineClassDenomCountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case baselineclassdenomcount.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BaselineClassDenomCountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BaselineClassDenomCountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BaselineClassDenomCountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparent {
		edges = append(edges, baselineclassdenomcount.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BaselineClassDenomCountMutation) EdgeCleared(name string) bool {
	switch name {
	case baselineclassdenomcount.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BaselineClassDenomCountMutation) ClearEdge(name string) error {
	switch name {
	case baselineclassdenomcount.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown BaselineClassDenomCount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BaselineClassDenomCountMutation) ResetEdge(name string) error {
	switch name {
	case baselineclassdenomcount.EdgeParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown BaselineClassDenomCount edge %s", name)
}

// BaselineDenomMutation represents an operation that mutates the BaselineDenom nodes in the graph.
type BaselineDenomMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	baseline_denom_units             *string
	clearedFields                    map[string]struct{}
	parent                           *int
	clearedparent                    bool
	baseline_denom_count_list        map[int]struct{}
	removedbaseline_denom_count_list map[int]struct{}
	clearedbaseline_denom_count_list bool
	done                             bool
	oldValue                         func(context.Context) (*BaselineDenom, error)
	predicates                       []predicate.BaselineDenom
}

var _ ent.Mutation = (*BaselineDenomMutation)(nil)

// baselinedenomOption allows management of the mutation configuration using functional options.
type baselinedenomOption func(*BaselineDenomMutation)

// newBaselineDenomMutation creates new mutation for the BaselineDenom entity.
func newBaselineDenomMutation(c config, op Op, opts ...baselinedenomOption) *BaselineDenomMutation {
	m := &BaselineDenomMutation{
		config:        c,
		op:            op,
		typ:           TypeBaselineDenom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBaselineDenomID sets the ID field of the mutation.
func withBaselineDenomID(id int) baselinedenomOption {
	return func(m *BaselineDenomMutation) {
		var (
			err   error
			once  sync.Once
			value *BaselineDenom
		)
		m.oldValue = func(ctx context.Context) (*BaselineDenom, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BaselineDenom.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBaselineDenom sets the old BaselineDenom of the mutation.
func withBaselineDenom(node *BaselineDenom) baselinedenomOption {
	return func(m *BaselineDenomMutation) {
		m.oldValue = func(context.Context) (*BaselineDenom, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BaselineDenomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BaselineDenomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BaselineDenomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BaselineDenomMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BaselineDenom.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBaselineDenomUnits sets the "baseline_denom_units" field.
func (m *BaselineDenomMutation) SetBaselineDenomUnits(s string) {
	m.baseline_denom_units = &s
}

// BaselineDenomUnits returns the value of the "baseline_denom_units" field in the mutation.
func (m *BaselineDenomMutation) BaselineDenomUnits() (r string, exists bool) {
	v := m.baseline_denom_units
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselineDenomUnits returns the old "baseline_denom_units" field's value of the BaselineDenom entity.
// If the BaselineDenom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineDenomMutation) OldBaselineDenomUnits(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselineDenomUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselineDenomUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselineDenomUnits: %w", err)
	}
	return oldValue.BaselineDenomUnits, nil
}

// ResetBaselineDenomUnits resets all changes to the "baseline_denom_units" field.
func (m *BaselineDenomMutation) ResetBaselineDenomUnits() {
	m.baseline_denom_units = nil
}

// SetParentID sets the "parent" edge to the BaselineCharacteristicsModule entity by id.
func (m *BaselineDenomMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the BaselineCharacteristicsModule entity.
func (m *BaselineDenomMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the BaselineCharacteristicsModule entity was cleared.
func (m *BaselineDenomMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *BaselineDenomMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *BaselineDenomMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *BaselineDenomMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddBaselineDenomCountListIDs adds the "baseline_denom_count_list" edge to the BaselineDenomCount entity by ids.
func (m *BaselineDenomMutation) AddBaselineDenomCountListIDs(ids ...int) {
	if m.baseline_denom_count_list == nil {
		m.baseline_denom_count_list = make(map[int]struct{})
	}
	for i := range ids {
		m.baseline_denom_count_list[ids[i]] = struct{}{}
	}
}

// ClearBaselineDenomCountList clears the "baseline_denom_count_list" edge to the BaselineDenomCount entity.
func (m *BaselineDenomMutation) ClearBaselineDenomCountList() {
	m.clearedbaseline_denom_count_list = true
}

// BaselineDenomCountListCleared reports if the "baseline_denom_count_list" edge to the BaselineDenomCount entity was cleared.
func (m *BaselineDenomMutation) BaselineDenomCountListCleared() bool {
	return m.clearedbaseline_denom_count_list
}

// RemoveBaselineDenomCountListIDs removes the "baseline_denom_count_list" edge to the BaselineDenomCount entity by IDs.
func (m *BaselineDenomMutation) RemoveBaselineDenomCountListIDs(ids ...int) {
	if m.removedbaseline_denom_count_list == nil {
		m.removedbaseline_denom_count_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.baseline_denom_count_list, ids[i])
		m.removedbaseline_denom_count_list[ids[i]] = struct{}{}
	}
}

// RemovedBaselineDenomCountList returns the removed IDs of the "baseline_denom_count_list" edge to the BaselineDenomCount entity.
func (m *BaselineDenomMutation) RemovedBaselineDenomCountListIDs() (ids []int) {
	for id := range m.removedbaseline_denom_count_list {
		ids = append(ids, id)
	}
	return
}

// BaselineDenomCountListIDs returns the "baseline_denom_count_list" edge IDs in the mutation.
func (m *BaselineDenomMutation) BaselineDenomCountListIDs() (ids []int) {
	for id := range m.baseline_denom_count_list {
		ids = append(ids, id)
	}
	return
}

// ResetBaselineDenomCountList resets all changes to the "baseline_denom_count_list" edge.
func (m *BaselineDenomMutation) ResetBaselineDenomCountList() {
	m.baseline_denom_count_list = nil
	m.clearedbaseline_denom_count_list = false
	m.removedbaseline_denom_count_list = nil
}

// Where appends a list predicates to the BaselineDenomMutation builder.
func (m *BaselineDenomMutation) Where(ps ...predicate.BaselineDenom) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BaselineDenomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BaselineDenom).
func (m *BaselineDenomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BaselineDenomMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.baseline_denom_units != nil {
		fields = append(fields, baselinedenom.FieldBaselineDenomUnits)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BaselineDenomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case baselinedenom.FieldBaselineDenomUnits:
		return m.BaselineDenomUnits()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BaselineDenomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case baselinedenom.FieldBaselineDenomUnits:
		return m.OldBaselineDenomUnits(ctx)
	}
	return nil, fmt.Errorf("unknown BaselineDenom field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BaselineDenomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case baselinedenom.FieldBaselineDenomUnits:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselineDenomUnits(v)
		return nil
	}
	return fmt.Errorf("unknown BaselineDenom field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BaselineDenomMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BaselineDenomMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BaselineDenomMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BaselineDenom numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BaselineDenomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BaselineDenomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BaselineDenomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BaselineDenom nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BaselineDenomMutation) ResetField(name string) error {
	switch name {
	case baselinedenom.FieldBaselineDenomUnits:
		m.ResetBaselineDenomUnits()
		return nil
	}
	return fmt.Errorf("unknown BaselineDenom field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BaselineDenomMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.parent != nil {
		edges = append(edges, baselinedenom.EdgeParent)
	}
	if m.baseline_denom_count_list != nil {
		edges = append(edges, baselinedenom.EdgeBaselineDenomCountList)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BaselineDenomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case baselinedenom.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case baselinedenom.EdgeBaselineDenomCountList:
		ids := make([]ent.Value, 0, len(m.baseline_denom_count_list))
		for id := range m.baseline_denom_count_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BaselineDenomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedbaseline_denom_count_list != nil {
		edges = append(edges, baselinedenom.EdgeBaselineDenomCountList)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BaselineDenomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case baselinedenom.EdgeBaselineDenomCountList:
		ids := make([]ent.Value, 0, len(m.removedbaseline_denom_count_list))
		for id := range m.removedbaseline_denom_count_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BaselineDenomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedparent {
		edges = append(edges, baselinedenom.EdgeParent)
	}
	if m.clearedbaseline_denom_count_list {
		edges = append(edges, baselinedenom.EdgeBaselineDenomCountList)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BaselineDenomMutation) EdgeCleared(name string) bool {
	switch name {
	case baselinedenom.EdgeParent:
		return m.clearedparent
	case baselinedenom.EdgeBaselineDenomCountList:
		return m.clearedbaseline_denom_count_list
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BaselineDenomMutation) ClearEdge(name string) error {
	switch name {
	case baselinedenom.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown BaselineDenom unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BaselineDenomMutation) ResetEdge(name string) error {
	switch name {
	case baselinedenom.EdgeParent:
		m.ResetParent()
		return nil
	case baselinedenom.EdgeBaselineDenomCountList:
		m.ResetBaselineDenomCountList()
		return nil
	}
	return fmt.Errorf("unknown BaselineDenom edge %s", name)
}

// BaselineDenomCountMutation represents an operation that mutates the BaselineDenomCount nodes in the graph.
type BaselineDenomCountMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	baseline_denom_count_group_id *string
	baseline_denom_count_value    *string
	clearedFields                 map[string]struct{}
	parent                        *int
	clearedparent                 bool
	done                          bool
	oldValue                      func(context.Context) (*BaselineDenomCount, error)
	predicates                    []predicate.BaselineDenomCount
}

var _ ent.Mutation = (*BaselineDenomCountMutation)(nil)

// baselinedenomcountOption allows management of the mutation configuration using functional options.
type baselinedenomcountOption func(*BaselineDenomCountMutation)

// newBaselineDenomCountMutation creates new mutation for the BaselineDenomCount entity.
func newBaselineDenomCountMutation(c config, op Op, opts ...baselinedenomcountOption) *BaselineDenomCountMutation {
	m := &BaselineDenomCountMutation{
		config:        c,
		op:            op,
		typ:           TypeBaselineDenomCount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBaselineDenomCountID sets the ID field of the mutation.
func withBaselineDenomCountID(id int) baselinedenomcountOption {
	return func(m *BaselineDenomCountMutation) {
		var (
			err   error
			once  sync.Once
			value *BaselineDenomCount
		)
		m.oldValue = func(ctx context.Context) (*BaselineDenomCount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BaselineDenomCount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBaselineDenomCount sets the old BaselineDenomCount of the mutation.
func withBaselineDenomCount(node *BaselineDenomCount) baselinedenomcountOption {
	return func(m *BaselineDenomCountMutation) {
		m.oldValue = func(context.Context) (*BaselineDenomCount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BaselineDenomCountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BaselineDenomCountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BaselineDenomCountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BaselineDenomCountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BaselineDenomCount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBaselineDenomCountGroupID sets the "baseline_denom_count_group_id" field.
func (m *BaselineDenomCountMutation) SetBaselineDenomCountGroupID(s string) {
	m.baseline_denom_count_group_id = &s
}

// BaselineDenomCountGroupID returns the value of the "baseline_denom_count_group_id" field in the mutation.
func (m *BaselineDenomCountMutation) BaselineDenomCountGroupID() (r string, exists bool) {
	v := m.baseline_denom_count_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselineDenomCountGroupID returns the old "baseline_denom_count_group_id" field's value of the BaselineDenomCount entity.
// If the BaselineDenomCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineDenomCountMutation) OldBaselineDenomCountGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselineDenomCountGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselineDenomCountGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselineDenomCountGroupID: %w", err)
	}
	return oldValue.BaselineDenomCountGroupID, nil
}

// ResetBaselineDenomCountGroupID resets all changes to the "baseline_denom_count_group_id" field.
func (m *BaselineDenomCountMutation) ResetBaselineDenomCountGroupID() {
	m.baseline_denom_count_group_id = nil
}

// SetBaselineDenomCountValue sets the "baseline_denom_count_value" field.
func (m *BaselineDenomCountMutation) SetBaselineDenomCountValue(s string) {
	m.baseline_denom_count_value = &s
}

// BaselineDenomCountValue returns the value of the "baseline_denom_count_value" field in the mutation.
func (m *BaselineDenomCountMutation) BaselineDenomCountValue() (r string, exists bool) {
	v := m.baseline_denom_count_value
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselineDenomCountValue returns the old "baseline_denom_count_value" field's value of the BaselineDenomCount entity.
// If the BaselineDenomCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineDenomCountMutation) OldBaselineDenomCountValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselineDenomCountValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselineDenomCountValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselineDenomCountValue: %w", err)
	}
	return oldValue.BaselineDenomCountValue, nil
}

// ResetBaselineDenomCountValue resets all changes to the "baseline_denom_count_value" field.
func (m *BaselineDenomCountMutation) ResetBaselineDenomCountValue() {
	m.baseline_denom_count_value = nil
}

// SetParentID sets the "parent" edge to the BaselineDenom entity by id.
func (m *BaselineDenomCountMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the BaselineDenom entity.
func (m *BaselineDenomCountMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the BaselineDenom entity was cleared.
func (m *BaselineDenomCountMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *BaselineDenomCountMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *BaselineDenomCountMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *BaselineDenomCountMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// Where appends a list predicates to the BaselineDenomCountMutation builder.
func (m *BaselineDenomCountMutation) Where(ps ...predicate.BaselineDenomCount) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BaselineDenomCountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BaselineDenomCount).
func (m *BaselineDenomCountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BaselineDenomCountMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.baseline_denom_count_group_id != nil {
		fields = append(fields, baselinedenomcount.FieldBaselineDenomCountGroupID)
	}
	if m.baseline_denom_count_value != nil {
		fields = append(fields, baselinedenomcount.FieldBaselineDenomCountValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BaselineDenomCountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case baselinedenomcount.FieldBaselineDenomCountGroupID:
		return m.BaselineDenomCountGroupID()
	case baselinedenomcount.FieldBaselineDenomCountValue:
		return m.BaselineDenomCountValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BaselineDenomCountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case baselinedenomcount.FieldBaselineDenomCountGroupID:
		return m.OldBaselineDenomCountGroupID(ctx)
	case baselinedenomcount.FieldBaselineDenomCountValue:
		return m.OldBaselineDenomCountValue(ctx)
	}
	return nil, fmt.Errorf("unknown BaselineDenomCount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BaselineDenomCountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case baselinedenomcount.FieldBaselineDenomCountGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselineDenomCountGroupID(v)
		return nil
	case baselinedenomcount.FieldBaselineDenomCountValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselineDenomCountValue(v)
		return nil
	}
	return fmt.Errorf("unknown BaselineDenomCount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BaselineDenomCountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BaselineDenomCountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BaselineDenomCountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BaselineDenomCount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BaselineDenomCountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BaselineDenomCountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BaselineDenomCountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BaselineDenomCount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BaselineDenomCountMutation) ResetField(name string) error {
	switch name {
	case baselinedenomcount.FieldBaselineDenomCountGroupID:
		m.ResetBaselineDenomCountGroupID()
		return nil
	case baselinedenomcount.FieldBaselineDenomCountValue:
		m.ResetBaselineDenomCountValue()
		return nil
	}
	return fmt.Errorf("unknown BaselineDenomCount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BaselineDenomCountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.parent != nil {
		edges = append(edges, baselinedenomcount.EdgeParent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BaselineDenomCountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case baselinedenomcount.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BaselineDenomCountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BaselineDenomCountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BaselineDenomCountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparent {
		edges = append(edges, baselinedenomcount.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BaselineDenomCountMutation) EdgeCleared(name string) bool {
	switch name {
	case baselinedenomcount.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BaselineDenomCountMutation) ClearEdge(name string) error {
	switch name {
	case baselinedenomcount.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown BaselineDenomCount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BaselineDenomCountMutation) ResetEdge(name string) error {
	switch name {
	case baselinedenomcount.EdgeParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown BaselineDenomCount edge %s", name)
}

// BaselineGroupMutation represents an operation that mutates the BaselineGroup nodes in the graph.
type BaselineGroupMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	baseline_group_id          *string
	baseline_group_title       *string
	baseline_group_description *string
	clearedFields              map[string]struct{}
	parent                     *int
	clearedparent              bool
	done                       bool
	oldValue                   func(context.Context) (*BaselineGroup, error)
	predicates                 []predicate.BaselineGroup
}

var _ ent.Mutation = (*BaselineGroupMutation)(nil)

// baselinegroupOption allows management of the mutation configuration using functional options.
type baselinegroupOption func(*BaselineGroupMutation)

// newBaselineGroupMutation creates new mutation for the BaselineGroup entity.
func newBaselineGroupMutation(c config, op Op, opts ...baselinegroupOption) *BaselineGroupMutation {
	m := &BaselineGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeBaselineGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBaselineGroupID sets the ID field of the mutation.
func withBaselineGroupID(id int) baselinegroupOption {
	return func(m *BaselineGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *BaselineGroup
		)
		m.oldValue = func(ctx context.Context) (*BaselineGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BaselineGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBaselineGroup sets the old BaselineGroup of the mutation.
func withBaselineGroup(node *BaselineGroup) baselinegroupOption {
	return func(m *BaselineGroupMutation) {
		m.oldValue = func(context.Context) (*BaselineGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BaselineGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BaselineGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BaselineGroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BaselineGroupMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BaselineGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBaselineGroupID sets the "baseline_group_id" field.
func (m *BaselineGroupMutation) SetBaselineGroupID(s string) {
	m.baseline_group_id = &s
}

// BaselineGroupID returns the value of the "baseline_group_id" field in the mutation.
func (m *BaselineGroupMutation) BaselineGroupID() (r string, exists bool) {
	v := m.baseline_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselineGroupID returns the old "baseline_group_id" field's value of the BaselineGroup entity.
// If the BaselineGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineGroupMutation) OldBaselineGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselineGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselineGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselineGroupID: %w", err)
	}
	return oldValue.BaselineGroupID, nil
}

// ResetBaselineGroupID resets all changes to the "baseline_group_id" field.
func (m *BaselineGroupMutation) ResetBaselineGroupID() {
	m.baseline_group_id = nil
}

// SetBaselineGroupTitle sets the "baseline_group_title" field.
func (m *BaselineGroupMutation) SetBaselineGroupTitle(s string) {
	m.baseline_group_title = &s
}

// BaselineGroupTitle returns the value of the "baseline_group_title" field in the mutation.
func (m *BaselineGroupMutation) BaselineGroupTitle() (r string, exists bool) {
	v := m.baseline_group_title
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselineGroupTitle returns the old "baseline_group_title" field's value of the BaselineGroup entity.
// If the BaselineGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineGroupMutation) OldBaselineGroupTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselineGroupTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselineGroupTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselineGroupTitle: %w", err)
	}
	return oldValue.BaselineGroupTitle, nil
}

// ResetBaselineGroupTitle resets all changes to the "baseline_group_title" field.
func (m *BaselineGroupMutation) ResetBaselineGroupTitle() {
	m.baseline_group_title = nil
}

// SetBaselineGroupDescription sets the "baseline_group_description" field.
func (m *BaselineGroupMutation) SetBaselineGroupDescription(s string) {
	m.baseline_group_description = &s
}

// BaselineGroupDescription returns the value of the "baseline_group_description" field in the mutation.
func (m *BaselineGroupMutation) BaselineGroupDescription() (r string, exists bool) {
	v := m.baseline_group_description
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselineGroupDescription returns the old "baseline_group_description" field's value of the BaselineGroup entity.
// If the BaselineGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineGroupMutation) OldBaselineGroupDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselineGroupDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselineGroupDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselineGroupDescription: %w", err)
	}
	return oldValue.BaselineGroupDescription, nil
}

// ResetBaselineGroupDescription resets all changes to the "baseline_group_description" field.
func (m *BaselineGroupMutation) ResetBaselineGroupDescription() {
	m.baseline_group_description = nil
}

// SetParentID sets the "parent" edge to the BaselineCharacteristicsModule entity by id.
func (m *BaselineGroupMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the BaselineCharacteristicsModule entity.
func (m *BaselineGroupMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the BaselineCharacteristicsModule entity was cleared.
func (m *BaselineGroupMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *BaselineGroupMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *BaselineGroupMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *BaselineGroupMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// Where appends a list predicates to the BaselineGroupMutation builder.
func (m *BaselineGroupMutation) Where(ps ...predicate.BaselineGroup) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BaselineGroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BaselineGroup).
func (m *BaselineGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BaselineGroupMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.baseline_group_id != nil {
		fields = append(fields, baselinegroup.FieldBaselineGroupID)
	}
	if m.baseline_group_title != nil {
		fields = append(fields, baselinegroup.FieldBaselineGroupTitle)
	}
	if m.baseline_group_description != nil {
		fields = append(fields, baselinegroup.FieldBaselineGroupDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BaselineGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case baselinegroup.FieldBaselineGroupID:
		return m.BaselineGroupID()
	case baselinegroup.FieldBaselineGroupTitle:
		return m.BaselineGroupTitle()
	case baselinegroup.FieldBaselineGroupDescription:
		return m.BaselineGroupDescription()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BaselineGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case baselinegroup.FieldBaselineGroupID:
		return m.OldBaselineGroupID(ctx)
	case baselinegroup.FieldBaselineGroupTitle:
		return m.OldBaselineGroupTitle(ctx)
	case baselinegroup.FieldBaselineGroupDescription:
		return m.OldBaselineGroupDescription(ctx)
	}
	return nil, fmt.Errorf("unknown BaselineGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BaselineGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case baselinegroup.FieldBaselineGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselineGroupID(v)
		return nil
	case baselinegroup.FieldBaselineGroupTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselineGroupTitle(v)
		return nil
	case baselinegroup.FieldBaselineGroupDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselineGroupDescription(v)
		return nil
	}
	return fmt.Errorf("unknown BaselineGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BaselineGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BaselineGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BaselineGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BaselineGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BaselineGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BaselineGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BaselineGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BaselineGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BaselineGroupMutation) ResetField(name string) error {
	switch name {
	case baselinegroup.FieldBaselineGroupID:
		m.ResetBaselineGroupID()
		return nil
	case baselinegroup.FieldBaselineGroupTitle:
		m.ResetBaselineGroupTitle()
		return nil
	case baselinegroup.FieldBaselineGroupDescription:
		m.ResetBaselineGroupDescription()
		return nil
	}
	return fmt.Errorf("unknown BaselineGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BaselineGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.parent != nil {
		edges = append(edges, baselinegroup.EdgeParent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BaselineGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case baselinegroup.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BaselineGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BaselineGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BaselineGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparent {
		edges = append(edges, baselinegroup.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BaselineGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case baselinegroup.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BaselineGroupMutation) ClearEdge(name string) error {
	switch name {
	case baselinegroup.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown BaselineGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BaselineGroupMutation) ResetEdge(name string) error {
	switch name {
	case baselinegroup.EdgeParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown BaselineGroup edge %s", name)
}

// BaselineMeasureMutation represents an operation that mutates the BaselineMeasure nodes in the graph.
type BaselineMeasureMutation struct {
	config
	op                                      Op
	typ                                     string
	id                                      *int
	baseline_measure_title                  *string
	baseline_measure_description            *string
	baseline_measure_population_description *string
	baseline_measure_param_type             *string
	baseline_measure_dispersion_type        *string
	baseline_measure_unit_of_measure        *string
	baseline_measure_calculate_pct          *string
	baseline_measure_denom_units_selected   *string
	clearedFields                           map[string]struct{}
	parent                                  *int
	clearedparent                           bool
	baseline_measure_denom_list             map[int]struct{}
	removedbaseline_measure_denom_list      map[int]struct{}
	clearedbaseline_measure_denom_list      bool
	baseline_class_list                     map[int]struct{}
	removedbaseline_class_list              map[int]struct{}
	clearedbaseline_class_list              bool
	done                                    bool
	oldValue                                func(context.Context) (*BaselineMeasure, error)
	predicates                              []predicate.BaselineMeasure
}

var _ ent.Mutation = (*BaselineMeasureMutation)(nil)

// baselinemeasureOption allows management of the mutation configuration using functional options.
type baselinemeasureOption func(*BaselineMeasureMutation)

// newBaselineMeasureMutation creates new mutation for the BaselineMeasure entity.
func newBaselineMeasureMutation(c config, op Op, opts ...baselinemeasureOption) *BaselineMeasureMutation {
	m := &BaselineMeasureMutation{
		config:        c,
		op:            op,
		typ:           TypeBaselineMeasure,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBaselineMeasureID sets the ID field of the mutation.
func withBaselineMeasureID(id int) baselinemeasureOption {
	return func(m *BaselineMeasureMutation) {
		var (
			err   error
			once  sync.Once
			value *BaselineMeasure
		)
		m.oldValue = func(ctx context.Context) (*BaselineMeasure, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BaselineMeasure.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBaselineMeasure sets the old BaselineMeasure of the mutation.
func withBaselineMeasure(node *BaselineMeasure) baselinemeasureOption {
	return func(m *BaselineMeasureMutation) {
		m.oldValue = func(context.Context) (*BaselineMeasure, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BaselineMeasureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BaselineMeasureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BaselineMeasureMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BaselineMeasureMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BaselineMeasure.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBaselineMeasureTitle sets the "baseline_measure_title" field.
func (m *BaselineMeasureMutation) SetBaselineMeasureTitle(s string) {
	m.baseline_measure_title = &s
}

// BaselineMeasureTitle returns the value of the "baseline_measure_title" field in the mutation.
func (m *BaselineMeasureMutation) BaselineMeasureTitle() (r string, exists bool) {
	v := m.baseline_measure_title
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselineMeasureTitle returns the old "baseline_measure_title" field's value of the BaselineMeasure entity.
// If the BaselineMeasure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineMeasureMutation) OldBaselineMeasureTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselineMeasureTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselineMeasureTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselineMeasureTitle: %w", err)
	}
	return oldValue.BaselineMeasureTitle, nil
}

// ResetBaselineMeasureTitle resets all changes to the "baseline_measure_title" field.
func (m *BaselineMeasureMutation) ResetBaselineMeasureTitle() {
	m.baseline_measure_title = nil
}

// SetBaselineMeasureDescription sets the "baseline_measure_description" field.
func (m *BaselineMeasureMutation) SetBaselineMeasureDescription(s string) {
	m.baseline_measure_description = &s
}

// BaselineMeasureDescription returns the value of the "baseline_measure_description" field in the mutation.
func (m *BaselineMeasureMutation) BaselineMeasureDescription() (r string, exists bool) {
	v := m.baseline_measure_description
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselineMeasureDescription returns the old "baseline_measure_description" field's value of the BaselineMeasure entity.
// If the BaselineMeasure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineMeasureMutation) OldBaselineMeasureDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselineMeasureDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselineMeasureDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselineMeasureDescription: %w", err)
	}
	return oldValue.BaselineMeasureDescription, nil
}

// ResetBaselineMeasureDescription resets all changes to the "baseline_measure_description" field.
func (m *BaselineMeasureMutation) ResetBaselineMeasureDescription() {
	m.baseline_measure_description = nil
}

// SetBaselineMeasurePopulationDescription sets the "baseline_measure_population_description" field.
func (m *BaselineMeasureMutation) SetBaselineMeasurePopulationDescription(s string) {
	m.baseline_measure_population_description = &s
}

// BaselineMeasurePopulationDescription returns the value of the "baseline_measure_population_description" field in the mutation.
func (m *BaselineMeasureMutation) BaselineMeasurePopulationDescription() (r string, exists bool) {
	v := m.baseline_measure_population_description
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselineMeasurePopulationDescription returns the old "baseline_measure_population_description" field's value of the BaselineMeasure entity.
// If the BaselineMeasure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineMeasureMutation) OldBaselineMeasurePopulationDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselineMeasurePopulationDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselineMeasurePopulationDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselineMeasurePopulationDescription: %w", err)
	}
	return oldValue.BaselineMeasurePopulationDescription, nil
}

// ResetBaselineMeasurePopulationDescription resets all changes to the "baseline_measure_population_description" field.
func (m *BaselineMeasureMutation) ResetBaselineMeasurePopulationDescription() {
	m.baseline_measure_population_description = nil
}

// SetBaselineMeasureParamType sets the "baseline_measure_param_type" field.
func (m *BaselineMeasureMutation) SetBaselineMeasureParamType(s string) {
	m.baseline_measure_param_type = &s
}

// BaselineMeasureParamType returns the value of the "baseline_measure_param_type" field in the mutation.
func (m *BaselineMeasureMutation) BaselineMeasureParamType() (r string, exists bool) {
	v := m.baseline_measure_param_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselineMeasureParamType returns the old "baseline_measure_param_type" field's value of the BaselineMeasure entity.
// If the BaselineMeasure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineMeasureMutation) OldBaselineMeasureParamType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselineMeasureParamType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselineMeasureParamType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselineMeasureParamType: %w", err)
	}
	return oldValue.BaselineMeasureParamType, nil
}

// ResetBaselineMeasureParamType resets all changes to the "baseline_measure_param_type" field.
func (m *BaselineMeasureMutation) ResetBaselineMeasureParamType() {
	m.baseline_measure_param_type = nil
}

// SetBaselineMeasureDispersionType sets the "baseline_measure_dispersion_type" field.
func (m *BaselineMeasureMutation) SetBaselineMeasureDispersionType(s string) {
	m.baseline_measure_dispersion_type = &s
}

// BaselineMeasureDispersionType returns the value of the "baseline_measure_dispersion_type" field in the mutation.
func (m *BaselineMeasureMutation) BaselineMeasureDispersionType() (r string, exists bool) {
	v := m.baseline_measure_dispersion_type
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselineMeasureDispersionType returns the old "baseline_measure_dispersion_type" field's value of the BaselineMeasure entity.
// If the BaselineMeasure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineMeasureMutation) OldBaselineMeasureDispersionType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselineMeasureDispersionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselineMeasureDispersionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselineMeasureDispersionType: %w", err)
	}
	return oldValue.BaselineMeasureDispersionType, nil
}

// ResetBaselineMeasureDispersionType resets all changes to the "baseline_measure_dispersion_type" field.
func (m *BaselineMeasureMutation) ResetBaselineMeasureDispersionType() {
	m.baseline_measure_dispersion_type = nil
}

// SetBaselineMeasureUnitOfMeasure sets the "baseline_measure_unit_of_measure" field.
func (m *BaselineMeasureMutation) SetBaselineMeasureUnitOfMeasure(s string) {
	m.baseline_measure_unit_of_measure = &s
}

// BaselineMeasureUnitOfMeasure returns the value of the "baseline_measure_unit_of_measure" field in the mutation.
func (m *BaselineMeasureMutation) BaselineMeasureUnitOfMeasure() (r string, exists bool) {
	v := m.baseline_measure_unit_of_measure
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselineMeasureUnitOfMeasure returns the old "baseline_measure_unit_of_measure" field's value of the BaselineMeasure entity.
// If the BaselineMeasure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineMeasureMutation) OldBaselineMeasureUnitOfMeasure(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselineMeasureUnitOfMeasure is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselineMeasureUnitOfMeasure requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselineMeasureUnitOfMeasure: %w", err)
	}
	return oldValue.BaselineMeasureUnitOfMeasure, nil
}

// ResetBaselineMeasureUnitOfMeasure resets all changes to the "baseline_measure_unit_of_measure" field.
func (m *BaselineMeasureMutation) ResetBaselineMeasureUnitOfMeasure() {
	m.baseline_measure_unit_of_measure = nil
}

// SetBaselineMeasureCalculatePct sets the "baseline_measure_calculate_pct" field.
func (m *BaselineMeasureMutation) SetBaselineMeasureCalculatePct(s string) {
	m.baseline_measure_calculate_pct = &s
}

// BaselineMeasureCalculatePct returns the value of the "baseline_measure_calculate_pct" field in the mutation.
func (m *BaselineMeasureMutation) BaselineMeasureCalculatePct() (r string, exists bool) {
	v := m.baseline_measure_calculate_pct
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselineMeasureCalculatePct returns the old "baseline_measure_calculate_pct" field's value of the BaselineMeasure entity.
// If the BaselineMeasure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineMeasureMutation) OldBaselineMeasureCalculatePct(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselineMeasureCalculatePct is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselineMeasureCalculatePct requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselineMeasureCalculatePct: %w", err)
	}
	return oldValue.BaselineMeasureCalculatePct, nil
}

// ResetBaselineMeasureCalculatePct resets all changes to the "baseline_measure_calculate_pct" field.
func (m *BaselineMeasureMutation) ResetBaselineMeasureCalculatePct() {
	m.baseline_measure_calculate_pct = nil
}

// SetBaselineMeasureDenomUnitsSelected sets the "baseline_measure_denom_units_selected" field.
func (m *BaselineMeasureMutation) SetBaselineMeasureDenomUnitsSelected(s string) {
	m.baseline_measure_denom_units_selected = &s
}

// BaselineMeasureDenomUnitsSelected returns the value of the "baseline_measure_denom_units_selected" field in the mutation.
func (m *BaselineMeasureMutation) BaselineMeasureDenomUnitsSelected() (r string, exists bool) {
	v := m.baseline_measure_denom_units_selected
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselineMeasureDenomUnitsSelected returns the old "baseline_measure_denom_units_selected" field's value of the BaselineMeasure entity.
// If the BaselineMeasure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineMeasureMutation) OldBaselineMeasureDenomUnitsSelected(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselineMeasureDenomUnitsSelected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselineMeasureDenomUnitsSelected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselineMeasureDenomUnitsSelected: %w", err)
	}
	return oldValue.BaselineMeasureDenomUnitsSelected, nil
}

// ResetBaselineMeasureDenomUnitsSelected resets all changes to the "baseline_measure_denom_units_selected" field.
func (m *BaselineMeasureMutation) ResetBaselineMeasureDenomUnitsSelected() {
	m.baseline_measure_denom_units_selected = nil
}

// SetParentID sets the "parent" edge to the BaselineCharacteristicsModule entity by id.
func (m *BaselineMeasureMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the BaselineCharacteristicsModule entity.
func (m *BaselineMeasureMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the BaselineCharacteristicsModule entity was cleared.
func (m *BaselineMeasureMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *BaselineMeasureMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *BaselineMeasureMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *BaselineMeasureMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddBaselineMeasureDenomListIDs adds the "baseline_measure_denom_list" edge to the BaselineMeasureDenom entity by ids.
func (m *BaselineMeasureMutation) AddBaselineMeasureDenomListIDs(ids ...int) {
	if m.baseline_measure_denom_list == nil {
		m.baseline_measure_denom_list = make(map[int]struct{})
	}
	for i := range ids {
		m.baseline_measure_denom_list[ids[i]] = struct{}{}
	}
}

// ClearBaselineMeasureDenomList clears the "baseline_measure_denom_list" edge to the BaselineMeasureDenom entity.
func (m *BaselineMeasureMutation) ClearBaselineMeasureDenomList() {
	m.clearedbaseline_measure_denom_list = true
}

// BaselineMeasureDenomListCleared reports if the "baseline_measure_denom_list" edge to the BaselineMeasureDenom entity was cleared.
func (m *BaselineMeasureMutation) BaselineMeasureDenomListCleared() bool {
	return m.clearedbaseline_measure_denom_list
}

// RemoveBaselineMeasureDenomListIDs removes the "baseline_measure_denom_list" edge to the BaselineMeasureDenom entity by IDs.
func (m *BaselineMeasureMutation) RemoveBaselineMeasureDenomListIDs(ids ...int) {
	if m.removedbaseline_measure_denom_list == nil {
		m.removedbaseline_measure_denom_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.baseline_measure_denom_list, ids[i])
		m.removedbaseline_measure_denom_list[ids[i]] = struct{}{}
	}
}

// RemovedBaselineMeasureDenomList returns the removed IDs of the "baseline_measure_denom_list" edge to the BaselineMeasureDenom entity.
func (m *BaselineMeasureMutation) RemovedBaselineMeasureDenomListIDs() (ids []int) {
	for id := range m.removedbaseline_measure_denom_list {
		ids = append(ids, id)
	}
	return
}

// BaselineMeasureDenomListIDs returns the "baseline_measure_denom_list" edge IDs in the mutation.
func (m *BaselineMeasureMutation) BaselineMeasureDenomListIDs() (ids []int) {
	for id := range m.baseline_measure_denom_list {
		ids = append(ids, id)
	}
	return
}

// ResetBaselineMeasureDenomList resets all changes to the "baseline_measure_denom_list" edge.
func (m *BaselineMeasureMutation) ResetBaselineMeasureDenomList() {
	m.baseline_measure_denom_list = nil
	m.clearedbaseline_measure_denom_list = false
	m.removedbaseline_measure_denom_list = nil
}

// AddBaselineClassListIDs adds the "baseline_class_list" edge to the BaselineClass entity by ids.
func (m *BaselineMeasureMutation) AddBaselineClassListIDs(ids ...int) {
	if m.baseline_class_list == nil {
		m.baseline_class_list = make(map[int]struct{})
	}
	for i := range ids {
		m.baseline_class_list[ids[i]] = struct{}{}
	}
}

// ClearBaselineClassList clears the "baseline_class_list" edge to the BaselineClass entity.
func (m *BaselineMeasureMutation) ClearBaselineClassList() {
	m.clearedbaseline_class_list = true
}

// BaselineClassListCleared reports if the "baseline_class_list" edge to the BaselineClass entity was cleared.
func (m *BaselineMeasureMutation) BaselineClassListCleared() bool {
	return m.clearedbaseline_class_list
}

// RemoveBaselineClassListIDs removes the "baseline_class_list" edge to the BaselineClass entity by IDs.
func (m *BaselineMeasureMutation) RemoveBaselineClassListIDs(ids ...int) {
	if m.removedbaseline_class_list == nil {
		m.removedbaseline_class_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.baseline_class_list, ids[i])
		m.removedbaseline_class_list[ids[i]] = struct{}{}
	}
}

// RemovedBaselineClassList returns the removed IDs of the "baseline_class_list" edge to the BaselineClass entity.
func (m *BaselineMeasureMutation) RemovedBaselineClassListIDs() (ids []int) {
	for id := range m.removedbaseline_class_list {
		ids = append(ids, id)
	}
	return
}

// BaselineClassListIDs returns the "baseline_class_list" edge IDs in the mutation.
func (m *BaselineMeasureMutation) BaselineClassListIDs() (ids []int) {
	for id := range m.baseline_class_list {
		ids = append(ids, id)
	}
	return
}

// ResetBaselineClassList resets all changes to the "baseline_class_list" edge.
func (m *BaselineMeasureMutation) ResetBaselineClassList() {
	m.baseline_class_list = nil
	m.clearedbaseline_class_list = false
	m.removedbaseline_class_list = nil
}

// Where appends a list predicates to the BaselineMeasureMutation builder.
func (m *BaselineMeasureMutation) Where(ps ...predicate.BaselineMeasure) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BaselineMeasureMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BaselineMeasure).
func (m *BaselineMeasureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BaselineMeasureMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.baseline_measure_title != nil {
		fields = append(fields, baselinemeasure.FieldBaselineMeasureTitle)
	}
	if m.baseline_measure_description != nil {
		fields = append(fields, baselinemeasure.FieldBaselineMeasureDescription)
	}
	if m.baseline_measure_population_description != nil {
		fields = append(fields, baselinemeasure.FieldBaselineMeasurePopulationDescription)
	}
	if m.baseline_measure_param_type != nil {
		fields = append(fields, baselinemeasure.FieldBaselineMeasureParamType)
	}
	if m.baseline_measure_dispersion_type != nil {
		fields = append(fields, baselinemeasure.FieldBaselineMeasureDispersionType)
	}
	if m.baseline_measure_unit_of_measure != nil {
		fields = append(fields, baselinemeasure.FieldBaselineMeasureUnitOfMeasure)
	}
	if m.baseline_measure_calculate_pct != nil {
		fields = append(fields, baselinemeasure.FieldBaselineMeasureCalculatePct)
	}
	if m.baseline_measure_denom_units_selected != nil {
		fields = append(fields, baselinemeasure.FieldBaselineMeasureDenomUnitsSelected)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BaselineMeasureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case baselinemeasure.FieldBaselineMeasureTitle:
		return m.BaselineMeasureTitle()
	case baselinemeasure.FieldBaselineMeasureDescription:
		return m.BaselineMeasureDescription()
	case baselinemeasure.FieldBaselineMeasurePopulationDescription:
		return m.BaselineMeasurePopulationDescription()
	case baselinemeasure.FieldBaselineMeasureParamType:
		return m.BaselineMeasureParamType()
	case baselinemeasure.FieldBaselineMeasureDispersionType:
		return m.BaselineMeasureDispersionType()
	case baselinemeasure.FieldBaselineMeasureUnitOfMeasure:
		return m.BaselineMeasureUnitOfMeasure()
	case baselinemeasure.FieldBaselineMeasureCalculatePct:
		return m.BaselineMeasureCalculatePct()
	case baselinemeasure.FieldBaselineMeasureDenomUnitsSelected:
		return m.BaselineMeasureDenomUnitsSelected()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BaselineMeasureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case baselinemeasure.FieldBaselineMeasureTitle:
		return m.OldBaselineMeasureTitle(ctx)
	case baselinemeasure.FieldBaselineMeasureDescription:
		return m.OldBaselineMeasureDescription(ctx)
	case baselinemeasure.FieldBaselineMeasurePopulationDescription:
		return m.OldBaselineMeasurePopulationDescription(ctx)
	case baselinemeasure.FieldBaselineMeasureParamType:
		return m.OldBaselineMeasureParamType(ctx)
	case baselinemeasure.FieldBaselineMeasureDispersionType:
		return m.OldBaselineMeasureDispersionType(ctx)
	case baselinemeasure.FieldBaselineMeasureUnitOfMeasure:
		return m.OldBaselineMeasureUnitOfMeasure(ctx)
	case baselinemeasure.FieldBaselineMeasureCalculatePct:
		return m.OldBaselineMeasureCalculatePct(ctx)
	case baselinemeasure.FieldBaselineMeasureDenomUnitsSelected:
		return m.OldBaselineMeasureDenomUnitsSelected(ctx)
	}
	return nil, fmt.Errorf("unknown BaselineMeasure field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BaselineMeasureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case baselinemeasure.FieldBaselineMeasureTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselineMeasureTitle(v)
		return nil
	case baselinemeasure.FieldBaselineMeasureDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselineMeasureDescription(v)
		return nil
	case baselinemeasure.FieldBaselineMeasurePopulationDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselineMeasurePopulationDescription(v)
		return nil
	case baselinemeasure.FieldBaselineMeasureParamType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselineMeasureParamType(v)
		return nil
	case baselinemeasure.FieldBaselineMeasureDispersionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselineMeasureDispersionType(v)
		return nil
	case baselinemeasure.FieldBaselineMeasureUnitOfMeasure:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselineMeasureUnitOfMeasure(v)
		return nil
	case baselinemeasure.FieldBaselineMeasureCalculatePct:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselineMeasureCalculatePct(v)
		return nil
	case baselinemeasure.FieldBaselineMeasureDenomUnitsSelected:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselineMeasureDenomUnitsSelected(v)
		return nil
	}
	return fmt.Errorf("unknown BaselineMeasure field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BaselineMeasureMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BaselineMeasureMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BaselineMeasureMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BaselineMeasure numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BaselineMeasureMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BaselineMeasureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BaselineMeasureMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BaselineMeasure nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BaselineMeasureMutation) ResetField(name string) error {
	switch name {
	case baselinemeasure.FieldBaselineMeasureTitle:
		m.ResetBaselineMeasureTitle()
		return nil
	case baselinemeasure.FieldBaselineMeasureDescription:
		m.ResetBaselineMeasureDescription()
		return nil
	case baselinemeasure.FieldBaselineMeasurePopulationDescription:
		m.ResetBaselineMeasurePopulationDescription()
		return nil
	case baselinemeasure.FieldBaselineMeasureParamType:
		m.ResetBaselineMeasureParamType()
		return nil
	case baselinemeasure.FieldBaselineMeasureDispersionType:
		m.ResetBaselineMeasureDispersionType()
		return nil
	case baselinemeasure.FieldBaselineMeasureUnitOfMeasure:
		m.ResetBaselineMeasureUnitOfMeasure()
		return nil
	case baselinemeasure.FieldBaselineMeasureCalculatePct:
		m.ResetBaselineMeasureCalculatePct()
		return nil
	case baselinemeasure.FieldBaselineMeasureDenomUnitsSelected:
		m.ResetBaselineMeasureDenomUnitsSelected()
		return nil
	}
	return fmt.Errorf("unknown BaselineMeasure field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BaselineMeasureMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent != nil {
		edges = append(edges, baselinemeasure.EdgeParent)
	}
	if m.baseline_measure_denom_list != nil {
		edges = append(edges, baselinemeasure.EdgeBaselineMeasureDenomList)
	}
	if m.baseline_class_list != nil {
		edges = append(edges, baselinemeasure.EdgeBaselineClassList)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BaselineMeasureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case baselinemeasure.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case baselinemeasure.EdgeBaselineMeasureDenomList:
		ids := make([]ent.Value, 0, len(m.baseline_measure_denom_list))
		for id := range m.baseline_measure_denom_list {
			ids = append(ids, id)
		}
		return ids
	case baselinemeasure.EdgeBaselineClassList:
		ids := make([]ent.Value, 0, len(m.baseline_class_list))
		for id := range m.baseline_class_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BaselineMeasureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedbaseline_measure_denom_list != nil {
		edges = append(edges, baselinemeasure.EdgeBaselineMeasureDenomList)
	}
	if m.removedbaseline_class_list != nil {
		edges = append(edges, baselinemeasure.EdgeBaselineClassList)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BaselineMeasureMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case baselinemeasure.EdgeBaselineMeasureDenomList:
		ids := make([]ent.Value, 0, len(m.removedbaseline_measure_denom_list))
		for id := range m.removedbaseline_measure_denom_list {
			ids = append(ids, id)
		}
		return ids
	case baselinemeasure.EdgeBaselineClassList:
		ids := make([]ent.Value, 0, len(m.removedbaseline_class_list))
		for id := range m.removedbaseline_class_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BaselineMeasureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent {
		edges = append(edges, baselinemeasure.EdgeParent)
	}
	if m.clearedbaseline_measure_denom_list {
		edges = append(edges, baselinemeasure.EdgeBaselineMeasureDenomList)
	}
	if m.clearedbaseline_class_list {
		edges = append(edges, baselinemeasure.EdgeBaselineClassList)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BaselineMeasureMutation) EdgeCleared(name string) bool {
	switch name {
	case baselinemeasure.EdgeParent:
		return m.clearedparent
	case baselinemeasure.EdgeBaselineMeasureDenomList:
		return m.clearedbaseline_measure_denom_list
	case baselinemeasure.EdgeBaselineClassList:
		return m.clearedbaseline_class_list
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BaselineMeasureMutation) ClearEdge(name string) error {
	switch name {
	case baselinemeasure.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown BaselineMeasure unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BaselineMeasureMutation) ResetEdge(name string) error {
	switch name {
	case baselinemeasure.EdgeParent:
		m.ResetParent()
		return nil
	case baselinemeasure.EdgeBaselineMeasureDenomList:
		m.ResetBaselineMeasureDenomList()
		return nil
	case baselinemeasure.EdgeBaselineClassList:
		m.ResetBaselineClassList()
		return nil
	}
	return fmt.Errorf("unknown BaselineMeasure edge %s", name)
}

// BaselineMeasureDenomMutation represents an operation that mutates the BaselineMeasureDenom nodes in the graph.
type BaselineMeasureDenomMutation struct {
	config
	op                                       Op
	typ                                      string
	id                                       *int
	baseline_measure_denom_units             *string
	clearedFields                            map[string]struct{}
	parent                                   *int
	clearedparent                            bool
	baseline_measure_denom_count_list        map[int]struct{}
	removedbaseline_measure_denom_count_list map[int]struct{}
	clearedbaseline_measure_denom_count_list bool
	done                                     bool
	oldValue                                 func(context.Context) (*BaselineMeasureDenom, error)
	predicates                               []predicate.BaselineMeasureDenom
}

var _ ent.Mutation = (*BaselineMeasureDenomMutation)(nil)

// baselinemeasuredenomOption allows management of the mutation configuration using functional options.
type baselinemeasuredenomOption func(*BaselineMeasureDenomMutation)

// newBaselineMeasureDenomMutation creates new mutation for the BaselineMeasureDenom entity.
func newBaselineMeasureDenomMutation(c config, op Op, opts ...baselinemeasuredenomOption) *BaselineMeasureDenomMutation {
	m := &BaselineMeasureDenomMutation{
		config:        c,
		op:            op,
		typ:           TypeBaselineMeasureDenom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBaselineMeasureDenomID sets the ID field of the mutation.
func withBaselineMeasureDenomID(id int) baselinemeasuredenomOption {
	return func(m *BaselineMeasureDenomMutation) {
		var (
			err   error
			once  sync.Once
			value *BaselineMeasureDenom
		)
		m.oldValue = func(ctx context.Context) (*BaselineMeasureDenom, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BaselineMeasureDenom.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBaselineMeasureDenom sets the old BaselineMeasureDenom of the mutation.
func withBaselineMeasureDenom(node *BaselineMeasureDenom) baselinemeasuredenomOption {
	return func(m *BaselineMeasureDenomMutation) {
		m.oldValue = func(context.Context) (*BaselineMeasureDenom, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BaselineMeasureDenomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BaselineMeasureDenomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BaselineMeasureDenomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BaselineMeasureDenomMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BaselineMeasureDenom.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBaselineMeasureDenomUnits sets the "baseline_measure_denom_units" field.
func (m *BaselineMeasureDenomMutation) SetBaselineMeasureDenomUnits(s string) {
	m.baseline_measure_denom_units = &s
}

// BaselineMeasureDenomUnits returns the value of the "baseline_measure_denom_units" field in the mutation.
func (m *BaselineMeasureDenomMutation) BaselineMeasureDenomUnits() (r string, exists bool) {
	v := m.baseline_measure_denom_units
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselineMeasureDenomUnits returns the old "baseline_measure_denom_units" field's value of the BaselineMeasureDenom entity.
// If the BaselineMeasureDenom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineMeasureDenomMutation) OldBaselineMeasureDenomUnits(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselineMeasureDenomUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselineMeasureDenomUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselineMeasureDenomUnits: %w", err)
	}
	return oldValue.BaselineMeasureDenomUnits, nil
}

// ResetBaselineMeasureDenomUnits resets all changes to the "baseline_measure_denom_units" field.
func (m *BaselineMeasureDenomMutation) ResetBaselineMeasureDenomUnits() {
	m.baseline_measure_denom_units = nil
}

// SetParentID sets the "parent" edge to the BaselineMeasure entity by id.
func (m *BaselineMeasureDenomMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the BaselineMeasure entity.
func (m *BaselineMeasureDenomMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the BaselineMeasure entity was cleared.
func (m *BaselineMeasureDenomMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *BaselineMeasureDenomMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *BaselineMeasureDenomMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *BaselineMeasureDenomMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddBaselineMeasureDenomCountListIDs adds the "baseline_measure_denom_count_list" edge to the BaselineMeasureDenomCount entity by ids.
func (m *BaselineMeasureDenomMutation) AddBaselineMeasureDenomCountListIDs(ids ...int) {
	if m.baseline_measure_denom_count_list == nil {
		m.baseline_measure_denom_count_list = make(map[int]struct{})
	}
	for i := range ids {
		m.baseline_measure_denom_count_list[ids[i]] = struct{}{}
	}
}

// ClearBaselineMeasureDenomCountList clears the "baseline_measure_denom_count_list" edge to the BaselineMeasureDenomCount entity.
func (m *BaselineMeasureDenomMutation) ClearBaselineMeasureDenomCountList() {
	m.clearedbaseline_measure_denom_count_list = true
}

// BaselineMeasureDenomCountListCleared reports if the "baseline_measure_denom_count_list" edge to the BaselineMeasureDenomCount entity was cleared.
func (m *BaselineMeasureDenomMutation) BaselineMeasureDenomCountListCleared() bool {
	return m.clearedbaseline_measure_denom_count_list
}

// RemoveBaselineMeasureDenomCountListIDs removes the "baseline_measure_denom_count_list" edge to the BaselineMeasureDenomCount entity by IDs.
func (m *BaselineMeasureDenomMutation) RemoveBaselineMeasureDenomCountListIDs(ids ...int) {
	if m.removedbaseline_measure_denom_count_list == nil {
		m.removedbaseline_measure_denom_count_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.baseline_measure_denom_count_list, ids[i])
		m.removedbaseline_measure_denom_count_list[ids[i]] = struct{}{}
	}
}

// RemovedBaselineMeasureDenomCountList returns the removed IDs of the "baseline_measure_denom_count_list" edge to the BaselineMeasureDenomCount entity.
func (m *BaselineMeasureDenomMutation) RemovedBaselineMeasureDenomCountListIDs() (ids []int) {
	for id := range m.removedbaseline_measure_denom_count_list {
		ids = append(ids, id)
	}
	return
}

// BaselineMeasureDenomCountListIDs returns the "baseline_measure_denom_count_list" edge IDs in the mutation.
func (m *BaselineMeasureDenomMutation) BaselineMeasureDenomCountListIDs() (ids []int) {
	for id := range m.baseline_measure_denom_count_list {
		ids = append(ids, id)
	}
	return
}

// ResetBaselineMeasureDenomCountList resets all changes to the "baseline_measure_denom_count_list" edge.
func (m *BaselineMeasureDenomMutation) ResetBaselineMeasureDenomCountList() {
	m.baseline_measure_denom_count_list = nil
	m.clearedbaseline_measure_denom_count_list = false
	m.removedbaseline_measure_denom_count_list = nil
}

// Where appends a list predicates to the BaselineMeasureDenomMutation builder.
func (m *BaselineMeasureDenomMutation) Where(ps ...predicate.BaselineMeasureDenom) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BaselineMeasureDenomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BaselineMeasureDenom).
func (m *BaselineMeasureDenomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BaselineMeasureDenomMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.baseline_measure_denom_units != nil {
		fields = append(fields, baselinemeasuredenom.FieldBaselineMeasureDenomUnits)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BaselineMeasureDenomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case baselinemeasuredenom.FieldBaselineMeasureDenomUnits:
		return m.BaselineMeasureDenomUnits()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BaselineMeasureDenomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case baselinemeasuredenom.FieldBaselineMeasureDenomUnits:
		return m.OldBaselineMeasureDenomUnits(ctx)
	}
	return nil, fmt.Errorf("unknown BaselineMeasureDenom field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BaselineMeasureDenomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case baselinemeasuredenom.FieldBaselineMeasureDenomUnits:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselineMeasureDenomUnits(v)
		return nil
	}
	return fmt.Errorf("unknown BaselineMeasureDenom field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BaselineMeasureDenomMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BaselineMeasureDenomMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BaselineMeasureDenomMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BaselineMeasureDenom numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BaselineMeasureDenomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BaselineMeasureDenomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BaselineMeasureDenomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BaselineMeasureDenom nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BaselineMeasureDenomMutation) ResetField(name string) error {
	switch name {
	case baselinemeasuredenom.FieldBaselineMeasureDenomUnits:
		m.ResetBaselineMeasureDenomUnits()
		return nil
	}
	return fmt.Errorf("unknown BaselineMeasureDenom field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BaselineMeasureDenomMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.parent != nil {
		edges = append(edges, baselinemeasuredenom.EdgeParent)
	}
	if m.baseline_measure_denom_count_list != nil {
		edges = append(edges, baselinemeasuredenom.EdgeBaselineMeasureDenomCountList)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BaselineMeasureDenomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case baselinemeasuredenom.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case baselinemeasuredenom.EdgeBaselineMeasureDenomCountList:
		ids := make([]ent.Value, 0, len(m.baseline_measure_denom_count_list))
		for id := range m.baseline_measure_denom_count_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BaselineMeasureDenomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedbaseline_measure_denom_count_list != nil {
		edges = append(edges, baselinemeasuredenom.EdgeBaselineMeasureDenomCountList)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BaselineMeasureDenomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case baselinemeasuredenom.EdgeBaselineMeasureDenomCountList:
		ids := make([]ent.Value, 0, len(m.removedbaseline_measure_denom_count_list))
		for id := range m.removedbaseline_measure_denom_count_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BaselineMeasureDenomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedparent {
		edges = append(edges, baselinemeasuredenom.EdgeParent)
	}
	if m.clearedbaseline_measure_denom_count_list {
		edges = append(edges, baselinemeasuredenom.EdgeBaselineMeasureDenomCountList)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BaselineMeasureDenomMutation) EdgeCleared(name string) bool {
	switch name {
	case baselinemeasuredenom.EdgeParent:
		return m.clearedparent
	case baselinemeasuredenom.EdgeBaselineMeasureDenomCountList:
		return m.clearedbaseline_measure_denom_count_list
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BaselineMeasureDenomMutation) ClearEdge(name string) error {
	switch name {
	case baselinemeasuredenom.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown BaselineMeasureDenom unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BaselineMeasureDenomMutation) ResetEdge(name string) error {
	switch name {
	case baselinemeasuredenom.EdgeParent:
		m.ResetParent()
		return nil
	case baselinemeasuredenom.EdgeBaselineMeasureDenomCountList:
		m.ResetBaselineMeasureDenomCountList()
		return nil
	}
	return fmt.Errorf("unknown BaselineMeasureDenom edge %s", name)
}

// BaselineMeasureDenomCountMutation represents an operation that mutates the BaselineMeasureDenomCount nodes in the graph.
type BaselineMeasureDenomCountMutation struct {
	config
	op                                    Op
	typ                                   string
	id                                    *int
	baseline_measure_denom_count_group_id *string
	baseline_measure_denom_count_value    *string
	clearedFields                         map[string]struct{}
	parent                                *int
	clearedparent                         bool
	done                                  bool
	oldValue                              func(context.Context) (*BaselineMeasureDenomCount, error)
	predicates                            []predicate.BaselineMeasureDenomCount
}

var _ ent.Mutation = (*BaselineMeasureDenomCountMutation)(nil)

// baselinemeasuredenomcountOption allows management of the mutation configuration using functional options.
type baselinemeasuredenomcountOption func(*BaselineMeasureDenomCountMutation)

// newBaselineMeasureDenomCountMutation creates new mutation for the BaselineMeasureDenomCount entity.
func newBaselineMeasureDenomCountMutation(c config, op Op, opts ...baselinemeasuredenomcountOption) *BaselineMeasureDenomCountMutation {
	m := &BaselineMeasureDenomCountMutation{
		config:        c,
		op:            op,
		typ:           TypeBaselineMeasureDenomCount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBaselineMeasureDenomCountID sets the ID field of the mutation.
func withBaselineMeasureDenomCountID(id int) baselinemeasuredenomcountOption {
	return func(m *BaselineMeasureDenomCountMutation) {
		var (
			err   error
			once  sync.Once
			value *BaselineMeasureDenomCount
		)
		m.oldValue = func(ctx context.Context) (*BaselineMeasureDenomCount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BaselineMeasureDenomCount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBaselineMeasureDenomCount sets the old BaselineMeasureDenomCount of the mutation.
func withBaselineMeasureDenomCount(node *BaselineMeasureDenomCount) baselinemeasuredenomcountOption {
	return func(m *BaselineMeasureDenomCountMutation) {
		m.oldValue = func(context.Context) (*BaselineMeasureDenomCount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BaselineMeasureDenomCountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BaselineMeasureDenomCountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BaselineMeasureDenomCountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BaselineMeasureDenomCountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BaselineMeasureDenomCount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBaselineMeasureDenomCountGroupID sets the "baseline_measure_denom_count_group_id" field.
func (m *BaselineMeasureDenomCountMutation) SetBaselineMeasureDenomCountGroupID(s string) {
	m.baseline_measure_denom_count_group_id = &s
}

// BaselineMeasureDenomCountGroupID returns the value of the "baseline_measure_denom_count_group_id" field in the mutation.
func (m *BaselineMeasureDenomCountMutation) BaselineMeasureDenomCountGroupID() (r string, exists bool) {
	v := m.baseline_measure_denom_count_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselineMeasureDenomCountGroupID returns the old "baseline_measure_denom_count_group_id" field's value of the BaselineMeasureDenomCount entity.
// If the BaselineMeasureDenomCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineMeasureDenomCountMutation) OldBaselineMeasureDenomCountGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselineMeasureDenomCountGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselineMeasureDenomCountGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselineMeasureDenomCountGroupID: %w", err)
	}
	return oldValue.BaselineMeasureDenomCountGroupID, nil
}

// ResetBaselineMeasureDenomCountGroupID resets all changes to the "baseline_measure_denom_count_group_id" field.
func (m *BaselineMeasureDenomCountMutation) ResetBaselineMeasureDenomCountGroupID() {
	m.baseline_measure_denom_count_group_id = nil
}

// SetBaselineMeasureDenomCountValue sets the "baseline_measure_denom_count_value" field.
func (m *BaselineMeasureDenomCountMutation) SetBaselineMeasureDenomCountValue(s string) {
	m.baseline_measure_denom_count_value = &s
}

// BaselineMeasureDenomCountValue returns the value of the "baseline_measure_denom_count_value" field in the mutation.
func (m *BaselineMeasureDenomCountMutation) BaselineMeasureDenomCountValue() (r string, exists bool) {
	v := m.baseline_measure_denom_count_value
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselineMeasureDenomCountValue returns the old "baseline_measure_denom_count_value" field's value of the BaselineMeasureDenomCount entity.
// If the BaselineMeasureDenomCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineMeasureDenomCountMutation) OldBaselineMeasureDenomCountValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselineMeasureDenomCountValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselineMeasureDenomCountValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselineMeasureDenomCountValue: %w", err)
	}
	return oldValue.BaselineMeasureDenomCountValue, nil
}

// ResetBaselineMeasureDenomCountValue resets all changes to the "baseline_measure_denom_count_value" field.
func (m *BaselineMeasureDenomCountMutation) ResetBaselineMeasureDenomCountValue() {
	m.baseline_measure_denom_count_value = nil
}

// SetParentID sets the "parent" edge to the BaselineMeasureDenom entity by id.
func (m *BaselineMeasureDenomCountMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the BaselineMeasureDenom entity.
func (m *BaselineMeasureDenomCountMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the BaselineMeasureDenom entity was cleared.
func (m *BaselineMeasureDenomCountMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *BaselineMeasureDenomCountMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *BaselineMeasureDenomCountMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *BaselineMeasureDenomCountMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// Where appends a list predicates to the BaselineMeasureDenomCountMutation builder.
func (m *BaselineMeasureDenomCountMutation) Where(ps ...predicate.BaselineMeasureDenomCount) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BaselineMeasureDenomCountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BaselineMeasureDenomCount).
func (m *BaselineMeasureDenomCountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BaselineMeasureDenomCountMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.baseline_measure_denom_count_group_id != nil {
		fields = append(fields, baselinemeasuredenomcount.FieldBaselineMeasureDenomCountGroupID)
	}
	if m.baseline_measure_denom_count_value != nil {
		fields = append(fields, baselinemeasuredenomcount.FieldBaselineMeasureDenomCountValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BaselineMeasureDenomCountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case baselinemeasuredenomcount.FieldBaselineMeasureDenomCountGroupID:
		return m.BaselineMeasureDenomCountGroupID()
	case baselinemeasuredenomcount.FieldBaselineMeasureDenomCountValue:
		return m.BaselineMeasureDenomCountValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BaselineMeasureDenomCountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case baselinemeasuredenomcount.FieldBaselineMeasureDenomCountGroupID:
		return m.OldBaselineMeasureDenomCountGroupID(ctx)
	case baselinemeasuredenomcount.FieldBaselineMeasureDenomCountValue:
		return m.OldBaselineMeasureDenomCountValue(ctx)
	}
	return nil, fmt.Errorf("unknown BaselineMeasureDenomCount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BaselineMeasureDenomCountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case baselinemeasuredenomcount.FieldBaselineMeasureDenomCountGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselineMeasureDenomCountGroupID(v)
		return nil
	case baselinemeasuredenomcount.FieldBaselineMeasureDenomCountValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselineMeasureDenomCountValue(v)
		return nil
	}
	return fmt.Errorf("unknown BaselineMeasureDenomCount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BaselineMeasureDenomCountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BaselineMeasureDenomCountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BaselineMeasureDenomCountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BaselineMeasureDenomCount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BaselineMeasureDenomCountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BaselineMeasureDenomCountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BaselineMeasureDenomCountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BaselineMeasureDenomCount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BaselineMeasureDenomCountMutation) ResetField(name string) error {
	switch name {
	case baselinemeasuredenomcount.FieldBaselineMeasureDenomCountGroupID:
		m.ResetBaselineMeasureDenomCountGroupID()
		return nil
	case baselinemeasuredenomcount.FieldBaselineMeasureDenomCountValue:
		m.ResetBaselineMeasureDenomCountValue()
		return nil
	}
	return fmt.Errorf("unknown BaselineMeasureDenomCount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BaselineMeasureDenomCountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.parent != nil {
		edges = append(edges, baselinemeasuredenomcount.EdgeParent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BaselineMeasureDenomCountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case baselinemeasuredenomcount.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BaselineMeasureDenomCountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BaselineMeasureDenomCountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BaselineMeasureDenomCountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparent {
		edges = append(edges, baselinemeasuredenomcount.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BaselineMeasureDenomCountMutation) EdgeCleared(name string) bool {
	switch name {
	case baselinemeasuredenomcount.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BaselineMeasureDenomCountMutation) ClearEdge(name string) error {
	switch name {
	case baselinemeasuredenomcount.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown BaselineMeasureDenomCount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BaselineMeasureDenomCountMutation) ResetEdge(name string) error {
	switch name {
	case baselinemeasuredenomcount.EdgeParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown BaselineMeasureDenomCount edge %s", name)
}

// BaselineMeasurementMutation represents an operation that mutates the BaselineMeasurement nodes in the graph.
type BaselineMeasurementMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	baseline_measurement_group_id    *string
	baseline_measurement_value       *string
	baseline_measurement_spread      *string
	baseline_measurement_lower_limit *string
	baseline_measurement_upper_limit *string
	baseline_measurement_comment     *string
	clearedFields                    map[string]struct{}
	parent                           *int
	clearedparent                    bool
	done                             bool
	oldValue                         func(context.Context) (*BaselineMeasurement, error)
	predicates                       []predicate.BaselineMeasurement
}

var _ ent.Mutation = (*BaselineMeasurementMutation)(nil)

// baselinemeasurementOption allows management of the mutation configuration using functional options.
type baselinemeasurementOption func(*BaselineMeasurementMutation)

// newBaselineMeasurementMutation creates new mutation for the BaselineMeasurement entity.
func newBaselineMeasurementMutation(c config, op Op, opts ...baselinemeasurementOption) *BaselineMeasurementMutation {
	m := &BaselineMeasurementMutation{
		config:        c,
		op:            op,
		typ:           TypeBaselineMeasurement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBaselineMeasurementID sets the ID field of the mutation.
func withBaselineMeasurementID(id int) baselinemeasurementOption {
	return func(m *BaselineMeasurementMutation) {
		var (
			err   error
			once  sync.Once
			value *BaselineMeasurement
		)
		m.oldValue = func(ctx context.Context) (*BaselineMeasurement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BaselineMeasurement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBaselineMeasurement sets the old BaselineMeasurement of the mutation.
func withBaselineMeasurement(node *BaselineMeasurement) baselinemeasurementOption {
	return func(m *BaselineMeasurementMutation) {
		m.oldValue = func(context.Context) (*BaselineMeasurement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BaselineMeasurementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BaselineMeasurementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BaselineMeasurementMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BaselineMeasurementMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BaselineMeasurement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBaselineMeasurementGroupID sets the "baseline_measurement_group_id" field.
func (m *BaselineMeasurementMutation) SetBaselineMeasurementGroupID(s string) {
	m.baseline_measurement_group_id = &s
}

// BaselineMeasurementGroupID returns the value of the "baseline_measurement_group_id" field in the mutation.
func (m *BaselineMeasurementMutation) BaselineMeasurementGroupID() (r string, exists bool) {
	v := m.baseline_measurement_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselineMeasurementGroupID returns the old "baseline_measurement_group_id" field's value of the BaselineMeasurement entity.
// If the BaselineMeasurement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineMeasurementMutation) OldBaselineMeasurementGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselineMeasurementGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselineMeasurementGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselineMeasurementGroupID: %w", err)
	}
	return oldValue.BaselineMeasurementGroupID, nil
}

// ResetBaselineMeasurementGroupID resets all changes to the "baseline_measurement_group_id" field.
func (m *BaselineMeasurementMutation) ResetBaselineMeasurementGroupID() {
	m.baseline_measurement_group_id = nil
}

// SetBaselineMeasurementValue sets the "baseline_measurement_value" field.
func (m *BaselineMeasurementMutation) SetBaselineMeasurementValue(s string) {
	m.baseline_measurement_value = &s
}

// BaselineMeasurementValue returns the value of the "baseline_measurement_value" field in the mutation.
func (m *BaselineMeasurementMutation) BaselineMeasurementValue() (r string, exists bool) {
	v := m.baseline_measurement_value
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselineMeasurementValue returns the old "baseline_measurement_value" field's value of the BaselineMeasurement entity.
// If the BaselineMeasurement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineMeasurementMutation) OldBaselineMeasurementValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselineMeasurementValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselineMeasurementValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselineMeasurementValue: %w", err)
	}
	return oldValue.BaselineMeasurementValue, nil
}

// ResetBaselineMeasurementValue resets all changes to the "baseline_measurement_value" field.
func (m *BaselineMeasurementMutation) ResetBaselineMeasurementValue() {
	m.baseline_measurement_value = nil
}

// SetBaselineMeasurementSpread sets the "baseline_measurement_spread" field.
func (m *BaselineMeasurementMutation) SetBaselineMeasurementSpread(s string) {
	m.baseline_measurement_spread = &s
}

// BaselineMeasurementSpread returns the value of the "baseline_measurement_spread" field in the mutation.
func (m *BaselineMeasurementMutation) BaselineMeasurementSpread() (r string, exists bool) {
	v := m.baseline_measurement_spread
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselineMeasurementSpread returns the old "baseline_measurement_spread" field's value of the BaselineMeasurement entity.
// If the BaselineMeasurement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineMeasurementMutation) OldBaselineMeasurementSpread(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselineMeasurementSpread is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselineMeasurementSpread requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselineMeasurementSpread: %w", err)
	}
	return oldValue.BaselineMeasurementSpread, nil
}

// ResetBaselineMeasurementSpread resets all changes to the "baseline_measurement_spread" field.
func (m *BaselineMeasurementMutation) ResetBaselineMeasurementSpread() {
	m.baseline_measurement_spread = nil
}

// SetBaselineMeasurementLowerLimit sets the "baseline_measurement_lower_limit" field.
func (m *BaselineMeasurementMutation) SetBaselineMeasurementLowerLimit(s string) {
	m.baseline_measurement_lower_limit = &s
}

// BaselineMeasurementLowerLimit returns the value of the "baseline_measurement_lower_limit" field in the mutation.
func (m *BaselineMeasurementMutation) BaselineMeasurementLowerLimit() (r string, exists bool) {
	v := m.baseline_measurement_lower_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselineMeasurementLowerLimit returns the old "baseline_measurement_lower_limit" field's value of the BaselineMeasurement entity.
// If the BaselineMeasurement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineMeasurementMutation) OldBaselineMeasurementLowerLimit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselineMeasurementLowerLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselineMeasurementLowerLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselineMeasurementLowerLimit: %w", err)
	}
	return oldValue.BaselineMeasurementLowerLimit, nil
}

// ResetBaselineMeasurementLowerLimit resets all changes to the "baseline_measurement_lower_limit" field.
func (m *BaselineMeasurementMutation) ResetBaselineMeasurementLowerLimit() {
	m.baseline_measurement_lower_limit = nil
}

// SetBaselineMeasurementUpperLimit sets the "baseline_measurement_upper_limit" field.
func (m *BaselineMeasurementMutation) SetBaselineMeasurementUpperLimit(s string) {
	m.baseline_measurement_upper_limit = &s
}

// BaselineMeasurementUpperLimit returns the value of the "baseline_measurement_upper_limit" field in the mutation.
func (m *BaselineMeasurementMutation) BaselineMeasurementUpperLimit() (r string, exists bool) {
	v := m.baseline_measurement_upper_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselineMeasurementUpperLimit returns the old "baseline_measurement_upper_limit" field's value of the BaselineMeasurement entity.
// If the BaselineMeasurement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineMeasurementMutation) OldBaselineMeasurementUpperLimit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselineMeasurementUpperLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselineMeasurementUpperLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselineMeasurementUpperLimit: %w", err)
	}
	return oldValue.BaselineMeasurementUpperLimit, nil
}

// ResetBaselineMeasurementUpperLimit resets all changes to the "baseline_measurement_upper_limit" field.
func (m *BaselineMeasurementMutation) ResetBaselineMeasurementUpperLimit() {
	m.baseline_measurement_upper_limit = nil
}

// SetBaselineMeasurementComment sets the "baseline_measurement_comment" field.
func (m *BaselineMeasurementMutation) SetBaselineMeasurementComment(s string) {
	m.baseline_measurement_comment = &s
}

// BaselineMeasurementComment returns the value of the "baseline_measurement_comment" field in the mutation.
func (m *BaselineMeasurementMutation) BaselineMeasurementComment() (r string, exists bool) {
	v := m.baseline_measurement_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldBaselineMeasurementComment returns the old "baseline_measurement_comment" field's value of the BaselineMeasurement entity.
// If the BaselineMeasurement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BaselineMeasurementMutation) OldBaselineMeasurementComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBaselineMeasurementComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBaselineMeasurementComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBaselineMeasurementComment: %w", err)
	}
	return oldValue.BaselineMeasurementComment, nil
}

// ResetBaselineMeasurementComment resets all changes to the "baseline_measurement_comment" field.
func (m *BaselineMeasurementMutation) ResetBaselineMeasurementComment() {
	m.baseline_measurement_comment = nil
}

// SetParentID sets the "parent" edge to the BaselineCategory entity by id.
func (m *BaselineMeasurementMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the BaselineCategory entity.
func (m *BaselineMeasurementMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the BaselineCategory entity was cleared.
func (m *BaselineMeasurementMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *BaselineMeasurementMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *BaselineMeasurementMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *BaselineMeasurementMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// Where appends a list predicates to the BaselineMeasurementMutation builder.
func (m *BaselineMeasurementMutation) Where(ps ...predicate.BaselineMeasurement) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *BaselineMeasurementMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (BaselineMeasurement).
func (m *BaselineMeasurementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BaselineMeasurementMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.baseline_measurement_group_id != nil {
		fields = append(fields, baselinemeasurement.FieldBaselineMeasurementGroupID)
	}
	if m.baseline_measurement_value != nil {
		fields = append(fields, baselinemeasurement.FieldBaselineMeasurementValue)
	}
	if m.baseline_measurement_spread != nil {
		fields = append(fields, baselinemeasurement.FieldBaselineMeasurementSpread)
	}
	if m.baseline_measurement_lower_limit != nil {
		fields = append(fields, baselinemeasurement.FieldBaselineMeasurementLowerLimit)
	}
	if m.baseline_measurement_upper_limit != nil {
		fields = append(fields, baselinemeasurement.FieldBaselineMeasurementUpperLimit)
	}
	if m.baseline_measurement_comment != nil {
		fields = append(fields, baselinemeasurement.FieldBaselineMeasurementComment)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BaselineMeasurementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case baselinemeasurement.FieldBaselineMeasurementGroupID:
		return m.BaselineMeasurementGroupID()
	case baselinemeasurement.FieldBaselineMeasurementValue:
		return m.BaselineMeasurementValue()
	case baselinemeasurement.FieldBaselineMeasurementSpread:
		return m.BaselineMeasurementSpread()
	case baselinemeasurement.FieldBaselineMeasurementLowerLimit:
		return m.BaselineMeasurementLowerLimit()
	case baselinemeasurement.FieldBaselineMeasurementUpperLimit:
		return m.BaselineMeasurementUpperLimit()
	case baselinemeasurement.FieldBaselineMeasurementComment:
		return m.BaselineMeasurementComment()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BaselineMeasurementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case baselinemeasurement.FieldBaselineMeasurementGroupID:
		return m.OldBaselineMeasurementGroupID(ctx)
	case baselinemeasurement.FieldBaselineMeasurementValue:
		return m.OldBaselineMeasurementValue(ctx)
	case baselinemeasurement.FieldBaselineMeasurementSpread:
		return m.OldBaselineMeasurementSpread(ctx)
	case baselinemeasurement.FieldBaselineMeasurementLowerLimit:
		return m.OldBaselineMeasurementLowerLimit(ctx)
	case baselinemeasurement.FieldBaselineMeasurementUpperLimit:
		return m.OldBaselineMeasurementUpperLimit(ctx)
	case baselinemeasurement.FieldBaselineMeasurementComment:
		return m.OldBaselineMeasurementComment(ctx)
	}
	return nil, fmt.Errorf("unknown BaselineMeasurement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BaselineMeasurementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case baselinemeasurement.FieldBaselineMeasurementGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselineMeasurementGroupID(v)
		return nil
	case baselinemeasurement.FieldBaselineMeasurementValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselineMeasurementValue(v)
		return nil
	case baselinemeasurement.FieldBaselineMeasurementSpread:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselineMeasurementSpread(v)
		return nil
	case baselinemeasurement.FieldBaselineMeasurementLowerLimit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselineMeasurementLowerLimit(v)
		return nil
	case baselinemeasurement.FieldBaselineMeasurementUpperLimit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselineMeasurementUpperLimit(v)
		return nil
	case baselinemeasurement.FieldBaselineMeasurementComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBaselineMeasurementComment(v)
		return nil
	}
	return fmt.Errorf("unknown BaselineMeasurement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BaselineMeasurementMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BaselineMeasurementMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BaselineMeasurementMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BaselineMeasurement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BaselineMeasurementMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BaselineMeasurementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BaselineMeasurementMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BaselineMeasurement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BaselineMeasurementMutation) ResetField(name string) error {
	switch name {
	case baselinemeasurement.FieldBaselineMeasurementGroupID:
		m.ResetBaselineMeasurementGroupID()
		return nil
	case baselinemeasurement.FieldBaselineMeasurementValue:
		m.ResetBaselineMeasurementValue()
		return nil
	case baselinemeasurement.FieldBaselineMeasurementSpread:
		m.ResetBaselineMeasurementSpread()
		return nil
	case baselinemeasurement.FieldBaselineMeasurementLowerLimit:
		m.ResetBaselineMeasurementLowerLimit()
		return nil
	case baselinemeasurement.FieldBaselineMeasurementUpperLimit:
		m.ResetBaselineMeasurementUpperLimit()
		return nil
	case baselinemeasurement.FieldBaselineMeasurementComment:
		m.ResetBaselineMeasurementComment()
		return nil
	}
	return fmt.Errorf("unknown BaselineMeasurement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BaselineMeasurementMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.parent != nil {
		edges = append(edges, baselinemeasurement.EdgeParent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BaselineMeasurementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case baselinemeasurement.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BaselineMeasurementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BaselineMeasurementMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BaselineMeasurementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparent {
		edges = append(edges, baselinemeasurement.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BaselineMeasurementMutation) EdgeCleared(name string) bool {
	switch name {
	case baselinemeasurement.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BaselineMeasurementMutation) ClearEdge(name string) error {
	switch name {
	case baselinemeasurement.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown BaselineMeasurement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BaselineMeasurementMutation) ResetEdge(name string) error {
	switch name {
	case baselinemeasurement.EdgeParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown BaselineMeasurement edge %s", name)
}

// CertainAgreementMutation represents an operation that mutates the CertainAgreement nodes in the graph.
type CertainAgreementMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	agreement_pi_sponsor_employee   *string
	agreement_restriction_type      *string
	agreement_restrictive_agreement *string
	agreement_other_details         *string
	clearedFields                   map[string]struct{}
	parent                          *int
	clearedparent                   bool
	done                            bool
	oldValue                        func(context.Context) (*CertainAgreement, error)
	predicates                      []predicate.CertainAgreement
}

var _ ent.Mutation = (*CertainAgreementMutation)(nil)

// certainagreementOption allows management of the mutation configuration using functional options.
type certainagreementOption func(*CertainAgreementMutation)

// newCertainAgreementMutation creates new mutation for the CertainAgreement entity.
func newCertainAgreementMutation(c config, op Op, opts ...certainagreementOption) *CertainAgreementMutation {
	m := &CertainAgreementMutation{
		config:        c,
		op:            op,
		typ:           TypeCertainAgreement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCertainAgreementID sets the ID field of the mutation.
func withCertainAgreementID(id int) certainagreementOption {
	return func(m *CertainAgreementMutation) {
		var (
			err   error
			once  sync.Once
			value *CertainAgreement
		)
		m.oldValue = func(ctx context.Context) (*CertainAgreement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CertainAgreement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCertainAgreement sets the old CertainAgreement of the mutation.
func withCertainAgreement(node *CertainAgreement) certainagreementOption {
	return func(m *CertainAgreementMutation) {
		m.oldValue = func(context.Context) (*CertainAgreement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CertainAgreementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CertainAgreementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CertainAgreementMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CertainAgreementMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CertainAgreement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAgreementPiSponsorEmployee sets the "agreement_pi_sponsor_employee" field.
func (m *CertainAgreementMutation) SetAgreementPiSponsorEmployee(s string) {
	m.agreement_pi_sponsor_employee = &s
}

// AgreementPiSponsorEmployee returns the value of the "agreement_pi_sponsor_employee" field in the mutation.
func (m *CertainAgreementMutation) AgreementPiSponsorEmployee() (r string, exists bool) {
	v := m.agreement_pi_sponsor_employee
	if v == nil {
		return
	}
	return *v, true
}

// OldAgreementPiSponsorEmployee returns the old "agreement_pi_sponsor_employee" field's value of the CertainAgreement entity.
// If the CertainAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertainAgreementMutation) OldAgreementPiSponsorEmployee(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgreementPiSponsorEmployee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgreementPiSponsorEmployee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgreementPiSponsorEmployee: %w", err)
	}
	return oldValue.AgreementPiSponsorEmployee, nil
}

// ResetAgreementPiSponsorEmployee resets all changes to the "agreement_pi_sponsor_employee" field.
func (m *CertainAgreementMutation) ResetAgreementPiSponsorEmployee() {
	m.agreement_pi_sponsor_employee = nil
}

// SetAgreementRestrictionType sets the "agreement_restriction_type" field.
func (m *CertainAgreementMutation) SetAgreementRestrictionType(s string) {
	m.agreement_restriction_type = &s
}

// AgreementRestrictionType returns the value of the "agreement_restriction_type" field in the mutation.
func (m *CertainAgreementMutation) AgreementRestrictionType() (r string, exists bool) {
	v := m.agreement_restriction_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAgreementRestrictionType returns the old "agreement_restriction_type" field's value of the CertainAgreement entity.
// If the CertainAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertainAgreementMutation) OldAgreementRestrictionType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgreementRestrictionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgreementRestrictionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgreementRestrictionType: %w", err)
	}
	return oldValue.AgreementRestrictionType, nil
}

// ResetAgreementRestrictionType resets all changes to the "agreement_restriction_type" field.
func (m *CertainAgreementMutation) ResetAgreementRestrictionType() {
	m.agreement_restriction_type = nil
}

// SetAgreementRestrictiveAgreement sets the "agreement_restrictive_agreement" field.
func (m *CertainAgreementMutation) SetAgreementRestrictiveAgreement(s string) {
	m.agreement_restrictive_agreement = &s
}

// AgreementRestrictiveAgreement returns the value of the "agreement_restrictive_agreement" field in the mutation.
func (m *CertainAgreementMutation) AgreementRestrictiveAgreement() (r string, exists bool) {
	v := m.agreement_restrictive_agreement
	if v == nil {
		return
	}
	return *v, true
}

// OldAgreementRestrictiveAgreement returns the old "agreement_restrictive_agreement" field's value of the CertainAgreement entity.
// If the CertainAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertainAgreementMutation) OldAgreementRestrictiveAgreement(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgreementRestrictiveAgreement is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgreementRestrictiveAgreement requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgreementRestrictiveAgreement: %w", err)
	}
	return oldValue.AgreementRestrictiveAgreement, nil
}

// ResetAgreementRestrictiveAgreement resets all changes to the "agreement_restrictive_agreement" field.
func (m *CertainAgreementMutation) ResetAgreementRestrictiveAgreement() {
	m.agreement_restrictive_agreement = nil
}

// SetAgreementOtherDetails sets the "agreement_other_details" field.
func (m *CertainAgreementMutation) SetAgreementOtherDetails(s string) {
	m.agreement_other_details = &s
}

// AgreementOtherDetails returns the value of the "agreement_other_details" field in the mutation.
func (m *CertainAgreementMutation) AgreementOtherDetails() (r string, exists bool) {
	v := m.agreement_other_details
	if v == nil {
		return
	}
	return *v, true
}

// OldAgreementOtherDetails returns the old "agreement_other_details" field's value of the CertainAgreement entity.
// If the CertainAgreement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CertainAgreementMutation) OldAgreementOtherDetails(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgreementOtherDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgreementOtherDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgreementOtherDetails: %w", err)
	}
	return oldValue.AgreementOtherDetails, nil
}

// ResetAgreementOtherDetails resets all changes to the "agreement_other_details" field.
func (m *CertainAgreementMutation) ResetAgreementOtherDetails() {
	m.agreement_other_details = nil
}

// SetParentID sets the "parent" edge to the MoreInfoModule entity by id.
func (m *CertainAgreementMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the MoreInfoModule entity.
func (m *CertainAgreementMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the MoreInfoModule entity was cleared.
func (m *CertainAgreementMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *CertainAgreementMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *CertainAgreementMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *CertainAgreementMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// Where appends a list predicates to the CertainAgreementMutation builder.
func (m *CertainAgreementMutation) Where(ps ...predicate.CertainAgreement) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CertainAgreementMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CertainAgreement).
func (m *CertainAgreementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CertainAgreementMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.agreement_pi_sponsor_employee != nil {
		fields = append(fields, certainagreement.FieldAgreementPiSponsorEmployee)
	}
	if m.agreement_restriction_type != nil {
		fields = append(fields, certainagreement.FieldAgreementRestrictionType)
	}
	if m.agreement_restrictive_agreement != nil {
		fields = append(fields, certainagreement.FieldAgreementRestrictiveAgreement)
	}
	if m.agreement_other_details != nil {
		fields = append(fields, certainagreement.FieldAgreementOtherDetails)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CertainAgreementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case certainagreement.FieldAgreementPiSponsorEmployee:
		return m.AgreementPiSponsorEmployee()
	case certainagreement.FieldAgreementRestrictionType:
		return m.AgreementRestrictionType()
	case certainagreement.FieldAgreementRestrictiveAgreement:
		return m.AgreementRestrictiveAgreement()
	case certainagreement.FieldAgreementOtherDetails:
		return m.AgreementOtherDetails()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CertainAgreementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case certainagreement.FieldAgreementPiSponsorEmployee:
		return m.OldAgreementPiSponsorEmployee(ctx)
	case certainagreement.FieldAgreementRestrictionType:
		return m.OldAgreementRestrictionType(ctx)
	case certainagreement.FieldAgreementRestrictiveAgreement:
		return m.OldAgreementRestrictiveAgreement(ctx)
	case certainagreement.FieldAgreementOtherDetails:
		return m.OldAgreementOtherDetails(ctx)
	}
	return nil, fmt.Errorf("unknown CertainAgreement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertainAgreementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case certainagreement.FieldAgreementPiSponsorEmployee:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgreementPiSponsorEmployee(v)
		return nil
	case certainagreement.FieldAgreementRestrictionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgreementRestrictionType(v)
		return nil
	case certainagreement.FieldAgreementRestrictiveAgreement:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgreementRestrictiveAgreement(v)
		return nil
	case certainagreement.FieldAgreementOtherDetails:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgreementOtherDetails(v)
		return nil
	}
	return fmt.Errorf("unknown CertainAgreement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CertainAgreementMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CertainAgreementMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CertainAgreementMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CertainAgreement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CertainAgreementMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CertainAgreementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CertainAgreementMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CertainAgreement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CertainAgreementMutation) ResetField(name string) error {
	switch name {
	case certainagreement.FieldAgreementPiSponsorEmployee:
		m.ResetAgreementPiSponsorEmployee()
		return nil
	case certainagreement.FieldAgreementRestrictionType:
		m.ResetAgreementRestrictionType()
		return nil
	case certainagreement.FieldAgreementRestrictiveAgreement:
		m.ResetAgreementRestrictiveAgreement()
		return nil
	case certainagreement.FieldAgreementOtherDetails:
		m.ResetAgreementOtherDetails()
		return nil
	}
	return fmt.Errorf("unknown CertainAgreement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CertainAgreementMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.parent != nil {
		edges = append(edges, certainagreement.EdgeParent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CertainAgreementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case certainagreement.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CertainAgreementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CertainAgreementMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CertainAgreementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparent {
		edges = append(edges, certainagreement.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CertainAgreementMutation) EdgeCleared(name string) bool {
	switch name {
	case certainagreement.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CertainAgreementMutation) ClearEdge(name string) error {
	switch name {
	case certainagreement.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown CertainAgreement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CertainAgreementMutation) ResetEdge(name string) error {
	switch name {
	case certainagreement.EdgeParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown CertainAgreement edge %s", name)
}

// ClinicalTrialMutation represents an operation that mutates the ClinicalTrial nodes in the graph.
type ClinicalTrialMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	study_name                     *string
	sponsor                        *string
	responsible_party              *string
	study_type                     *string
	phase                          *string
	actual_enrollment              *string
	allocation                     *string
	intervention_model             *string
	masking                        *string
	primary_purpose                *string
	official_title                 *string
	actual_study_start_date        *time.Time
	actual_primary_completion_date *time.Time
	actual_study_completion_date   *time.Time
	study_id                       *string
	clearedFields                  map[string]struct{}
	results_definition             *int
	clearedresults_definition      bool
	study_locations                map[int]struct{}
	removedstudy_locations         map[int]struct{}
	clearedstudy_locations         bool
	study_eligibility              map[int]struct{}
	removedstudy_eligibility       map[int]struct{}
	clearedstudy_eligibility       bool
	metadata                       map[int]struct{}
	removedmetadata                map[int]struct{}
	clearedmetadata                bool
	done                           bool
	oldValue                       func(context.Context) (*ClinicalTrial, error)
	predicates                     []predicate.ClinicalTrial
}

var _ ent.Mutation = (*ClinicalTrialMutation)(nil)

// clinicaltrialOption allows management of the mutation configuration using functional options.
type clinicaltrialOption func(*ClinicalTrialMutation)

// newClinicalTrialMutation creates new mutation for the ClinicalTrial entity.
func newClinicalTrialMutation(c config, op Op, opts ...clinicaltrialOption) *ClinicalTrialMutation {
	m := &ClinicalTrialMutation{
		config:        c,
		op:            op,
		typ:           TypeClinicalTrial,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClinicalTrialID sets the ID field of the mutation.
func withClinicalTrialID(id int) clinicaltrialOption {
	return func(m *ClinicalTrialMutation) {
		var (
			err   error
			once  sync.Once
			value *ClinicalTrial
		)
		m.oldValue = func(ctx context.Context) (*ClinicalTrial, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ClinicalTrial.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClinicalTrial sets the old ClinicalTrial of the mutation.
func withClinicalTrial(node *ClinicalTrial) clinicaltrialOption {
	return func(m *ClinicalTrialMutation) {
		m.oldValue = func(context.Context) (*ClinicalTrial, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClinicalTrialMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClinicalTrialMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClinicalTrialMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClinicalTrialMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ClinicalTrial.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStudyName sets the "study_name" field.
func (m *ClinicalTrialMutation) SetStudyName(s string) {
	m.study_name = &s
}

// StudyName returns the value of the "study_name" field in the mutation.
func (m *ClinicalTrialMutation) StudyName() (r string, exists bool) {
	v := m.study_name
	if v == nil {
		return
	}
	return *v, true
}

// OldStudyName returns the old "study_name" field's value of the ClinicalTrial entity.
// If the ClinicalTrial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicalTrialMutation) OldStudyName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStudyName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStudyName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStudyName: %w", err)
	}
	return oldValue.StudyName, nil
}

// ResetStudyName resets all changes to the "study_name" field.
func (m *ClinicalTrialMutation) ResetStudyName() {
	m.study_name = nil
}

// SetSponsor sets the "sponsor" field.
func (m *ClinicalTrialMutation) SetSponsor(s string) {
	m.sponsor = &s
}

// Sponsor returns the value of the "sponsor" field in the mutation.
func (m *ClinicalTrialMutation) Sponsor() (r string, exists bool) {
	v := m.sponsor
	if v == nil {
		return
	}
	return *v, true
}

// OldSponsor returns the old "sponsor" field's value of the ClinicalTrial entity.
// If the ClinicalTrial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicalTrialMutation) OldSponsor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSponsor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSponsor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSponsor: %w", err)
	}
	return oldValue.Sponsor, nil
}

// ResetSponsor resets all changes to the "sponsor" field.
func (m *ClinicalTrialMutation) ResetSponsor() {
	m.sponsor = nil
}

// SetResponsibleParty sets the "responsible_party" field.
func (m *ClinicalTrialMutation) SetResponsibleParty(s string) {
	m.responsible_party = &s
}

// ResponsibleParty returns the value of the "responsible_party" field in the mutation.
func (m *ClinicalTrialMutation) ResponsibleParty() (r string, exists bool) {
	v := m.responsible_party
	if v == nil {
		return
	}
	return *v, true
}

// OldResponsibleParty returns the old "responsible_party" field's value of the ClinicalTrial entity.
// If the ClinicalTrial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicalTrialMutation) OldResponsibleParty(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponsibleParty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponsibleParty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponsibleParty: %w", err)
	}
	return oldValue.ResponsibleParty, nil
}

// ResetResponsibleParty resets all changes to the "responsible_party" field.
func (m *ClinicalTrialMutation) ResetResponsibleParty() {
	m.responsible_party = nil
}

// SetStudyType sets the "study_type" field.
func (m *ClinicalTrialMutation) SetStudyType(s string) {
	m.study_type = &s
}

// StudyType returns the value of the "study_type" field in the mutation.
func (m *ClinicalTrialMutation) StudyType() (r string, exists bool) {
	v := m.study_type
	if v == nil {
		return
	}
	return *v, true
}

// OldStudyType returns the old "study_type" field's value of the ClinicalTrial entity.
// If the ClinicalTrial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicalTrialMutation) OldStudyType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStudyType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStudyType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStudyType: %w", err)
	}
	return oldValue.StudyType, nil
}

// ResetStudyType resets all changes to the "study_type" field.
func (m *ClinicalTrialMutation) ResetStudyType() {
	m.study_type = nil
}

// SetPhase sets the "phase" field.
func (m *ClinicalTrialMutation) SetPhase(s string) {
	m.phase = &s
}

// Phase returns the value of the "phase" field in the mutation.
func (m *ClinicalTrialMutation) Phase() (r string, exists bool) {
	v := m.phase
	if v == nil {
		return
	}
	return *v, true
}

// OldPhase returns the old "phase" field's value of the ClinicalTrial entity.
// If the ClinicalTrial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicalTrialMutation) OldPhase(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhase is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhase requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhase: %w", err)
	}
	return oldValue.Phase, nil
}

// ResetPhase resets all changes to the "phase" field.
func (m *ClinicalTrialMutation) ResetPhase() {
	m.phase = nil
}

// SetActualEnrollment sets the "actual_enrollment" field.
func (m *ClinicalTrialMutation) SetActualEnrollment(s string) {
	m.actual_enrollment = &s
}

// ActualEnrollment returns the value of the "actual_enrollment" field in the mutation.
func (m *ClinicalTrialMutation) ActualEnrollment() (r string, exists bool) {
	v := m.actual_enrollment
	if v == nil {
		return
	}
	return *v, true
}

// OldActualEnrollment returns the old "actual_enrollment" field's value of the ClinicalTrial entity.
// If the ClinicalTrial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicalTrialMutation) OldActualEnrollment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActualEnrollment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActualEnrollment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActualEnrollment: %w", err)
	}
	return oldValue.ActualEnrollment, nil
}

// ResetActualEnrollment resets all changes to the "actual_enrollment" field.
func (m *ClinicalTrialMutation) ResetActualEnrollment() {
	m.actual_enrollment = nil
}

// SetAllocation sets the "allocation" field.
func (m *ClinicalTrialMutation) SetAllocation(s string) {
	m.allocation = &s
}

// Allocation returns the value of the "allocation" field in the mutation.
func (m *ClinicalTrialMutation) Allocation() (r string, exists bool) {
	v := m.allocation
	if v == nil {
		return
	}
	return *v, true
}

// OldAllocation returns the old "allocation" field's value of the ClinicalTrial entity.
// If the ClinicalTrial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicalTrialMutation) OldAllocation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllocation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllocation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllocation: %w", err)
	}
	return oldValue.Allocation, nil
}

// ResetAllocation resets all changes to the "allocation" field.
func (m *ClinicalTrialMutation) ResetAllocation() {
	m.allocation = nil
}

// SetInterventionModel sets the "intervention_model" field.
func (m *ClinicalTrialMutation) SetInterventionModel(s string) {
	m.intervention_model = &s
}

// InterventionModel returns the value of the "intervention_model" field in the mutation.
func (m *ClinicalTrialMutation) InterventionModel() (r string, exists bool) {
	v := m.intervention_model
	if v == nil {
		return
	}
	return *v, true
}

// OldInterventionModel returns the old "intervention_model" field's value of the ClinicalTrial entity.
// If the ClinicalTrial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicalTrialMutation) OldInterventionModel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInterventionModel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInterventionModel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInterventionModel: %w", err)
	}
	return oldValue.InterventionModel, nil
}

// ResetInterventionModel resets all changes to the "intervention_model" field.
func (m *ClinicalTrialMutation) ResetInterventionModel() {
	m.intervention_model = nil
}

// SetMasking sets the "masking" field.
func (m *ClinicalTrialMutation) SetMasking(s string) {
	m.masking = &s
}

// Masking returns the value of the "masking" field in the mutation.
func (m *ClinicalTrialMutation) Masking() (r string, exists bool) {
	v := m.masking
	if v == nil {
		return
	}
	return *v, true
}

// OldMasking returns the old "masking" field's value of the ClinicalTrial entity.
// If the ClinicalTrial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicalTrialMutation) OldMasking(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMasking is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMasking requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMasking: %w", err)
	}
	return oldValue.Masking, nil
}

// ResetMasking resets all changes to the "masking" field.
func (m *ClinicalTrialMutation) ResetMasking() {
	m.masking = nil
}

// SetPrimaryPurpose sets the "primary_purpose" field.
func (m *ClinicalTrialMutation) SetPrimaryPurpose(s string) {
	m.primary_purpose = &s
}

// PrimaryPurpose returns the value of the "primary_purpose" field in the mutation.
func (m *ClinicalTrialMutation) PrimaryPurpose() (r string, exists bool) {
	v := m.primary_purpose
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryPurpose returns the old "primary_purpose" field's value of the ClinicalTrial entity.
// If the ClinicalTrial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicalTrialMutation) OldPrimaryPurpose(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryPurpose is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryPurpose requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryPurpose: %w", err)
	}
	return oldValue.PrimaryPurpose, nil
}

// ResetPrimaryPurpose resets all changes to the "primary_purpose" field.
func (m *ClinicalTrialMutation) ResetPrimaryPurpose() {
	m.primary_purpose = nil
}

// SetOfficialTitle sets the "official_title" field.
func (m *ClinicalTrialMutation) SetOfficialTitle(s string) {
	m.official_title = &s
}

// OfficialTitle returns the value of the "official_title" field in the mutation.
func (m *ClinicalTrialMutation) OfficialTitle() (r string, exists bool) {
	v := m.official_title
	if v == nil {
		return
	}
	return *v, true
}

// OldOfficialTitle returns the old "official_title" field's value of the ClinicalTrial entity.
// If the ClinicalTrial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicalTrialMutation) OldOfficialTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOfficialTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOfficialTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOfficialTitle: %w", err)
	}
	return oldValue.OfficialTitle, nil
}

// ResetOfficialTitle resets all changes to the "official_title" field.
func (m *ClinicalTrialMutation) ResetOfficialTitle() {
	m.official_title = nil
}

// SetActualStudyStartDate sets the "actual_study_start_date" field.
func (m *ClinicalTrialMutation) SetActualStudyStartDate(t time.Time) {
	m.actual_study_start_date = &t
}

// ActualStudyStartDate returns the value of the "actual_study_start_date" field in the mutation.
func (m *ClinicalTrialMutation) ActualStudyStartDate() (r time.Time, exists bool) {
	v := m.actual_study_start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldActualStudyStartDate returns the old "actual_study_start_date" field's value of the ClinicalTrial entity.
// If the ClinicalTrial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicalTrialMutation) OldActualStudyStartDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActualStudyStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActualStudyStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActualStudyStartDate: %w", err)
	}
	return oldValue.ActualStudyStartDate, nil
}

// ResetActualStudyStartDate resets all changes to the "actual_study_start_date" field.
func (m *ClinicalTrialMutation) ResetActualStudyStartDate() {
	m.actual_study_start_date = nil
}

// SetActualPrimaryCompletionDate sets the "actual_primary_completion_date" field.
func (m *ClinicalTrialMutation) SetActualPrimaryCompletionDate(t time.Time) {
	m.actual_primary_completion_date = &t
}

// ActualPrimaryCompletionDate returns the value of the "actual_primary_completion_date" field in the mutation.
func (m *ClinicalTrialMutation) ActualPrimaryCompletionDate() (r time.Time, exists bool) {
	v := m.actual_primary_completion_date
	if v == nil {
		return
	}
	return *v, true
}

// OldActualPrimaryCompletionDate returns the old "actual_primary_completion_date" field's value of the ClinicalTrial entity.
// If the ClinicalTrial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicalTrialMutation) OldActualPrimaryCompletionDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActualPrimaryCompletionDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActualPrimaryCompletionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActualPrimaryCompletionDate: %w", err)
	}
	return oldValue.ActualPrimaryCompletionDate, nil
}

// ResetActualPrimaryCompletionDate resets all changes to the "actual_primary_completion_date" field.
func (m *ClinicalTrialMutation) ResetActualPrimaryCompletionDate() {
	m.actual_primary_completion_date = nil
}

// SetActualStudyCompletionDate sets the "actual_study_completion_date" field.
func (m *ClinicalTrialMutation) SetActualStudyCompletionDate(t time.Time) {
	m.actual_study_completion_date = &t
}

// ActualStudyCompletionDate returns the value of the "actual_study_completion_date" field in the mutation.
func (m *ClinicalTrialMutation) ActualStudyCompletionDate() (r time.Time, exists bool) {
	v := m.actual_study_completion_date
	if v == nil {
		return
	}
	return *v, true
}

// OldActualStudyCompletionDate returns the old "actual_study_completion_date" field's value of the ClinicalTrial entity.
// If the ClinicalTrial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicalTrialMutation) OldActualStudyCompletionDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActualStudyCompletionDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActualStudyCompletionDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActualStudyCompletionDate: %w", err)
	}
	return oldValue.ActualStudyCompletionDate, nil
}

// ResetActualStudyCompletionDate resets all changes to the "actual_study_completion_date" field.
func (m *ClinicalTrialMutation) ResetActualStudyCompletionDate() {
	m.actual_study_completion_date = nil
}

// SetStudyID sets the "study_id" field.
func (m *ClinicalTrialMutation) SetStudyID(s string) {
	m.study_id = &s
}

// StudyID returns the value of the "study_id" field in the mutation.
func (m *ClinicalTrialMutation) StudyID() (r string, exists bool) {
	v := m.study_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStudyID returns the old "study_id" field's value of the ClinicalTrial entity.
// If the ClinicalTrial object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicalTrialMutation) OldStudyID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStudyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStudyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStudyID: %w", err)
	}
	return oldValue.StudyID, nil
}

// ResetStudyID resets all changes to the "study_id" field.
func (m *ClinicalTrialMutation) ResetStudyID() {
	m.study_id = nil
}

// SetResultsDefinitionID sets the "results_definition" edge to the ResultsDefinition entity by id.
func (m *ClinicalTrialMutation) SetResultsDefinitionID(id int) {
	m.results_definition = &id
}

// ClearResultsDefinition clears the "results_definition" edge to the ResultsDefinition entity.
func (m *ClinicalTrialMutation) ClearResultsDefinition() {
	m.clearedresults_definition = true
}

// ResultsDefinitionCleared reports if the "results_definition" edge to the ResultsDefinition entity was cleared.
func (m *ClinicalTrialMutation) ResultsDefinitionCleared() bool {
	return m.clearedresults_definition
}

// ResultsDefinitionID returns the "results_definition" edge ID in the mutation.
func (m *ClinicalTrialMutation) ResultsDefinitionID() (id int, exists bool) {
	if m.results_definition != nil {
		return *m.results_definition, true
	}
	return
}

// ResultsDefinitionIDs returns the "results_definition" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ResultsDefinitionID instead. It exists only for internal usage by the builders.
func (m *ClinicalTrialMutation) ResultsDefinitionIDs() (ids []int) {
	if id := m.results_definition; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetResultsDefinition resets all changes to the "results_definition" edge.
func (m *ClinicalTrialMutation) ResetResultsDefinition() {
	m.results_definition = nil
	m.clearedresults_definition = false
}

// AddStudyLocationIDs adds the "study_locations" edge to the StudyLocation entity by ids.
func (m *ClinicalTrialMutation) AddStudyLocationIDs(ids ...int) {
	if m.study_locations == nil {
		m.study_locations = make(map[int]struct{})
	}
	for i := range ids {
		m.study_locations[ids[i]] = struct{}{}
	}
}

// ClearStudyLocations clears the "study_locations" edge to the StudyLocation entity.
func (m *ClinicalTrialMutation) ClearStudyLocations() {
	m.clearedstudy_locations = true
}

// StudyLocationsCleared reports if the "study_locations" edge to the StudyLocation entity was cleared.
func (m *ClinicalTrialMutation) StudyLocationsCleared() bool {
	return m.clearedstudy_locations
}

// RemoveStudyLocationIDs removes the "study_locations" edge to the StudyLocation entity by IDs.
func (m *ClinicalTrialMutation) RemoveStudyLocationIDs(ids ...int) {
	if m.removedstudy_locations == nil {
		m.removedstudy_locations = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.study_locations, ids[i])
		m.removedstudy_locations[ids[i]] = struct{}{}
	}
}

// RemovedStudyLocations returns the removed IDs of the "study_locations" edge to the StudyLocation entity.
func (m *ClinicalTrialMutation) RemovedStudyLocationsIDs() (ids []int) {
	for id := range m.removedstudy_locations {
		ids = append(ids, id)
	}
	return
}

// StudyLocationsIDs returns the "study_locations" edge IDs in the mutation.
func (m *ClinicalTrialMutation) StudyLocationsIDs() (ids []int) {
	for id := range m.study_locations {
		ids = append(ids, id)
	}
	return
}

// ResetStudyLocations resets all changes to the "study_locations" edge.
func (m *ClinicalTrialMutation) ResetStudyLocations() {
	m.study_locations = nil
	m.clearedstudy_locations = false
	m.removedstudy_locations = nil
}

// AddStudyEligibilityIDs adds the "study_eligibility" edge to the StudyEligibility entity by ids.
func (m *ClinicalTrialMutation) AddStudyEligibilityIDs(ids ...int) {
	if m.study_eligibility == nil {
		m.study_eligibility = make(map[int]struct{})
	}
	for i := range ids {
		m.study_eligibility[ids[i]] = struct{}{}
	}
}

// ClearStudyEligibility clears the "study_eligibility" edge to the StudyEligibility entity.
func (m *ClinicalTrialMutation) ClearStudyEligibility() {
	m.clearedstudy_eligibility = true
}

// StudyEligibilityCleared reports if the "study_eligibility" edge to the StudyEligibility entity was cleared.
func (m *ClinicalTrialMutation) StudyEligibilityCleared() bool {
	return m.clearedstudy_eligibility
}

// RemoveStudyEligibilityIDs removes the "study_eligibility" edge to the StudyEligibility entity by IDs.
func (m *ClinicalTrialMutation) RemoveStudyEligibilityIDs(ids ...int) {
	if m.removedstudy_eligibility == nil {
		m.removedstudy_eligibility = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.study_eligibility, ids[i])
		m.removedstudy_eligibility[ids[i]] = struct{}{}
	}
}

// RemovedStudyEligibility returns the removed IDs of the "study_eligibility" edge to the StudyEligibility entity.
func (m *ClinicalTrialMutation) RemovedStudyEligibilityIDs() (ids []int) {
	for id := range m.removedstudy_eligibility {
		ids = append(ids, id)
	}
	return
}

// StudyEligibilityIDs returns the "study_eligibility" edge IDs in the mutation.
func (m *ClinicalTrialMutation) StudyEligibilityIDs() (ids []int) {
	for id := range m.study_eligibility {
		ids = append(ids, id)
	}
	return
}

// ResetStudyEligibility resets all changes to the "study_eligibility" edge.
func (m *ClinicalTrialMutation) ResetStudyEligibility() {
	m.study_eligibility = nil
	m.clearedstudy_eligibility = false
	m.removedstudy_eligibility = nil
}

// AddMetadatumIDs adds the "metadata" edge to the ClinicalTrialMetadata entity by ids.
func (m *ClinicalTrialMutation) AddMetadatumIDs(ids ...int) {
	if m.metadata == nil {
		m.metadata = make(map[int]struct{})
	}
	for i := range ids {
		m.metadata[ids[i]] = struct{}{}
	}
}

// ClearMetadata clears the "metadata" edge to the ClinicalTrialMetadata entity.
func (m *ClinicalTrialMutation) ClearMetadata() {
	m.clearedmetadata = true
}

// MetadataCleared reports if the "metadata" edge to the ClinicalTrialMetadata entity was cleared.
func (m *ClinicalTrialMutation) MetadataCleared() bool {
	return m.clearedmetadata
}

// RemoveMetadatumIDs removes the "metadata" edge to the ClinicalTrialMetadata entity by IDs.
func (m *ClinicalTrialMutation) RemoveMetadatumIDs(ids ...int) {
	if m.removedmetadata == nil {
		m.removedmetadata = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.metadata, ids[i])
		m.removedmetadata[ids[i]] = struct{}{}
	}
}

// RemovedMetadata returns the removed IDs of the "metadata" edge to the ClinicalTrialMetadata entity.
func (m *ClinicalTrialMutation) RemovedMetadataIDs() (ids []int) {
	for id := range m.removedmetadata {
		ids = append(ids, id)
	}
	return
}

// MetadataIDs returns the "metadata" edge IDs in the mutation.
func (m *ClinicalTrialMutation) MetadataIDs() (ids []int) {
	for id := range m.metadata {
		ids = append(ids, id)
	}
	return
}

// ResetMetadata resets all changes to the "metadata" edge.
func (m *ClinicalTrialMutation) ResetMetadata() {
	m.metadata = nil
	m.clearedmetadata = false
	m.removedmetadata = nil
}

// Where appends a list predicates to the ClinicalTrialMutation builder.
func (m *ClinicalTrialMutation) Where(ps ...predicate.ClinicalTrial) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ClinicalTrialMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ClinicalTrial).
func (m *ClinicalTrialMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClinicalTrialMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.study_name != nil {
		fields = append(fields, clinicaltrial.FieldStudyName)
	}
	if m.sponsor != nil {
		fields = append(fields, clinicaltrial.FieldSponsor)
	}
	if m.responsible_party != nil {
		fields = append(fields, clinicaltrial.FieldResponsibleParty)
	}
	if m.study_type != nil {
		fields = append(fields, clinicaltrial.FieldStudyType)
	}
	if m.phase != nil {
		fields = append(fields, clinicaltrial.FieldPhase)
	}
	if m.actual_enrollment != nil {
		fields = append(fields, clinicaltrial.FieldActualEnrollment)
	}
	if m.allocation != nil {
		fields = append(fields, clinicaltrial.FieldAllocation)
	}
	if m.intervention_model != nil {
		fields = append(fields, clinicaltrial.FieldInterventionModel)
	}
	if m.masking != nil {
		fields = append(fields, clinicaltrial.FieldMasking)
	}
	if m.primary_purpose != nil {
		fields = append(fields, clinicaltrial.FieldPrimaryPurpose)
	}
	if m.official_title != nil {
		fields = append(fields, clinicaltrial.FieldOfficialTitle)
	}
	if m.actual_study_start_date != nil {
		fields = append(fields, clinicaltrial.FieldActualStudyStartDate)
	}
	if m.actual_primary_completion_date != nil {
		fields = append(fields, clinicaltrial.FieldActualPrimaryCompletionDate)
	}
	if m.actual_study_completion_date != nil {
		fields = append(fields, clinicaltrial.FieldActualStudyCompletionDate)
	}
	if m.study_id != nil {
		fields = append(fields, clinicaltrial.FieldStudyID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClinicalTrialMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case clinicaltrial.FieldStudyName:
		return m.StudyName()
	case clinicaltrial.FieldSponsor:
		return m.Sponsor()
	case clinicaltrial.FieldResponsibleParty:
		return m.ResponsibleParty()
	case clinicaltrial.FieldStudyType:
		return m.StudyType()
	case clinicaltrial.FieldPhase:
		return m.Phase()
	case clinicaltrial.FieldActualEnrollment:
		return m.ActualEnrollment()
	case clinicaltrial.FieldAllocation:
		return m.Allocation()
	case clinicaltrial.FieldInterventionModel:
		return m.InterventionModel()
	case clinicaltrial.FieldMasking:
		return m.Masking()
	case clinicaltrial.FieldPrimaryPurpose:
		return m.PrimaryPurpose()
	case clinicaltrial.FieldOfficialTitle:
		return m.OfficialTitle()
	case clinicaltrial.FieldActualStudyStartDate:
		return m.ActualStudyStartDate()
	case clinicaltrial.FieldActualPrimaryCompletionDate:
		return m.ActualPrimaryCompletionDate()
	case clinicaltrial.FieldActualStudyCompletionDate:
		return m.ActualStudyCompletionDate()
	case clinicaltrial.FieldStudyID:
		return m.StudyID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClinicalTrialMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case clinicaltrial.FieldStudyName:
		return m.OldStudyName(ctx)
	case clinicaltrial.FieldSponsor:
		return m.OldSponsor(ctx)
	case clinicaltrial.FieldResponsibleParty:
		return m.OldResponsibleParty(ctx)
	case clinicaltrial.FieldStudyType:
		return m.OldStudyType(ctx)
	case clinicaltrial.FieldPhase:
		return m.OldPhase(ctx)
	case clinicaltrial.FieldActualEnrollment:
		return m.OldActualEnrollment(ctx)
	case clinicaltrial.FieldAllocation:
		return m.OldAllocation(ctx)
	case clinicaltrial.FieldInterventionModel:
		return m.OldInterventionModel(ctx)
	case clinicaltrial.FieldMasking:
		return m.OldMasking(ctx)
	case clinicaltrial.FieldPrimaryPurpose:
		return m.OldPrimaryPurpose(ctx)
	case clinicaltrial.FieldOfficialTitle:
		return m.OldOfficialTitle(ctx)
	case clinicaltrial.FieldActualStudyStartDate:
		return m.OldActualStudyStartDate(ctx)
	case clinicaltrial.FieldActualPrimaryCompletionDate:
		return m.OldActualPrimaryCompletionDate(ctx)
	case clinicaltrial.FieldActualStudyCompletionDate:
		return m.OldActualStudyCompletionDate(ctx)
	case clinicaltrial.FieldStudyID:
		return m.OldStudyID(ctx)
	}
	return nil, fmt.Errorf("unknown ClinicalTrial field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClinicalTrialMutation) SetField(name string, value ent.Value) error {
	switch name {
	case clinicaltrial.FieldStudyName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStudyName(v)
		return nil
	case clinicaltrial.FieldSponsor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSponsor(v)
		return nil
	case clinicaltrial.FieldResponsibleParty:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponsibleParty(v)
		return nil
	case clinicaltrial.FieldStudyType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStudyType(v)
		return nil
	case clinicaltrial.FieldPhase:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhase(v)
		return nil
	case clinicaltrial.FieldActualEnrollment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActualEnrollment(v)
		return nil
	case clinicaltrial.FieldAllocation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllocation(v)
		return nil
	case clinicaltrial.FieldInterventionModel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInterventionModel(v)
		return nil
	case clinicaltrial.FieldMasking:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMasking(v)
		return nil
	case clinicaltrial.FieldPrimaryPurpose:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryPurpose(v)
		return nil
	case clinicaltrial.FieldOfficialTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOfficialTitle(v)
		return nil
	case clinicaltrial.FieldActualStudyStartDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActualStudyStartDate(v)
		return nil
	case clinicaltrial.FieldActualPrimaryCompletionDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActualPrimaryCompletionDate(v)
		return nil
	case clinicaltrial.FieldActualStudyCompletionDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActualStudyCompletionDate(v)
		return nil
	case clinicaltrial.FieldStudyID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStudyID(v)
		return nil
	}
	return fmt.Errorf("unknown ClinicalTrial field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClinicalTrialMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClinicalTrialMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClinicalTrialMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ClinicalTrial numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClinicalTrialMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClinicalTrialMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClinicalTrialMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ClinicalTrial nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClinicalTrialMutation) ResetField(name string) error {
	switch name {
	case clinicaltrial.FieldStudyName:
		m.ResetStudyName()
		return nil
	case clinicaltrial.FieldSponsor:
		m.ResetSponsor()
		return nil
	case clinicaltrial.FieldResponsibleParty:
		m.ResetResponsibleParty()
		return nil
	case clinicaltrial.FieldStudyType:
		m.ResetStudyType()
		return nil
	case clinicaltrial.FieldPhase:
		m.ResetPhase()
		return nil
	case clinicaltrial.FieldActualEnrollment:
		m.ResetActualEnrollment()
		return nil
	case clinicaltrial.FieldAllocation:
		m.ResetAllocation()
		return nil
	case clinicaltrial.FieldInterventionModel:
		m.ResetInterventionModel()
		return nil
	case clinicaltrial.FieldMasking:
		m.ResetMasking()
		return nil
	case clinicaltrial.FieldPrimaryPurpose:
		m.ResetPrimaryPurpose()
		return nil
	case clinicaltrial.FieldOfficialTitle:
		m.ResetOfficialTitle()
		return nil
	case clinicaltrial.FieldActualStudyStartDate:
		m.ResetActualStudyStartDate()
		return nil
	case clinicaltrial.FieldActualPrimaryCompletionDate:
		m.ResetActualPrimaryCompletionDate()
		return nil
	case clinicaltrial.FieldActualStudyCompletionDate:
		m.ResetActualStudyCompletionDate()
		return nil
	case clinicaltrial.FieldStudyID:
		m.ResetStudyID()
		return nil
	}
	return fmt.Errorf("unknown ClinicalTrial field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClinicalTrialMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.results_definition != nil {
		edges = append(edges, clinicaltrial.EdgeResultsDefinition)
	}
	if m.study_locations != nil {
		edges = append(edges, clinicaltrial.EdgeStudyLocations)
	}
	if m.study_eligibility != nil {
		edges = append(edges, clinicaltrial.EdgeStudyEligibility)
	}
	if m.metadata != nil {
		edges = append(edges, clinicaltrial.EdgeMetadata)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClinicalTrialMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case clinicaltrial.EdgeResultsDefinition:
		if id := m.results_definition; id != nil {
			return []ent.Value{*id}
		}
	case clinicaltrial.EdgeStudyLocations:
		ids := make([]ent.Value, 0, len(m.study_locations))
		for id := range m.study_locations {
			ids = append(ids, id)
		}
		return ids
	case clinicaltrial.EdgeStudyEligibility:
		ids := make([]ent.Value, 0, len(m.study_eligibility))
		for id := range m.study_eligibility {
			ids = append(ids, id)
		}
		return ids
	case clinicaltrial.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.metadata))
		for id := range m.metadata {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClinicalTrialMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedstudy_locations != nil {
		edges = append(edges, clinicaltrial.EdgeStudyLocations)
	}
	if m.removedstudy_eligibility != nil {
		edges = append(edges, clinicaltrial.EdgeStudyEligibility)
	}
	if m.removedmetadata != nil {
		edges = append(edges, clinicaltrial.EdgeMetadata)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClinicalTrialMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case clinicaltrial.EdgeStudyLocations:
		ids := make([]ent.Value, 0, len(m.removedstudy_locations))
		for id := range m.removedstudy_locations {
			ids = append(ids, id)
		}
		return ids
	case clinicaltrial.EdgeStudyEligibility:
		ids := make([]ent.Value, 0, len(m.removedstudy_eligibility))
		for id := range m.removedstudy_eligibility {
			ids = append(ids, id)
		}
		return ids
	case clinicaltrial.EdgeMetadata:
		ids := make([]ent.Value, 0, len(m.removedmetadata))
		for id := range m.removedmetadata {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClinicalTrialMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedresults_definition {
		edges = append(edges, clinicaltrial.EdgeResultsDefinition)
	}
	if m.clearedstudy_locations {
		edges = append(edges, clinicaltrial.EdgeStudyLocations)
	}
	if m.clearedstudy_eligibility {
		edges = append(edges, clinicaltrial.EdgeStudyEligibility)
	}
	if m.clearedmetadata {
		edges = append(edges, clinicaltrial.EdgeMetadata)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClinicalTrialMutation) EdgeCleared(name string) bool {
	switch name {
	case clinicaltrial.EdgeResultsDefinition:
		return m.clearedresults_definition
	case clinicaltrial.EdgeStudyLocations:
		return m.clearedstudy_locations
	case clinicaltrial.EdgeStudyEligibility:
		return m.clearedstudy_eligibility
	case clinicaltrial.EdgeMetadata:
		return m.clearedmetadata
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClinicalTrialMutation) ClearEdge(name string) error {
	switch name {
	case clinicaltrial.EdgeResultsDefinition:
		m.ClearResultsDefinition()
		return nil
	}
	return fmt.Errorf("unknown ClinicalTrial unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClinicalTrialMutation) ResetEdge(name string) error {
	switch name {
	case clinicaltrial.EdgeResultsDefinition:
		m.ResetResultsDefinition()
		return nil
	case clinicaltrial.EdgeStudyLocations:
		m.ResetStudyLocations()
		return nil
	case clinicaltrial.EdgeStudyEligibility:
		m.ResetStudyEligibility()
		return nil
	case clinicaltrial.EdgeMetadata:
		m.ResetMetadata()
		return nil
	}
	return fmt.Errorf("unknown ClinicalTrial edge %s", name)
}

// ClinicalTrialMetadataMutation represents an operation that mutates the ClinicalTrialMetadata nodes in the graph.
type ClinicalTrialMetadataMutation struct {
	config
	op            Op
	typ           string
	id            *int
	tag_name      *string
	tag_value     *string
	use_case_code *string
	clearedFields map[string]struct{}
	parent        *int
	clearedparent bool
	done          bool
	oldValue      func(context.Context) (*ClinicalTrialMetadata, error)
	predicates    []predicate.ClinicalTrialMetadata
}

var _ ent.Mutation = (*ClinicalTrialMetadataMutation)(nil)

// clinicaltrialmetadataOption allows management of the mutation configuration using functional options.
type clinicaltrialmetadataOption func(*ClinicalTrialMetadataMutation)

// newClinicalTrialMetadataMutation creates new mutation for the ClinicalTrialMetadata entity.
func newClinicalTrialMetadataMutation(c config, op Op, opts ...clinicaltrialmetadataOption) *ClinicalTrialMetadataMutation {
	m := &ClinicalTrialMetadataMutation{
		config:        c,
		op:            op,
		typ:           TypeClinicalTrialMetadata,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClinicalTrialMetadataID sets the ID field of the mutation.
func withClinicalTrialMetadataID(id int) clinicaltrialmetadataOption {
	return func(m *ClinicalTrialMetadataMutation) {
		var (
			err   error
			once  sync.Once
			value *ClinicalTrialMetadata
		)
		m.oldValue = func(ctx context.Context) (*ClinicalTrialMetadata, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ClinicalTrialMetadata.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClinicalTrialMetadata sets the old ClinicalTrialMetadata of the mutation.
func withClinicalTrialMetadata(node *ClinicalTrialMetadata) clinicaltrialmetadataOption {
	return func(m *ClinicalTrialMetadataMutation) {
		m.oldValue = func(context.Context) (*ClinicalTrialMetadata, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClinicalTrialMetadataMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClinicalTrialMetadataMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClinicalTrialMetadataMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ClinicalTrialMetadataMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ClinicalTrialMetadata.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTagName sets the "tag_name" field.
func (m *ClinicalTrialMetadataMutation) SetTagName(s string) {
	m.tag_name = &s
}

// TagName returns the value of the "tag_name" field in the mutation.
func (m *ClinicalTrialMetadataMutation) TagName() (r string, exists bool) {
	v := m.tag_name
	if v == nil {
		return
	}
	return *v, true
}

// OldTagName returns the old "tag_name" field's value of the ClinicalTrialMetadata entity.
// If the ClinicalTrialMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicalTrialMetadataMutation) OldTagName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTagName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTagName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTagName: %w", err)
	}
	return oldValue.TagName, nil
}

// ResetTagName resets all changes to the "tag_name" field.
func (m *ClinicalTrialMetadataMutation) ResetTagName() {
	m.tag_name = nil
}

// SetTagValue sets the "tag_value" field.
func (m *ClinicalTrialMetadataMutation) SetTagValue(s string) {
	m.tag_value = &s
}

// TagValue returns the value of the "tag_value" field in the mutation.
func (m *ClinicalTrialMetadataMutation) TagValue() (r string, exists bool) {
	v := m.tag_value
	if v == nil {
		return
	}
	return *v, true
}

// OldTagValue returns the old "tag_value" field's value of the ClinicalTrialMetadata entity.
// If the ClinicalTrialMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicalTrialMetadataMutation) OldTagValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTagValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTagValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTagValue: %w", err)
	}
	return oldValue.TagValue, nil
}

// ResetTagValue resets all changes to the "tag_value" field.
func (m *ClinicalTrialMetadataMutation) ResetTagValue() {
	m.tag_value = nil
}

// SetUseCaseCode sets the "use_case_code" field.
func (m *ClinicalTrialMetadataMutation) SetUseCaseCode(s string) {
	m.use_case_code = &s
}

// UseCaseCode returns the value of the "use_case_code" field in the mutation.
func (m *ClinicalTrialMetadataMutation) UseCaseCode() (r string, exists bool) {
	v := m.use_case_code
	if v == nil {
		return
	}
	return *v, true
}

// OldUseCaseCode returns the old "use_case_code" field's value of the ClinicalTrialMetadata entity.
// If the ClinicalTrialMetadata object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClinicalTrialMetadataMutation) OldUseCaseCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseCaseCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseCaseCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseCaseCode: %w", err)
	}
	return oldValue.UseCaseCode, nil
}

// ResetUseCaseCode resets all changes to the "use_case_code" field.
func (m *ClinicalTrialMetadataMutation) ResetUseCaseCode() {
	m.use_case_code = nil
}

// SetParentID sets the "parent" edge to the ClinicalTrial entity by id.
func (m *ClinicalTrialMetadataMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ClinicalTrial entity.
func (m *ClinicalTrialMetadataMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ClinicalTrial entity was cleared.
func (m *ClinicalTrialMetadataMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *ClinicalTrialMetadataMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *ClinicalTrialMetadataMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *ClinicalTrialMetadataMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// Where appends a list predicates to the ClinicalTrialMetadataMutation builder.
func (m *ClinicalTrialMetadataMutation) Where(ps ...predicate.ClinicalTrialMetadata) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ClinicalTrialMetadataMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ClinicalTrialMetadata).
func (m *ClinicalTrialMetadataMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClinicalTrialMetadataMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tag_name != nil {
		fields = append(fields, clinicaltrialmetadata.FieldTagName)
	}
	if m.tag_value != nil {
		fields = append(fields, clinicaltrialmetadata.FieldTagValue)
	}
	if m.use_case_code != nil {
		fields = append(fields, clinicaltrialmetadata.FieldUseCaseCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClinicalTrialMetadataMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case clinicaltrialmetadata.FieldTagName:
		return m.TagName()
	case clinicaltrialmetadata.FieldTagValue:
		return m.TagValue()
	case clinicaltrialmetadata.FieldUseCaseCode:
		return m.UseCaseCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClinicalTrialMetadataMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case clinicaltrialmetadata.FieldTagName:
		return m.OldTagName(ctx)
	case clinicaltrialmetadata.FieldTagValue:
		return m.OldTagValue(ctx)
	case clinicaltrialmetadata.FieldUseCaseCode:
		return m.OldUseCaseCode(ctx)
	}
	return nil, fmt.Errorf("unknown ClinicalTrialMetadata field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClinicalTrialMetadataMutation) SetField(name string, value ent.Value) error {
	switch name {
	case clinicaltrialmetadata.FieldTagName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagName(v)
		return nil
	case clinicaltrialmetadata.FieldTagValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagValue(v)
		return nil
	case clinicaltrialmetadata.FieldUseCaseCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseCaseCode(v)
		return nil
	}
	return fmt.Errorf("unknown ClinicalTrialMetadata field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClinicalTrialMetadataMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClinicalTrialMetadataMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClinicalTrialMetadataMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ClinicalTrialMetadata numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClinicalTrialMetadataMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClinicalTrialMetadataMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClinicalTrialMetadataMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ClinicalTrialMetadata nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClinicalTrialMetadataMutation) ResetField(name string) error {
	switch name {
	case clinicaltrialmetadata.FieldTagName:
		m.ResetTagName()
		return nil
	case clinicaltrialmetadata.FieldTagValue:
		m.ResetTagValue()
		return nil
	case clinicaltrialmetadata.FieldUseCaseCode:
		m.ResetUseCaseCode()
		return nil
	}
	return fmt.Errorf("unknown ClinicalTrialMetadata field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClinicalTrialMetadataMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.parent != nil {
		edges = append(edges, clinicaltrialmetadata.EdgeParent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClinicalTrialMetadataMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case clinicaltrialmetadata.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClinicalTrialMetadataMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClinicalTrialMetadataMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClinicalTrialMetadataMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparent {
		edges = append(edges, clinicaltrialmetadata.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClinicalTrialMetadataMutation) EdgeCleared(name string) bool {
	switch name {
	case clinicaltrialmetadata.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClinicalTrialMetadataMutation) ClearEdge(name string) error {
	switch name {
	case clinicaltrialmetadata.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown ClinicalTrialMetadata unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClinicalTrialMetadataMutation) ResetEdge(name string) error {
	switch name {
	case clinicaltrialmetadata.EdgeParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown ClinicalTrialMetadata edge %s", name)
}

// DoseDescriptionMutation represents an operation that mutates the DoseDescription nodes in the graph.
type DoseDescriptionMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*DoseDescription, error)
	predicates    []predicate.DoseDescription
}

var _ ent.Mutation = (*DoseDescriptionMutation)(nil)

// dosedescriptionOption allows management of the mutation configuration using functional options.
type dosedescriptionOption func(*DoseDescriptionMutation)

// newDoseDescriptionMutation creates new mutation for the DoseDescription entity.
func newDoseDescriptionMutation(c config, op Op, opts ...dosedescriptionOption) *DoseDescriptionMutation {
	m := &DoseDescriptionMutation{
		config:        c,
		op:            op,
		typ:           TypeDoseDescription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDoseDescriptionID sets the ID field of the mutation.
func withDoseDescriptionID(id int) dosedescriptionOption {
	return func(m *DoseDescriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *DoseDescription
		)
		m.oldValue = func(ctx context.Context) (*DoseDescription, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DoseDescription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDoseDescription sets the old DoseDescription of the mutation.
func withDoseDescription(node *DoseDescription) dosedescriptionOption {
	return func(m *DoseDescriptionMutation) {
		m.oldValue = func(context.Context) (*DoseDescription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DoseDescriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DoseDescriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DoseDescriptionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DoseDescriptionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DoseDescription.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *DoseDescriptionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DoseDescriptionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DoseDescription entity.
// If the DoseDescription object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DoseDescriptionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DoseDescriptionMutation) ResetName() {
	m.name = nil
}

// Where appends a list predicates to the DoseDescriptionMutation builder.
func (m *DoseDescriptionMutation) Where(ps ...predicate.DoseDescription) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *DoseDescriptionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (DoseDescription).
func (m *DoseDescriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DoseDescriptionMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, dosedescription.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DoseDescriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case dosedescription.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DoseDescriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case dosedescription.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown DoseDescription field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DoseDescriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case dosedescription.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown DoseDescription field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DoseDescriptionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DoseDescriptionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DoseDescriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DoseDescription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DoseDescriptionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DoseDescriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DoseDescriptionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DoseDescription nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DoseDescriptionMutation) ResetField(name string) error {
	switch name {
	case dosedescription.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown DoseDescription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DoseDescriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DoseDescriptionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DoseDescriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DoseDescriptionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DoseDescriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DoseDescriptionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DoseDescriptionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DoseDescription unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DoseDescriptionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DoseDescription edge %s", name)
}

// EventGroupMutation represents an operation that mutates the EventGroup nodes in the graph.
type EventGroupMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	event_group_id                   *string
	event_group_title                *string
	event_group_description          *string
	event_group_deaths_num_affected  *string
	event_group_deaths_num_at_risk   *string
	event_group_serious_num_affected *string
	event_group_serious_num_at_risk  *string
	event_group_other_num_affected   *string
	event_group_other_num_at_risk    *string
	clearedFields                    map[string]struct{}
	parent                           *int
	clearedparent                    bool
	done                             bool
	oldValue                         func(context.Context) (*EventGroup, error)
	predicates                       []predicate.EventGroup
}

var _ ent.Mutation = (*EventGroupMutation)(nil)

// eventgroupOption allows management of the mutation configuration using functional options.
type eventgroupOption func(*EventGroupMutation)

// newEventGroupMutation creates new mutation for the EventGroup entity.
func newEventGroupMutation(c config, op Op, opts ...eventgroupOption) *EventGroupMutation {
	m := &EventGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeEventGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEventGroupID sets the ID field of the mutation.
func withEventGroupID(id int) eventgroupOption {
	return func(m *EventGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *EventGroup
		)
		m.oldValue = func(ctx context.Context) (*EventGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EventGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEventGroup sets the old EventGroup of the mutation.
func withEventGroup(node *EventGroup) eventgroupOption {
	return func(m *EventGroupMutation) {
		m.oldValue = func(context.Context) (*EventGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EventGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EventGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EventGroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EventGroupMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EventGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEventGroupID sets the "event_group_id" field.
func (m *EventGroupMutation) SetEventGroupID(s string) {
	m.event_group_id = &s
}

// EventGroupID returns the value of the "event_group_id" field in the mutation.
func (m *EventGroupMutation) EventGroupID() (r string, exists bool) {
	v := m.event_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEventGroupID returns the old "event_group_id" field's value of the EventGroup entity.
// If the EventGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventGroupMutation) OldEventGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventGroupID: %w", err)
	}
	return oldValue.EventGroupID, nil
}

// ResetEventGroupID resets all changes to the "event_group_id" field.
func (m *EventGroupMutation) ResetEventGroupID() {
	m.event_group_id = nil
}

// SetEventGroupTitle sets the "event_group_title" field.
func (m *EventGroupMutation) SetEventGroupTitle(s string) {
	m.event_group_title = &s
}

// EventGroupTitle returns the value of the "event_group_title" field in the mutation.
func (m *EventGroupMutation) EventGroupTitle() (r string, exists bool) {
	v := m.event_group_title
	if v == nil {
		return
	}
	return *v, true
}

// OldEventGroupTitle returns the old "event_group_title" field's value of the EventGroup entity.
// If the EventGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventGroupMutation) OldEventGroupTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventGroupTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventGroupTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventGroupTitle: %w", err)
	}
	return oldValue.EventGroupTitle, nil
}

// ResetEventGroupTitle resets all changes to the "event_group_title" field.
func (m *EventGroupMutation) ResetEventGroupTitle() {
	m.event_group_title = nil
}

// SetEventGroupDescription sets the "event_group_description" field.
func (m *EventGroupMutation) SetEventGroupDescription(s string) {
	m.event_group_description = &s
}

// EventGroupDescription returns the value of the "event_group_description" field in the mutation.
func (m *EventGroupMutation) EventGroupDescription() (r string, exists bool) {
	v := m.event_group_description
	if v == nil {
		return
	}
	return *v, true
}

// OldEventGroupDescription returns the old "event_group_description" field's value of the EventGroup entity.
// If the EventGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventGroupMutation) OldEventGroupDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventGroupDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventGroupDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventGroupDescription: %w", err)
	}
	return oldValue.EventGroupDescription, nil
}

// ResetEventGroupDescription resets all changes to the "event_group_description" field.
func (m *EventGroupMutation) ResetEventGroupDescription() {
	m.event_group_description = nil
}

// SetEventGroupDeathsNumAffected sets the "event_group_deaths_num_affected" field.
func (m *EventGroupMutation) SetEventGroupDeathsNumAffected(s string) {
	m.event_group_deaths_num_affected = &s
}

// EventGroupDeathsNumAffected returns the value of the "event_group_deaths_num_affected" field in the mutation.
func (m *EventGroupMutation) EventGroupDeathsNumAffected() (r string, exists bool) {
	v := m.event_group_deaths_num_affected
	if v == nil {
		return
	}
	return *v, true
}

// OldEventGroupDeathsNumAffected returns the old "event_group_deaths_num_affected" field's value of the EventGroup entity.
// If the EventGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventGroupMutation) OldEventGroupDeathsNumAffected(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventGroupDeathsNumAffected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventGroupDeathsNumAffected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventGroupDeathsNumAffected: %w", err)
	}
	return oldValue.EventGroupDeathsNumAffected, nil
}

// ResetEventGroupDeathsNumAffected resets all changes to the "event_group_deaths_num_affected" field.
func (m *EventGroupMutation) ResetEventGroupDeathsNumAffected() {
	m.event_group_deaths_num_affected = nil
}

// SetEventGroupDeathsNumAtRisk sets the "event_group_deaths_num_at_risk" field.
func (m *EventGroupMutation) SetEventGroupDeathsNumAtRisk(s string) {
	m.event_group_deaths_num_at_risk = &s
}

// EventGroupDeathsNumAtRisk returns the value of the "event_group_deaths_num_at_risk" field in the mutation.
func (m *EventGroupMutation) EventGroupDeathsNumAtRisk() (r string, exists bool) {
	v := m.event_group_deaths_num_at_risk
	if v == nil {
		return
	}
	return *v, true
}

// OldEventGroupDeathsNumAtRisk returns the old "event_group_deaths_num_at_risk" field's value of the EventGroup entity.
// If the EventGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventGroupMutation) OldEventGroupDeathsNumAtRisk(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventGroupDeathsNumAtRisk is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventGroupDeathsNumAtRisk requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventGroupDeathsNumAtRisk: %w", err)
	}
	return oldValue.EventGroupDeathsNumAtRisk, nil
}

// ResetEventGroupDeathsNumAtRisk resets all changes to the "event_group_deaths_num_at_risk" field.
func (m *EventGroupMutation) ResetEventGroupDeathsNumAtRisk() {
	m.event_group_deaths_num_at_risk = nil
}

// SetEventGroupSeriousNumAffected sets the "event_group_serious_num_affected" field.
func (m *EventGroupMutation) SetEventGroupSeriousNumAffected(s string) {
	m.event_group_serious_num_affected = &s
}

// EventGroupSeriousNumAffected returns the value of the "event_group_serious_num_affected" field in the mutation.
func (m *EventGroupMutation) EventGroupSeriousNumAffected() (r string, exists bool) {
	v := m.event_group_serious_num_affected
	if v == nil {
		return
	}
	return *v, true
}

// OldEventGroupSeriousNumAffected returns the old "event_group_serious_num_affected" field's value of the EventGroup entity.
// If the EventGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventGroupMutation) OldEventGroupSeriousNumAffected(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventGroupSeriousNumAffected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventGroupSeriousNumAffected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventGroupSeriousNumAffected: %w", err)
	}
	return oldValue.EventGroupSeriousNumAffected, nil
}

// ResetEventGroupSeriousNumAffected resets all changes to the "event_group_serious_num_affected" field.
func (m *EventGroupMutation) ResetEventGroupSeriousNumAffected() {
	m.event_group_serious_num_affected = nil
}

// SetEventGroupSeriousNumAtRisk sets the "event_group_serious_num_at_risk" field.
func (m *EventGroupMutation) SetEventGroupSeriousNumAtRisk(s string) {
	m.event_group_serious_num_at_risk = &s
}

// EventGroupSeriousNumAtRisk returns the value of the "event_group_serious_num_at_risk" field in the mutation.
func (m *EventGroupMutation) EventGroupSeriousNumAtRisk() (r string, exists bool) {
	v := m.event_group_serious_num_at_risk
	if v == nil {
		return
	}
	return *v, true
}

// OldEventGroupSeriousNumAtRisk returns the old "event_group_serious_num_at_risk" field's value of the EventGroup entity.
// If the EventGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventGroupMutation) OldEventGroupSeriousNumAtRisk(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventGroupSeriousNumAtRisk is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventGroupSeriousNumAtRisk requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventGroupSeriousNumAtRisk: %w", err)
	}
	return oldValue.EventGroupSeriousNumAtRisk, nil
}

// ResetEventGroupSeriousNumAtRisk resets all changes to the "event_group_serious_num_at_risk" field.
func (m *EventGroupMutation) ResetEventGroupSeriousNumAtRisk() {
	m.event_group_serious_num_at_risk = nil
}

// SetEventGroupOtherNumAffected sets the "event_group_other_num_affected" field.
func (m *EventGroupMutation) SetEventGroupOtherNumAffected(s string) {
	m.event_group_other_num_affected = &s
}

// EventGroupOtherNumAffected returns the value of the "event_group_other_num_affected" field in the mutation.
func (m *EventGroupMutation) EventGroupOtherNumAffected() (r string, exists bool) {
	v := m.event_group_other_num_affected
	if v == nil {
		return
	}
	return *v, true
}

// OldEventGroupOtherNumAffected returns the old "event_group_other_num_affected" field's value of the EventGroup entity.
// If the EventGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventGroupMutation) OldEventGroupOtherNumAffected(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventGroupOtherNumAffected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventGroupOtherNumAffected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventGroupOtherNumAffected: %w", err)
	}
	return oldValue.EventGroupOtherNumAffected, nil
}

// ResetEventGroupOtherNumAffected resets all changes to the "event_group_other_num_affected" field.
func (m *EventGroupMutation) ResetEventGroupOtherNumAffected() {
	m.event_group_other_num_affected = nil
}

// SetEventGroupOtherNumAtRisk sets the "event_group_other_num_at_risk" field.
func (m *EventGroupMutation) SetEventGroupOtherNumAtRisk(s string) {
	m.event_group_other_num_at_risk = &s
}

// EventGroupOtherNumAtRisk returns the value of the "event_group_other_num_at_risk" field in the mutation.
func (m *EventGroupMutation) EventGroupOtherNumAtRisk() (r string, exists bool) {
	v := m.event_group_other_num_at_risk
	if v == nil {
		return
	}
	return *v, true
}

// OldEventGroupOtherNumAtRisk returns the old "event_group_other_num_at_risk" field's value of the EventGroup entity.
// If the EventGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EventGroupMutation) OldEventGroupOtherNumAtRisk(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventGroupOtherNumAtRisk is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventGroupOtherNumAtRisk requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventGroupOtherNumAtRisk: %w", err)
	}
	return oldValue.EventGroupOtherNumAtRisk, nil
}

// ResetEventGroupOtherNumAtRisk resets all changes to the "event_group_other_num_at_risk" field.
func (m *EventGroupMutation) ResetEventGroupOtherNumAtRisk() {
	m.event_group_other_num_at_risk = nil
}

// SetParentID sets the "parent" edge to the AdverseEventsModule entity by id.
func (m *EventGroupMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the AdverseEventsModule entity.
func (m *EventGroupMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the AdverseEventsModule entity was cleared.
func (m *EventGroupMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *EventGroupMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *EventGroupMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *EventGroupMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// Where appends a list predicates to the EventGroupMutation builder.
func (m *EventGroupMutation) Where(ps ...predicate.EventGroup) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *EventGroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (EventGroup).
func (m *EventGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EventGroupMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.event_group_id != nil {
		fields = append(fields, eventgroup.FieldEventGroupID)
	}
	if m.event_group_title != nil {
		fields = append(fields, eventgroup.FieldEventGroupTitle)
	}
	if m.event_group_description != nil {
		fields = append(fields, eventgroup.FieldEventGroupDescription)
	}
	if m.event_group_deaths_num_affected != nil {
		fields = append(fields, eventgroup.FieldEventGroupDeathsNumAffected)
	}
	if m.event_group_deaths_num_at_risk != nil {
		fields = append(fields, eventgroup.FieldEventGroupDeathsNumAtRisk)
	}
	if m.event_group_serious_num_affected != nil {
		fields = append(fields, eventgroup.FieldEventGroupSeriousNumAffected)
	}
	if m.event_group_serious_num_at_risk != nil {
		fields = append(fields, eventgroup.FieldEventGroupSeriousNumAtRisk)
	}
	if m.event_group_other_num_affected != nil {
		fields = append(fields, eventgroup.FieldEventGroupOtherNumAffected)
	}
	if m.event_group_other_num_at_risk != nil {
		fields = append(fields, eventgroup.FieldEventGroupOtherNumAtRisk)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EventGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case eventgroup.FieldEventGroupID:
		return m.EventGroupID()
	case eventgroup.FieldEventGroupTitle:
		return m.EventGroupTitle()
	case eventgroup.FieldEventGroupDescription:
		return m.EventGroupDescription()
	case eventgroup.FieldEventGroupDeathsNumAffected:
		return m.EventGroupDeathsNumAffected()
	case eventgroup.FieldEventGroupDeathsNumAtRisk:
		return m.EventGroupDeathsNumAtRisk()
	case eventgroup.FieldEventGroupSeriousNumAffected:
		return m.EventGroupSeriousNumAffected()
	case eventgroup.FieldEventGroupSeriousNumAtRisk:
		return m.EventGroupSeriousNumAtRisk()
	case eventgroup.FieldEventGroupOtherNumAffected:
		return m.EventGroupOtherNumAffected()
	case eventgroup.FieldEventGroupOtherNumAtRisk:
		return m.EventGroupOtherNumAtRisk()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EventGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case eventgroup.FieldEventGroupID:
		return m.OldEventGroupID(ctx)
	case eventgroup.FieldEventGroupTitle:
		return m.OldEventGroupTitle(ctx)
	case eventgroup.FieldEventGroupDescription:
		return m.OldEventGroupDescription(ctx)
	case eventgroup.FieldEventGroupDeathsNumAffected:
		return m.OldEventGroupDeathsNumAffected(ctx)
	case eventgroup.FieldEventGroupDeathsNumAtRisk:
		return m.OldEventGroupDeathsNumAtRisk(ctx)
	case eventgroup.FieldEventGroupSeriousNumAffected:
		return m.OldEventGroupSeriousNumAffected(ctx)
	case eventgroup.FieldEventGroupSeriousNumAtRisk:
		return m.OldEventGroupSeriousNumAtRisk(ctx)
	case eventgroup.FieldEventGroupOtherNumAffected:
		return m.OldEventGroupOtherNumAffected(ctx)
	case eventgroup.FieldEventGroupOtherNumAtRisk:
		return m.OldEventGroupOtherNumAtRisk(ctx)
	}
	return nil, fmt.Errorf("unknown EventGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case eventgroup.FieldEventGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventGroupID(v)
		return nil
	case eventgroup.FieldEventGroupTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventGroupTitle(v)
		return nil
	case eventgroup.FieldEventGroupDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventGroupDescription(v)
		return nil
	case eventgroup.FieldEventGroupDeathsNumAffected:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventGroupDeathsNumAffected(v)
		return nil
	case eventgroup.FieldEventGroupDeathsNumAtRisk:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventGroupDeathsNumAtRisk(v)
		return nil
	case eventgroup.FieldEventGroupSeriousNumAffected:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventGroupSeriousNumAffected(v)
		return nil
	case eventgroup.FieldEventGroupSeriousNumAtRisk:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventGroupSeriousNumAtRisk(v)
		return nil
	case eventgroup.FieldEventGroupOtherNumAffected:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventGroupOtherNumAffected(v)
		return nil
	case eventgroup.FieldEventGroupOtherNumAtRisk:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventGroupOtherNumAtRisk(v)
		return nil
	}
	return fmt.Errorf("unknown EventGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EventGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EventGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EventGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EventGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EventGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EventGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EventGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown EventGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EventGroupMutation) ResetField(name string) error {
	switch name {
	case eventgroup.FieldEventGroupID:
		m.ResetEventGroupID()
		return nil
	case eventgroup.FieldEventGroupTitle:
		m.ResetEventGroupTitle()
		return nil
	case eventgroup.FieldEventGroupDescription:
		m.ResetEventGroupDescription()
		return nil
	case eventgroup.FieldEventGroupDeathsNumAffected:
		m.ResetEventGroupDeathsNumAffected()
		return nil
	case eventgroup.FieldEventGroupDeathsNumAtRisk:
		m.ResetEventGroupDeathsNumAtRisk()
		return nil
	case eventgroup.FieldEventGroupSeriousNumAffected:
		m.ResetEventGroupSeriousNumAffected()
		return nil
	case eventgroup.FieldEventGroupSeriousNumAtRisk:
		m.ResetEventGroupSeriousNumAtRisk()
		return nil
	case eventgroup.FieldEventGroupOtherNumAffected:
		m.ResetEventGroupOtherNumAffected()
		return nil
	case eventgroup.FieldEventGroupOtherNumAtRisk:
		m.ResetEventGroupOtherNumAtRisk()
		return nil
	}
	return fmt.Errorf("unknown EventGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EventGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.parent != nil {
		edges = append(edges, eventgroup.EdgeParent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EventGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case eventgroup.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EventGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EventGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EventGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparent {
		edges = append(edges, eventgroup.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EventGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case eventgroup.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EventGroupMutation) ClearEdge(name string) error {
	switch name {
	case eventgroup.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown EventGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EventGroupMutation) ResetEdge(name string) error {
	switch name {
	case eventgroup.EdgeParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown EventGroup edge %s", name)
}

// FlowAchievementMutation represents an operation that mutates the FlowAchievement nodes in the graph.
type FlowAchievementMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	flow_achievement_group_id     *string
	flow_achievement_comment      *string
	flow_achievement_num_subjects *string
	flow_achievement_num_units    *string
	clearedFields                 map[string]struct{}
	parent                        *int
	clearedparent                 bool
	done                          bool
	oldValue                      func(context.Context) (*FlowAchievement, error)
	predicates                    []predicate.FlowAchievement
}

var _ ent.Mutation = (*FlowAchievementMutation)(nil)

// flowachievementOption allows management of the mutation configuration using functional options.
type flowachievementOption func(*FlowAchievementMutation)

// newFlowAchievementMutation creates new mutation for the FlowAchievement entity.
func newFlowAchievementMutation(c config, op Op, opts ...flowachievementOption) *FlowAchievementMutation {
	m := &FlowAchievementMutation{
		config:        c,
		op:            op,
		typ:           TypeFlowAchievement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFlowAchievementID sets the ID field of the mutation.
func withFlowAchievementID(id int) flowachievementOption {
	return func(m *FlowAchievementMutation) {
		var (
			err   error
			once  sync.Once
			value *FlowAchievement
		)
		m.oldValue = func(ctx context.Context) (*FlowAchievement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FlowAchievement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFlowAchievement sets the old FlowAchievement of the mutation.
func withFlowAchievement(node *FlowAchievement) flowachievementOption {
	return func(m *FlowAchievementMutation) {
		m.oldValue = func(context.Context) (*FlowAchievement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FlowAchievementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FlowAchievementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FlowAchievementMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FlowAchievementMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FlowAchievement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFlowAchievementGroupID sets the "flow_achievement_group_id" field.
func (m *FlowAchievementMutation) SetFlowAchievementGroupID(s string) {
	m.flow_achievement_group_id = &s
}

// FlowAchievementGroupID returns the value of the "flow_achievement_group_id" field in the mutation.
func (m *FlowAchievementMutation) FlowAchievementGroupID() (r string, exists bool) {
	v := m.flow_achievement_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowAchievementGroupID returns the old "flow_achievement_group_id" field's value of the FlowAchievement entity.
// If the FlowAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowAchievementMutation) OldFlowAchievementGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowAchievementGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowAchievementGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowAchievementGroupID: %w", err)
	}
	return oldValue.FlowAchievementGroupID, nil
}

// ResetFlowAchievementGroupID resets all changes to the "flow_achievement_group_id" field.
func (m *FlowAchievementMutation) ResetFlowAchievementGroupID() {
	m.flow_achievement_group_id = nil
}

// SetFlowAchievementComment sets the "flow_achievement_comment" field.
func (m *FlowAchievementMutation) SetFlowAchievementComment(s string) {
	m.flow_achievement_comment = &s
}

// FlowAchievementComment returns the value of the "flow_achievement_comment" field in the mutation.
func (m *FlowAchievementMutation) FlowAchievementComment() (r string, exists bool) {
	v := m.flow_achievement_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowAchievementComment returns the old "flow_achievement_comment" field's value of the FlowAchievement entity.
// If the FlowAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowAchievementMutation) OldFlowAchievementComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowAchievementComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowAchievementComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowAchievementComment: %w", err)
	}
	return oldValue.FlowAchievementComment, nil
}

// ResetFlowAchievementComment resets all changes to the "flow_achievement_comment" field.
func (m *FlowAchievementMutation) ResetFlowAchievementComment() {
	m.flow_achievement_comment = nil
}

// SetFlowAchievementNumSubjects sets the "flow_achievement_num_subjects" field.
func (m *FlowAchievementMutation) SetFlowAchievementNumSubjects(s string) {
	m.flow_achievement_num_subjects = &s
}

// FlowAchievementNumSubjects returns the value of the "flow_achievement_num_subjects" field in the mutation.
func (m *FlowAchievementMutation) FlowAchievementNumSubjects() (r string, exists bool) {
	v := m.flow_achievement_num_subjects
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowAchievementNumSubjects returns the old "flow_achievement_num_subjects" field's value of the FlowAchievement entity.
// If the FlowAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowAchievementMutation) OldFlowAchievementNumSubjects(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowAchievementNumSubjects is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowAchievementNumSubjects requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowAchievementNumSubjects: %w", err)
	}
	return oldValue.FlowAchievementNumSubjects, nil
}

// ResetFlowAchievementNumSubjects resets all changes to the "flow_achievement_num_subjects" field.
func (m *FlowAchievementMutation) ResetFlowAchievementNumSubjects() {
	m.flow_achievement_num_subjects = nil
}

// SetFlowAchievementNumUnits sets the "flow_achievement_num_units" field.
func (m *FlowAchievementMutation) SetFlowAchievementNumUnits(s string) {
	m.flow_achievement_num_units = &s
}

// FlowAchievementNumUnits returns the value of the "flow_achievement_num_units" field in the mutation.
func (m *FlowAchievementMutation) FlowAchievementNumUnits() (r string, exists bool) {
	v := m.flow_achievement_num_units
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowAchievementNumUnits returns the old "flow_achievement_num_units" field's value of the FlowAchievement entity.
// If the FlowAchievement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowAchievementMutation) OldFlowAchievementNumUnits(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowAchievementNumUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowAchievementNumUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowAchievementNumUnits: %w", err)
	}
	return oldValue.FlowAchievementNumUnits, nil
}

// ResetFlowAchievementNumUnits resets all changes to the "flow_achievement_num_units" field.
func (m *FlowAchievementMutation) ResetFlowAchievementNumUnits() {
	m.flow_achievement_num_units = nil
}

// SetParentID sets the "parent" edge to the FlowMilestone entity by id.
func (m *FlowAchievementMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the FlowMilestone entity.
func (m *FlowAchievementMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the FlowMilestone entity was cleared.
func (m *FlowAchievementMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *FlowAchievementMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *FlowAchievementMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *FlowAchievementMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// Where appends a list predicates to the FlowAchievementMutation builder.
func (m *FlowAchievementMutation) Where(ps ...predicate.FlowAchievement) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FlowAchievementMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FlowAchievement).
func (m *FlowAchievementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FlowAchievementMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.flow_achievement_group_id != nil {
		fields = append(fields, flowachievement.FieldFlowAchievementGroupID)
	}
	if m.flow_achievement_comment != nil {
		fields = append(fields, flowachievement.FieldFlowAchievementComment)
	}
	if m.flow_achievement_num_subjects != nil {
		fields = append(fields, flowachievement.FieldFlowAchievementNumSubjects)
	}
	if m.flow_achievement_num_units != nil {
		fields = append(fields, flowachievement.FieldFlowAchievementNumUnits)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FlowAchievementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flowachievement.FieldFlowAchievementGroupID:
		return m.FlowAchievementGroupID()
	case flowachievement.FieldFlowAchievementComment:
		return m.FlowAchievementComment()
	case flowachievement.FieldFlowAchievementNumSubjects:
		return m.FlowAchievementNumSubjects()
	case flowachievement.FieldFlowAchievementNumUnits:
		return m.FlowAchievementNumUnits()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FlowAchievementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flowachievement.FieldFlowAchievementGroupID:
		return m.OldFlowAchievementGroupID(ctx)
	case flowachievement.FieldFlowAchievementComment:
		return m.OldFlowAchievementComment(ctx)
	case flowachievement.FieldFlowAchievementNumSubjects:
		return m.OldFlowAchievementNumSubjects(ctx)
	case flowachievement.FieldFlowAchievementNumUnits:
		return m.OldFlowAchievementNumUnits(ctx)
	}
	return nil, fmt.Errorf("unknown FlowAchievement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlowAchievementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flowachievement.FieldFlowAchievementGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowAchievementGroupID(v)
		return nil
	case flowachievement.FieldFlowAchievementComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowAchievementComment(v)
		return nil
	case flowachievement.FieldFlowAchievementNumSubjects:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowAchievementNumSubjects(v)
		return nil
	case flowachievement.FieldFlowAchievementNumUnits:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowAchievementNumUnits(v)
		return nil
	}
	return fmt.Errorf("unknown FlowAchievement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FlowAchievementMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FlowAchievementMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlowAchievementMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FlowAchievement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FlowAchievementMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FlowAchievementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FlowAchievementMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FlowAchievement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FlowAchievementMutation) ResetField(name string) error {
	switch name {
	case flowachievement.FieldFlowAchievementGroupID:
		m.ResetFlowAchievementGroupID()
		return nil
	case flowachievement.FieldFlowAchievementComment:
		m.ResetFlowAchievementComment()
		return nil
	case flowachievement.FieldFlowAchievementNumSubjects:
		m.ResetFlowAchievementNumSubjects()
		return nil
	case flowachievement.FieldFlowAchievementNumUnits:
		m.ResetFlowAchievementNumUnits()
		return nil
	}
	return fmt.Errorf("unknown FlowAchievement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FlowAchievementMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.parent != nil {
		edges = append(edges, flowachievement.EdgeParent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FlowAchievementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case flowachievement.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FlowAchievementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FlowAchievementMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FlowAchievementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparent {
		edges = append(edges, flowachievement.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FlowAchievementMutation) EdgeCleared(name string) bool {
	switch name {
	case flowachievement.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FlowAchievementMutation) ClearEdge(name string) error {
	switch name {
	case flowachievement.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown FlowAchievement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FlowAchievementMutation) ResetEdge(name string) error {
	switch name {
	case flowachievement.EdgeParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown FlowAchievement edge %s", name)
}

// FlowDropWithdrawMutation represents an operation that mutates the FlowDropWithdraw nodes in the graph.
type FlowDropWithdrawMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	flow_drop_withdraw_type    *string
	flow_drop_withdraw_comment *string
	clearedFields              map[string]struct{}
	parent                     *int
	clearedparent              bool
	flow_reason_list           map[int]struct{}
	removedflow_reason_list    map[int]struct{}
	clearedflow_reason_list    bool
	done                       bool
	oldValue                   func(context.Context) (*FlowDropWithdraw, error)
	predicates                 []predicate.FlowDropWithdraw
}

var _ ent.Mutation = (*FlowDropWithdrawMutation)(nil)

// flowdropwithdrawOption allows management of the mutation configuration using functional options.
type flowdropwithdrawOption func(*FlowDropWithdrawMutation)

// newFlowDropWithdrawMutation creates new mutation for the FlowDropWithdraw entity.
func newFlowDropWithdrawMutation(c config, op Op, opts ...flowdropwithdrawOption) *FlowDropWithdrawMutation {
	m := &FlowDropWithdrawMutation{
		config:        c,
		op:            op,
		typ:           TypeFlowDropWithdraw,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFlowDropWithdrawID sets the ID field of the mutation.
func withFlowDropWithdrawID(id int) flowdropwithdrawOption {
	return func(m *FlowDropWithdrawMutation) {
		var (
			err   error
			once  sync.Once
			value *FlowDropWithdraw
		)
		m.oldValue = func(ctx context.Context) (*FlowDropWithdraw, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FlowDropWithdraw.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFlowDropWithdraw sets the old FlowDropWithdraw of the mutation.
func withFlowDropWithdraw(node *FlowDropWithdraw) flowdropwithdrawOption {
	return func(m *FlowDropWithdrawMutation) {
		m.oldValue = func(context.Context) (*FlowDropWithdraw, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FlowDropWithdrawMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FlowDropWithdrawMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FlowDropWithdrawMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FlowDropWithdrawMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FlowDropWithdraw.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFlowDropWithdrawType sets the "flow_drop_withdraw_type" field.
func (m *FlowDropWithdrawMutation) SetFlowDropWithdrawType(s string) {
	m.flow_drop_withdraw_type = &s
}

// FlowDropWithdrawType returns the value of the "flow_drop_withdraw_type" field in the mutation.
func (m *FlowDropWithdrawMutation) FlowDropWithdrawType() (r string, exists bool) {
	v := m.flow_drop_withdraw_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowDropWithdrawType returns the old "flow_drop_withdraw_type" field's value of the FlowDropWithdraw entity.
// If the FlowDropWithdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowDropWithdrawMutation) OldFlowDropWithdrawType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowDropWithdrawType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowDropWithdrawType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowDropWithdrawType: %w", err)
	}
	return oldValue.FlowDropWithdrawType, nil
}

// ResetFlowDropWithdrawType resets all changes to the "flow_drop_withdraw_type" field.
func (m *FlowDropWithdrawMutation) ResetFlowDropWithdrawType() {
	m.flow_drop_withdraw_type = nil
}

// SetFlowDropWithdrawComment sets the "flow_drop_withdraw_comment" field.
func (m *FlowDropWithdrawMutation) SetFlowDropWithdrawComment(s string) {
	m.flow_drop_withdraw_comment = &s
}

// FlowDropWithdrawComment returns the value of the "flow_drop_withdraw_comment" field in the mutation.
func (m *FlowDropWithdrawMutation) FlowDropWithdrawComment() (r string, exists bool) {
	v := m.flow_drop_withdraw_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowDropWithdrawComment returns the old "flow_drop_withdraw_comment" field's value of the FlowDropWithdraw entity.
// If the FlowDropWithdraw object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowDropWithdrawMutation) OldFlowDropWithdrawComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowDropWithdrawComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowDropWithdrawComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowDropWithdrawComment: %w", err)
	}
	return oldValue.FlowDropWithdrawComment, nil
}

// ResetFlowDropWithdrawComment resets all changes to the "flow_drop_withdraw_comment" field.
func (m *FlowDropWithdrawMutation) ResetFlowDropWithdrawComment() {
	m.flow_drop_withdraw_comment = nil
}

// SetParentID sets the "parent" edge to the FlowPeriod entity by id.
func (m *FlowDropWithdrawMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the FlowPeriod entity.
func (m *FlowDropWithdrawMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the FlowPeriod entity was cleared.
func (m *FlowDropWithdrawMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *FlowDropWithdrawMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *FlowDropWithdrawMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *FlowDropWithdrawMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddFlowReasonListIDs adds the "flow_reason_list" edge to the FlowReason entity by ids.
func (m *FlowDropWithdrawMutation) AddFlowReasonListIDs(ids ...int) {
	if m.flow_reason_list == nil {
		m.flow_reason_list = make(map[int]struct{})
	}
	for i := range ids {
		m.flow_reason_list[ids[i]] = struct{}{}
	}
}

// ClearFlowReasonList clears the "flow_reason_list" edge to the FlowReason entity.
func (m *FlowDropWithdrawMutation) ClearFlowReasonList() {
	m.clearedflow_reason_list = true
}

// FlowReasonListCleared reports if the "flow_reason_list" edge to the FlowReason entity was cleared.
func (m *FlowDropWithdrawMutation) FlowReasonListCleared() bool {
	return m.clearedflow_reason_list
}

// RemoveFlowReasonListIDs removes the "flow_reason_list" edge to the FlowReason entity by IDs.
func (m *FlowDropWithdrawMutation) RemoveFlowReasonListIDs(ids ...int) {
	if m.removedflow_reason_list == nil {
		m.removedflow_reason_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.flow_reason_list, ids[i])
		m.removedflow_reason_list[ids[i]] = struct{}{}
	}
}

// RemovedFlowReasonList returns the removed IDs of the "flow_reason_list" edge to the FlowReason entity.
func (m *FlowDropWithdrawMutation) RemovedFlowReasonListIDs() (ids []int) {
	for id := range m.removedflow_reason_list {
		ids = append(ids, id)
	}
	return
}

// FlowReasonListIDs returns the "flow_reason_list" edge IDs in the mutation.
func (m *FlowDropWithdrawMutation) FlowReasonListIDs() (ids []int) {
	for id := range m.flow_reason_list {
		ids = append(ids, id)
	}
	return
}

// ResetFlowReasonList resets all changes to the "flow_reason_list" edge.
func (m *FlowDropWithdrawMutation) ResetFlowReasonList() {
	m.flow_reason_list = nil
	m.clearedflow_reason_list = false
	m.removedflow_reason_list = nil
}

// Where appends a list predicates to the FlowDropWithdrawMutation builder.
func (m *FlowDropWithdrawMutation) Where(ps ...predicate.FlowDropWithdraw) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FlowDropWithdrawMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FlowDropWithdraw).
func (m *FlowDropWithdrawMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FlowDropWithdrawMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.flow_drop_withdraw_type != nil {
		fields = append(fields, flowdropwithdraw.FieldFlowDropWithdrawType)
	}
	if m.flow_drop_withdraw_comment != nil {
		fields = append(fields, flowdropwithdraw.FieldFlowDropWithdrawComment)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FlowDropWithdrawMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flowdropwithdraw.FieldFlowDropWithdrawType:
		return m.FlowDropWithdrawType()
	case flowdropwithdraw.FieldFlowDropWithdrawComment:
		return m.FlowDropWithdrawComment()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FlowDropWithdrawMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flowdropwithdraw.FieldFlowDropWithdrawType:
		return m.OldFlowDropWithdrawType(ctx)
	case flowdropwithdraw.FieldFlowDropWithdrawComment:
		return m.OldFlowDropWithdrawComment(ctx)
	}
	return nil, fmt.Errorf("unknown FlowDropWithdraw field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlowDropWithdrawMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flowdropwithdraw.FieldFlowDropWithdrawType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowDropWithdrawType(v)
		return nil
	case flowdropwithdraw.FieldFlowDropWithdrawComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowDropWithdrawComment(v)
		return nil
	}
	return fmt.Errorf("unknown FlowDropWithdraw field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FlowDropWithdrawMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FlowDropWithdrawMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlowDropWithdrawMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FlowDropWithdraw numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FlowDropWithdrawMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FlowDropWithdrawMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FlowDropWithdrawMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FlowDropWithdraw nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FlowDropWithdrawMutation) ResetField(name string) error {
	switch name {
	case flowdropwithdraw.FieldFlowDropWithdrawType:
		m.ResetFlowDropWithdrawType()
		return nil
	case flowdropwithdraw.FieldFlowDropWithdrawComment:
		m.ResetFlowDropWithdrawComment()
		return nil
	}
	return fmt.Errorf("unknown FlowDropWithdraw field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FlowDropWithdrawMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.parent != nil {
		edges = append(edges, flowdropwithdraw.EdgeParent)
	}
	if m.flow_reason_list != nil {
		edges = append(edges, flowdropwithdraw.EdgeFlowReasonList)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FlowDropWithdrawMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case flowdropwithdraw.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case flowdropwithdraw.EdgeFlowReasonList:
		ids := make([]ent.Value, 0, len(m.flow_reason_list))
		for id := range m.flow_reason_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FlowDropWithdrawMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedflow_reason_list != nil {
		edges = append(edges, flowdropwithdraw.EdgeFlowReasonList)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FlowDropWithdrawMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case flowdropwithdraw.EdgeFlowReasonList:
		ids := make([]ent.Value, 0, len(m.removedflow_reason_list))
		for id := range m.removedflow_reason_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FlowDropWithdrawMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedparent {
		edges = append(edges, flowdropwithdraw.EdgeParent)
	}
	if m.clearedflow_reason_list {
		edges = append(edges, flowdropwithdraw.EdgeFlowReasonList)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FlowDropWithdrawMutation) EdgeCleared(name string) bool {
	switch name {
	case flowdropwithdraw.EdgeParent:
		return m.clearedparent
	case flowdropwithdraw.EdgeFlowReasonList:
		return m.clearedflow_reason_list
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FlowDropWithdrawMutation) ClearEdge(name string) error {
	switch name {
	case flowdropwithdraw.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown FlowDropWithdraw unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FlowDropWithdrawMutation) ResetEdge(name string) error {
	switch name {
	case flowdropwithdraw.EdgeParent:
		m.ResetParent()
		return nil
	case flowdropwithdraw.EdgeFlowReasonList:
		m.ResetFlowReasonList()
		return nil
	}
	return fmt.Errorf("unknown FlowDropWithdraw edge %s", name)
}

// FlowGroupMutation represents an operation that mutates the FlowGroup nodes in the graph.
type FlowGroupMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	flow_group_id          *string
	flow_group_title       *string
	flow_group_description *string
	clearedFields          map[string]struct{}
	parent                 *int
	clearedparent          bool
	done                   bool
	oldValue               func(context.Context) (*FlowGroup, error)
	predicates             []predicate.FlowGroup
}

var _ ent.Mutation = (*FlowGroupMutation)(nil)

// flowgroupOption allows management of the mutation configuration using functional options.
type flowgroupOption func(*FlowGroupMutation)

// newFlowGroupMutation creates new mutation for the FlowGroup entity.
func newFlowGroupMutation(c config, op Op, opts ...flowgroupOption) *FlowGroupMutation {
	m := &FlowGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeFlowGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFlowGroupID sets the ID field of the mutation.
func withFlowGroupID(id int) flowgroupOption {
	return func(m *FlowGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *FlowGroup
		)
		m.oldValue = func(ctx context.Context) (*FlowGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FlowGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFlowGroup sets the old FlowGroup of the mutation.
func withFlowGroup(node *FlowGroup) flowgroupOption {
	return func(m *FlowGroupMutation) {
		m.oldValue = func(context.Context) (*FlowGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FlowGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FlowGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FlowGroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FlowGroupMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FlowGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFlowGroupID sets the "flow_group_id" field.
func (m *FlowGroupMutation) SetFlowGroupID(s string) {
	m.flow_group_id = &s
}

// FlowGroupID returns the value of the "flow_group_id" field in the mutation.
func (m *FlowGroupMutation) FlowGroupID() (r string, exists bool) {
	v := m.flow_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowGroupID returns the old "flow_group_id" field's value of the FlowGroup entity.
// If the FlowGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowGroupMutation) OldFlowGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowGroupID: %w", err)
	}
	return oldValue.FlowGroupID, nil
}

// ResetFlowGroupID resets all changes to the "flow_group_id" field.
func (m *FlowGroupMutation) ResetFlowGroupID() {
	m.flow_group_id = nil
}

// SetFlowGroupTitle sets the "flow_group_title" field.
func (m *FlowGroupMutation) SetFlowGroupTitle(s string) {
	m.flow_group_title = &s
}

// FlowGroupTitle returns the value of the "flow_group_title" field in the mutation.
func (m *FlowGroupMutation) FlowGroupTitle() (r string, exists bool) {
	v := m.flow_group_title
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowGroupTitle returns the old "flow_group_title" field's value of the FlowGroup entity.
// If the FlowGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowGroupMutation) OldFlowGroupTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowGroupTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowGroupTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowGroupTitle: %w", err)
	}
	return oldValue.FlowGroupTitle, nil
}

// ResetFlowGroupTitle resets all changes to the "flow_group_title" field.
func (m *FlowGroupMutation) ResetFlowGroupTitle() {
	m.flow_group_title = nil
}

// SetFlowGroupDescription sets the "flow_group_description" field.
func (m *FlowGroupMutation) SetFlowGroupDescription(s string) {
	m.flow_group_description = &s
}

// FlowGroupDescription returns the value of the "flow_group_description" field in the mutation.
func (m *FlowGroupMutation) FlowGroupDescription() (r string, exists bool) {
	v := m.flow_group_description
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowGroupDescription returns the old "flow_group_description" field's value of the FlowGroup entity.
// If the FlowGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowGroupMutation) OldFlowGroupDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowGroupDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowGroupDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowGroupDescription: %w", err)
	}
	return oldValue.FlowGroupDescription, nil
}

// ResetFlowGroupDescription resets all changes to the "flow_group_description" field.
func (m *FlowGroupMutation) ResetFlowGroupDescription() {
	m.flow_group_description = nil
}

// SetParentID sets the "parent" edge to the ParticipantFlowModule entity by id.
func (m *FlowGroupMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ParticipantFlowModule entity.
func (m *FlowGroupMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ParticipantFlowModule entity was cleared.
func (m *FlowGroupMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *FlowGroupMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *FlowGroupMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *FlowGroupMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// Where appends a list predicates to the FlowGroupMutation builder.
func (m *FlowGroupMutation) Where(ps ...predicate.FlowGroup) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FlowGroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FlowGroup).
func (m *FlowGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FlowGroupMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.flow_group_id != nil {
		fields = append(fields, flowgroup.FieldFlowGroupID)
	}
	if m.flow_group_title != nil {
		fields = append(fields, flowgroup.FieldFlowGroupTitle)
	}
	if m.flow_group_description != nil {
		fields = append(fields, flowgroup.FieldFlowGroupDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FlowGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flowgroup.FieldFlowGroupID:
		return m.FlowGroupID()
	case flowgroup.FieldFlowGroupTitle:
		return m.FlowGroupTitle()
	case flowgroup.FieldFlowGroupDescription:
		return m.FlowGroupDescription()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FlowGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flowgroup.FieldFlowGroupID:
		return m.OldFlowGroupID(ctx)
	case flowgroup.FieldFlowGroupTitle:
		return m.OldFlowGroupTitle(ctx)
	case flowgroup.FieldFlowGroupDescription:
		return m.OldFlowGroupDescription(ctx)
	}
	return nil, fmt.Errorf("unknown FlowGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlowGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flowgroup.FieldFlowGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowGroupID(v)
		return nil
	case flowgroup.FieldFlowGroupTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowGroupTitle(v)
		return nil
	case flowgroup.FieldFlowGroupDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowGroupDescription(v)
		return nil
	}
	return fmt.Errorf("unknown FlowGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FlowGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FlowGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlowGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FlowGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FlowGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FlowGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FlowGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FlowGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FlowGroupMutation) ResetField(name string) error {
	switch name {
	case flowgroup.FieldFlowGroupID:
		m.ResetFlowGroupID()
		return nil
	case flowgroup.FieldFlowGroupTitle:
		m.ResetFlowGroupTitle()
		return nil
	case flowgroup.FieldFlowGroupDescription:
		m.ResetFlowGroupDescription()
		return nil
	}
	return fmt.Errorf("unknown FlowGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FlowGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.parent != nil {
		edges = append(edges, flowgroup.EdgeParent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FlowGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case flowgroup.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FlowGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FlowGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FlowGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparent {
		edges = append(edges, flowgroup.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FlowGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case flowgroup.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FlowGroupMutation) ClearEdge(name string) error {
	switch name {
	case flowgroup.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown FlowGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FlowGroupMutation) ResetEdge(name string) error {
	switch name {
	case flowgroup.EdgeParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown FlowGroup edge %s", name)
}

// FlowMilestoneMutation represents an operation that mutates the FlowMilestone nodes in the graph.
type FlowMilestoneMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	flow_milestone_type          *string
	flow_milestone_comment       *string
	clearedFields                map[string]struct{}
	parent                       *int
	clearedparent                bool
	flow_achievement_list        map[int]struct{}
	removedflow_achievement_list map[int]struct{}
	clearedflow_achievement_list bool
	done                         bool
	oldValue                     func(context.Context) (*FlowMilestone, error)
	predicates                   []predicate.FlowMilestone
}

var _ ent.Mutation = (*FlowMilestoneMutation)(nil)

// flowmilestoneOption allows management of the mutation configuration using functional options.
type flowmilestoneOption func(*FlowMilestoneMutation)

// newFlowMilestoneMutation creates new mutation for the FlowMilestone entity.
func newFlowMilestoneMutation(c config, op Op, opts ...flowmilestoneOption) *FlowMilestoneMutation {
	m := &FlowMilestoneMutation{
		config:        c,
		op:            op,
		typ:           TypeFlowMilestone,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFlowMilestoneID sets the ID field of the mutation.
func withFlowMilestoneID(id int) flowmilestoneOption {
	return func(m *FlowMilestoneMutation) {
		var (
			err   error
			once  sync.Once
			value *FlowMilestone
		)
		m.oldValue = func(ctx context.Context) (*FlowMilestone, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FlowMilestone.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFlowMilestone sets the old FlowMilestone of the mutation.
func withFlowMilestone(node *FlowMilestone) flowmilestoneOption {
	return func(m *FlowMilestoneMutation) {
		m.oldValue = func(context.Context) (*FlowMilestone, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FlowMilestoneMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FlowMilestoneMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FlowMilestoneMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FlowMilestoneMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FlowMilestone.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFlowMilestoneType sets the "flow_milestone_type" field.
func (m *FlowMilestoneMutation) SetFlowMilestoneType(s string) {
	m.flow_milestone_type = &s
}

// FlowMilestoneType returns the value of the "flow_milestone_type" field in the mutation.
func (m *FlowMilestoneMutation) FlowMilestoneType() (r string, exists bool) {
	v := m.flow_milestone_type
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowMilestoneType returns the old "flow_milestone_type" field's value of the FlowMilestone entity.
// If the FlowMilestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowMilestoneMutation) OldFlowMilestoneType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowMilestoneType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowMilestoneType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowMilestoneType: %w", err)
	}
	return oldValue.FlowMilestoneType, nil
}

// ResetFlowMilestoneType resets all changes to the "flow_milestone_type" field.
func (m *FlowMilestoneMutation) ResetFlowMilestoneType() {
	m.flow_milestone_type = nil
}

// SetFlowMilestoneComment sets the "flow_milestone_comment" field.
func (m *FlowMilestoneMutation) SetFlowMilestoneComment(s string) {
	m.flow_milestone_comment = &s
}

// FlowMilestoneComment returns the value of the "flow_milestone_comment" field in the mutation.
func (m *FlowMilestoneMutation) FlowMilestoneComment() (r string, exists bool) {
	v := m.flow_milestone_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowMilestoneComment returns the old "flow_milestone_comment" field's value of the FlowMilestone entity.
// If the FlowMilestone object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowMilestoneMutation) OldFlowMilestoneComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowMilestoneComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowMilestoneComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowMilestoneComment: %w", err)
	}
	return oldValue.FlowMilestoneComment, nil
}

// ResetFlowMilestoneComment resets all changes to the "flow_milestone_comment" field.
func (m *FlowMilestoneMutation) ResetFlowMilestoneComment() {
	m.flow_milestone_comment = nil
}

// SetParentID sets the "parent" edge to the FlowPeriod entity by id.
func (m *FlowMilestoneMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the FlowPeriod entity.
func (m *FlowMilestoneMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the FlowPeriod entity was cleared.
func (m *FlowMilestoneMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *FlowMilestoneMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *FlowMilestoneMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *FlowMilestoneMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddFlowAchievementListIDs adds the "flow_achievement_list" edge to the FlowAchievement entity by ids.
func (m *FlowMilestoneMutation) AddFlowAchievementListIDs(ids ...int) {
	if m.flow_achievement_list == nil {
		m.flow_achievement_list = make(map[int]struct{})
	}
	for i := range ids {
		m.flow_achievement_list[ids[i]] = struct{}{}
	}
}

// ClearFlowAchievementList clears the "flow_achievement_list" edge to the FlowAchievement entity.
func (m *FlowMilestoneMutation) ClearFlowAchievementList() {
	m.clearedflow_achievement_list = true
}

// FlowAchievementListCleared reports if the "flow_achievement_list" edge to the FlowAchievement entity was cleared.
func (m *FlowMilestoneMutation) FlowAchievementListCleared() bool {
	return m.clearedflow_achievement_list
}

// RemoveFlowAchievementListIDs removes the "flow_achievement_list" edge to the FlowAchievement entity by IDs.
func (m *FlowMilestoneMutation) RemoveFlowAchievementListIDs(ids ...int) {
	if m.removedflow_achievement_list == nil {
		m.removedflow_achievement_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.flow_achievement_list, ids[i])
		m.removedflow_achievement_list[ids[i]] = struct{}{}
	}
}

// RemovedFlowAchievementList returns the removed IDs of the "flow_achievement_list" edge to the FlowAchievement entity.
func (m *FlowMilestoneMutation) RemovedFlowAchievementListIDs() (ids []int) {
	for id := range m.removedflow_achievement_list {
		ids = append(ids, id)
	}
	return
}

// FlowAchievementListIDs returns the "flow_achievement_list" edge IDs in the mutation.
func (m *FlowMilestoneMutation) FlowAchievementListIDs() (ids []int) {
	for id := range m.flow_achievement_list {
		ids = append(ids, id)
	}
	return
}

// ResetFlowAchievementList resets all changes to the "flow_achievement_list" edge.
func (m *FlowMilestoneMutation) ResetFlowAchievementList() {
	m.flow_achievement_list = nil
	m.clearedflow_achievement_list = false
	m.removedflow_achievement_list = nil
}

// Where appends a list predicates to the FlowMilestoneMutation builder.
func (m *FlowMilestoneMutation) Where(ps ...predicate.FlowMilestone) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FlowMilestoneMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FlowMilestone).
func (m *FlowMilestoneMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FlowMilestoneMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.flow_milestone_type != nil {
		fields = append(fields, flowmilestone.FieldFlowMilestoneType)
	}
	if m.flow_milestone_comment != nil {
		fields = append(fields, flowmilestone.FieldFlowMilestoneComment)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FlowMilestoneMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flowmilestone.FieldFlowMilestoneType:
		return m.FlowMilestoneType()
	case flowmilestone.FieldFlowMilestoneComment:
		return m.FlowMilestoneComment()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FlowMilestoneMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flowmilestone.FieldFlowMilestoneType:
		return m.OldFlowMilestoneType(ctx)
	case flowmilestone.FieldFlowMilestoneComment:
		return m.OldFlowMilestoneComment(ctx)
	}
	return nil, fmt.Errorf("unknown FlowMilestone field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlowMilestoneMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flowmilestone.FieldFlowMilestoneType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowMilestoneType(v)
		return nil
	case flowmilestone.FieldFlowMilestoneComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowMilestoneComment(v)
		return nil
	}
	return fmt.Errorf("unknown FlowMilestone field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FlowMilestoneMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FlowMilestoneMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlowMilestoneMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FlowMilestone numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FlowMilestoneMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FlowMilestoneMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FlowMilestoneMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FlowMilestone nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FlowMilestoneMutation) ResetField(name string) error {
	switch name {
	case flowmilestone.FieldFlowMilestoneType:
		m.ResetFlowMilestoneType()
		return nil
	case flowmilestone.FieldFlowMilestoneComment:
		m.ResetFlowMilestoneComment()
		return nil
	}
	return fmt.Errorf("unknown FlowMilestone field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FlowMilestoneMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.parent != nil {
		edges = append(edges, flowmilestone.EdgeParent)
	}
	if m.flow_achievement_list != nil {
		edges = append(edges, flowmilestone.EdgeFlowAchievementList)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FlowMilestoneMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case flowmilestone.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case flowmilestone.EdgeFlowAchievementList:
		ids := make([]ent.Value, 0, len(m.flow_achievement_list))
		for id := range m.flow_achievement_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FlowMilestoneMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedflow_achievement_list != nil {
		edges = append(edges, flowmilestone.EdgeFlowAchievementList)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FlowMilestoneMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case flowmilestone.EdgeFlowAchievementList:
		ids := make([]ent.Value, 0, len(m.removedflow_achievement_list))
		for id := range m.removedflow_achievement_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FlowMilestoneMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedparent {
		edges = append(edges, flowmilestone.EdgeParent)
	}
	if m.clearedflow_achievement_list {
		edges = append(edges, flowmilestone.EdgeFlowAchievementList)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FlowMilestoneMutation) EdgeCleared(name string) bool {
	switch name {
	case flowmilestone.EdgeParent:
		return m.clearedparent
	case flowmilestone.EdgeFlowAchievementList:
		return m.clearedflow_achievement_list
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FlowMilestoneMutation) ClearEdge(name string) error {
	switch name {
	case flowmilestone.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown FlowMilestone unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FlowMilestoneMutation) ResetEdge(name string) error {
	switch name {
	case flowmilestone.EdgeParent:
		m.ResetParent()
		return nil
	case flowmilestone.EdgeFlowAchievementList:
		m.ResetFlowAchievementList()
		return nil
	}
	return fmt.Errorf("unknown FlowMilestone edge %s", name)
}

// FlowPeriodMutation represents an operation that mutates the FlowPeriod nodes in the graph.
type FlowPeriodMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	flow_period_title              *string
	clearedFields                  map[string]struct{}
	parent                         *int
	clearedparent                  bool
	flow_milestone_list            map[int]struct{}
	removedflow_milestone_list     map[int]struct{}
	clearedflow_milestone_list     bool
	flow_drop_withdraw_list        map[int]struct{}
	removedflow_drop_withdraw_list map[int]struct{}
	clearedflow_drop_withdraw_list bool
	done                           bool
	oldValue                       func(context.Context) (*FlowPeriod, error)
	predicates                     []predicate.FlowPeriod
}

var _ ent.Mutation = (*FlowPeriodMutation)(nil)

// flowperiodOption allows management of the mutation configuration using functional options.
type flowperiodOption func(*FlowPeriodMutation)

// newFlowPeriodMutation creates new mutation for the FlowPeriod entity.
func newFlowPeriodMutation(c config, op Op, opts ...flowperiodOption) *FlowPeriodMutation {
	m := &FlowPeriodMutation{
		config:        c,
		op:            op,
		typ:           TypeFlowPeriod,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFlowPeriodID sets the ID field of the mutation.
func withFlowPeriodID(id int) flowperiodOption {
	return func(m *FlowPeriodMutation) {
		var (
			err   error
			once  sync.Once
			value *FlowPeriod
		)
		m.oldValue = func(ctx context.Context) (*FlowPeriod, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FlowPeriod.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFlowPeriod sets the old FlowPeriod of the mutation.
func withFlowPeriod(node *FlowPeriod) flowperiodOption {
	return func(m *FlowPeriodMutation) {
		m.oldValue = func(context.Context) (*FlowPeriod, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FlowPeriodMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FlowPeriodMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FlowPeriodMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FlowPeriodMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FlowPeriod.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFlowPeriodTitle sets the "flow_period_title" field.
func (m *FlowPeriodMutation) SetFlowPeriodTitle(s string) {
	m.flow_period_title = &s
}

// FlowPeriodTitle returns the value of the "flow_period_title" field in the mutation.
func (m *FlowPeriodMutation) FlowPeriodTitle() (r string, exists bool) {
	v := m.flow_period_title
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowPeriodTitle returns the old "flow_period_title" field's value of the FlowPeriod entity.
// If the FlowPeriod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowPeriodMutation) OldFlowPeriodTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowPeriodTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowPeriodTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowPeriodTitle: %w", err)
	}
	return oldValue.FlowPeriodTitle, nil
}

// ResetFlowPeriodTitle resets all changes to the "flow_period_title" field.
func (m *FlowPeriodMutation) ResetFlowPeriodTitle() {
	m.flow_period_title = nil
}

// SetParentID sets the "parent" edge to the ParticipantFlowModule entity by id.
func (m *FlowPeriodMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ParticipantFlowModule entity.
func (m *FlowPeriodMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ParticipantFlowModule entity was cleared.
func (m *FlowPeriodMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *FlowPeriodMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *FlowPeriodMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *FlowPeriodMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddFlowMilestoneListIDs adds the "flow_milestone_list" edge to the FlowMilestone entity by ids.
func (m *FlowPeriodMutation) AddFlowMilestoneListIDs(ids ...int) {
	if m.flow_milestone_list == nil {
		m.flow_milestone_list = make(map[int]struct{})
	}
	for i := range ids {
		m.flow_milestone_list[ids[i]] = struct{}{}
	}
}

// ClearFlowMilestoneList clears the "flow_milestone_list" edge to the FlowMilestone entity.
func (m *FlowPeriodMutation) ClearFlowMilestoneList() {
	m.clearedflow_milestone_list = true
}

// FlowMilestoneListCleared reports if the "flow_milestone_list" edge to the FlowMilestone entity was cleared.
func (m *FlowPeriodMutation) FlowMilestoneListCleared() bool {
	return m.clearedflow_milestone_list
}

// RemoveFlowMilestoneListIDs removes the "flow_milestone_list" edge to the FlowMilestone entity by IDs.
func (m *FlowPeriodMutation) RemoveFlowMilestoneListIDs(ids ...int) {
	if m.removedflow_milestone_list == nil {
		m.removedflow_milestone_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.flow_milestone_list, ids[i])
		m.removedflow_milestone_list[ids[i]] = struct{}{}
	}
}

// RemovedFlowMilestoneList returns the removed IDs of the "flow_milestone_list" edge to the FlowMilestone entity.
func (m *FlowPeriodMutation) RemovedFlowMilestoneListIDs() (ids []int) {
	for id := range m.removedflow_milestone_list {
		ids = append(ids, id)
	}
	return
}

// FlowMilestoneListIDs returns the "flow_milestone_list" edge IDs in the mutation.
func (m *FlowPeriodMutation) FlowMilestoneListIDs() (ids []int) {
	for id := range m.flow_milestone_list {
		ids = append(ids, id)
	}
	return
}

// ResetFlowMilestoneList resets all changes to the "flow_milestone_list" edge.
func (m *FlowPeriodMutation) ResetFlowMilestoneList() {
	m.flow_milestone_list = nil
	m.clearedflow_milestone_list = false
	m.removedflow_milestone_list = nil
}

// AddFlowDropWithdrawListIDs adds the "flow_drop_withdraw_list" edge to the FlowDropWithdraw entity by ids.
func (m *FlowPeriodMutation) AddFlowDropWithdrawListIDs(ids ...int) {
	if m.flow_drop_withdraw_list == nil {
		m.flow_drop_withdraw_list = make(map[int]struct{})
	}
	for i := range ids {
		m.flow_drop_withdraw_list[ids[i]] = struct{}{}
	}
}

// ClearFlowDropWithdrawList clears the "flow_drop_withdraw_list" edge to the FlowDropWithdraw entity.
func (m *FlowPeriodMutation) ClearFlowDropWithdrawList() {
	m.clearedflow_drop_withdraw_list = true
}

// FlowDropWithdrawListCleared reports if the "flow_drop_withdraw_list" edge to the FlowDropWithdraw entity was cleared.
func (m *FlowPeriodMutation) FlowDropWithdrawListCleared() bool {
	return m.clearedflow_drop_withdraw_list
}

// RemoveFlowDropWithdrawListIDs removes the "flow_drop_withdraw_list" edge to the FlowDropWithdraw entity by IDs.
func (m *FlowPeriodMutation) RemoveFlowDropWithdrawListIDs(ids ...int) {
	if m.removedflow_drop_withdraw_list == nil {
		m.removedflow_drop_withdraw_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.flow_drop_withdraw_list, ids[i])
		m.removedflow_drop_withdraw_list[ids[i]] = struct{}{}
	}
}

// RemovedFlowDropWithdrawList returns the removed IDs of the "flow_drop_withdraw_list" edge to the FlowDropWithdraw entity.
func (m *FlowPeriodMutation) RemovedFlowDropWithdrawListIDs() (ids []int) {
	for id := range m.removedflow_drop_withdraw_list {
		ids = append(ids, id)
	}
	return
}

// FlowDropWithdrawListIDs returns the "flow_drop_withdraw_list" edge IDs in the mutation.
func (m *FlowPeriodMutation) FlowDropWithdrawListIDs() (ids []int) {
	for id := range m.flow_drop_withdraw_list {
		ids = append(ids, id)
	}
	return
}

// ResetFlowDropWithdrawList resets all changes to the "flow_drop_withdraw_list" edge.
func (m *FlowPeriodMutation) ResetFlowDropWithdrawList() {
	m.flow_drop_withdraw_list = nil
	m.clearedflow_drop_withdraw_list = false
	m.removedflow_drop_withdraw_list = nil
}

// Where appends a list predicates to the FlowPeriodMutation builder.
func (m *FlowPeriodMutation) Where(ps ...predicate.FlowPeriod) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FlowPeriodMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FlowPeriod).
func (m *FlowPeriodMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FlowPeriodMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.flow_period_title != nil {
		fields = append(fields, flowperiod.FieldFlowPeriodTitle)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FlowPeriodMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flowperiod.FieldFlowPeriodTitle:
		return m.FlowPeriodTitle()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FlowPeriodMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flowperiod.FieldFlowPeriodTitle:
		return m.OldFlowPeriodTitle(ctx)
	}
	return nil, fmt.Errorf("unknown FlowPeriod field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlowPeriodMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flowperiod.FieldFlowPeriodTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowPeriodTitle(v)
		return nil
	}
	return fmt.Errorf("unknown FlowPeriod field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FlowPeriodMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FlowPeriodMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlowPeriodMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FlowPeriod numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FlowPeriodMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FlowPeriodMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FlowPeriodMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FlowPeriod nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FlowPeriodMutation) ResetField(name string) error {
	switch name {
	case flowperiod.FieldFlowPeriodTitle:
		m.ResetFlowPeriodTitle()
		return nil
	}
	return fmt.Errorf("unknown FlowPeriod field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FlowPeriodMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent != nil {
		edges = append(edges, flowperiod.EdgeParent)
	}
	if m.flow_milestone_list != nil {
		edges = append(edges, flowperiod.EdgeFlowMilestoneList)
	}
	if m.flow_drop_withdraw_list != nil {
		edges = append(edges, flowperiod.EdgeFlowDropWithdrawList)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FlowPeriodMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case flowperiod.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case flowperiod.EdgeFlowMilestoneList:
		ids := make([]ent.Value, 0, len(m.flow_milestone_list))
		for id := range m.flow_milestone_list {
			ids = append(ids, id)
		}
		return ids
	case flowperiod.EdgeFlowDropWithdrawList:
		ids := make([]ent.Value, 0, len(m.flow_drop_withdraw_list))
		for id := range m.flow_drop_withdraw_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FlowPeriodMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedflow_milestone_list != nil {
		edges = append(edges, flowperiod.EdgeFlowMilestoneList)
	}
	if m.removedflow_drop_withdraw_list != nil {
		edges = append(edges, flowperiod.EdgeFlowDropWithdrawList)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FlowPeriodMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case flowperiod.EdgeFlowMilestoneList:
		ids := make([]ent.Value, 0, len(m.removedflow_milestone_list))
		for id := range m.removedflow_milestone_list {
			ids = append(ids, id)
		}
		return ids
	case flowperiod.EdgeFlowDropWithdrawList:
		ids := make([]ent.Value, 0, len(m.removedflow_drop_withdraw_list))
		for id := range m.removedflow_drop_withdraw_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FlowPeriodMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent {
		edges = append(edges, flowperiod.EdgeParent)
	}
	if m.clearedflow_milestone_list {
		edges = append(edges, flowperiod.EdgeFlowMilestoneList)
	}
	if m.clearedflow_drop_withdraw_list {
		edges = append(edges, flowperiod.EdgeFlowDropWithdrawList)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FlowPeriodMutation) EdgeCleared(name string) bool {
	switch name {
	case flowperiod.EdgeParent:
		return m.clearedparent
	case flowperiod.EdgeFlowMilestoneList:
		return m.clearedflow_milestone_list
	case flowperiod.EdgeFlowDropWithdrawList:
		return m.clearedflow_drop_withdraw_list
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FlowPeriodMutation) ClearEdge(name string) error {
	switch name {
	case flowperiod.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown FlowPeriod unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FlowPeriodMutation) ResetEdge(name string) error {
	switch name {
	case flowperiod.EdgeParent:
		m.ResetParent()
		return nil
	case flowperiod.EdgeFlowMilestoneList:
		m.ResetFlowMilestoneList()
		return nil
	case flowperiod.EdgeFlowDropWithdrawList:
		m.ResetFlowDropWithdrawList()
		return nil
	}
	return fmt.Errorf("unknown FlowPeriod edge %s", name)
}

// FlowReasonMutation represents an operation that mutates the FlowReason nodes in the graph.
type FlowReasonMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	flow_reason_group_id     *string
	flow_reason_comment      *string
	flow_reason_num_subjects *string
	flow_reason_num_units    *string
	clearedFields            map[string]struct{}
	parent                   *int
	clearedparent            bool
	done                     bool
	oldValue                 func(context.Context) (*FlowReason, error)
	predicates               []predicate.FlowReason
}

var _ ent.Mutation = (*FlowReasonMutation)(nil)

// flowreasonOption allows management of the mutation configuration using functional options.
type flowreasonOption func(*FlowReasonMutation)

// newFlowReasonMutation creates new mutation for the FlowReason entity.
func newFlowReasonMutation(c config, op Op, opts ...flowreasonOption) *FlowReasonMutation {
	m := &FlowReasonMutation{
		config:        c,
		op:            op,
		typ:           TypeFlowReason,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFlowReasonID sets the ID field of the mutation.
func withFlowReasonID(id int) flowreasonOption {
	return func(m *FlowReasonMutation) {
		var (
			err   error
			once  sync.Once
			value *FlowReason
		)
		m.oldValue = func(ctx context.Context) (*FlowReason, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FlowReason.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFlowReason sets the old FlowReason of the mutation.
func withFlowReason(node *FlowReason) flowreasonOption {
	return func(m *FlowReasonMutation) {
		m.oldValue = func(context.Context) (*FlowReason, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FlowReasonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FlowReasonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FlowReasonMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FlowReasonMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FlowReason.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFlowReasonGroupID sets the "flow_reason_group_id" field.
func (m *FlowReasonMutation) SetFlowReasonGroupID(s string) {
	m.flow_reason_group_id = &s
}

// FlowReasonGroupID returns the value of the "flow_reason_group_id" field in the mutation.
func (m *FlowReasonMutation) FlowReasonGroupID() (r string, exists bool) {
	v := m.flow_reason_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowReasonGroupID returns the old "flow_reason_group_id" field's value of the FlowReason entity.
// If the FlowReason object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowReasonMutation) OldFlowReasonGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowReasonGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowReasonGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowReasonGroupID: %w", err)
	}
	return oldValue.FlowReasonGroupID, nil
}

// ResetFlowReasonGroupID resets all changes to the "flow_reason_group_id" field.
func (m *FlowReasonMutation) ResetFlowReasonGroupID() {
	m.flow_reason_group_id = nil
}

// SetFlowReasonComment sets the "flow_reason_comment" field.
func (m *FlowReasonMutation) SetFlowReasonComment(s string) {
	m.flow_reason_comment = &s
}

// FlowReasonComment returns the value of the "flow_reason_comment" field in the mutation.
func (m *FlowReasonMutation) FlowReasonComment() (r string, exists bool) {
	v := m.flow_reason_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowReasonComment returns the old "flow_reason_comment" field's value of the FlowReason entity.
// If the FlowReason object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowReasonMutation) OldFlowReasonComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowReasonComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowReasonComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowReasonComment: %w", err)
	}
	return oldValue.FlowReasonComment, nil
}

// ResetFlowReasonComment resets all changes to the "flow_reason_comment" field.
func (m *FlowReasonMutation) ResetFlowReasonComment() {
	m.flow_reason_comment = nil
}

// SetFlowReasonNumSubjects sets the "flow_reason_num_subjects" field.
func (m *FlowReasonMutation) SetFlowReasonNumSubjects(s string) {
	m.flow_reason_num_subjects = &s
}

// FlowReasonNumSubjects returns the value of the "flow_reason_num_subjects" field in the mutation.
func (m *FlowReasonMutation) FlowReasonNumSubjects() (r string, exists bool) {
	v := m.flow_reason_num_subjects
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowReasonNumSubjects returns the old "flow_reason_num_subjects" field's value of the FlowReason entity.
// If the FlowReason object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowReasonMutation) OldFlowReasonNumSubjects(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowReasonNumSubjects is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowReasonNumSubjects requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowReasonNumSubjects: %w", err)
	}
	return oldValue.FlowReasonNumSubjects, nil
}

// ResetFlowReasonNumSubjects resets all changes to the "flow_reason_num_subjects" field.
func (m *FlowReasonMutation) ResetFlowReasonNumSubjects() {
	m.flow_reason_num_subjects = nil
}

// SetFlowReasonNumUnits sets the "flow_reason_num_units" field.
func (m *FlowReasonMutation) SetFlowReasonNumUnits(s string) {
	m.flow_reason_num_units = &s
}

// FlowReasonNumUnits returns the value of the "flow_reason_num_units" field in the mutation.
func (m *FlowReasonMutation) FlowReasonNumUnits() (r string, exists bool) {
	v := m.flow_reason_num_units
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowReasonNumUnits returns the old "flow_reason_num_units" field's value of the FlowReason entity.
// If the FlowReason object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FlowReasonMutation) OldFlowReasonNumUnits(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowReasonNumUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowReasonNumUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowReasonNumUnits: %w", err)
	}
	return oldValue.FlowReasonNumUnits, nil
}

// ResetFlowReasonNumUnits resets all changes to the "flow_reason_num_units" field.
func (m *FlowReasonMutation) ResetFlowReasonNumUnits() {
	m.flow_reason_num_units = nil
}

// SetParentID sets the "parent" edge to the FlowDropWithdraw entity by id.
func (m *FlowReasonMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the FlowDropWithdraw entity.
func (m *FlowReasonMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the FlowDropWithdraw entity was cleared.
func (m *FlowReasonMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *FlowReasonMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *FlowReasonMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *FlowReasonMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// Where appends a list predicates to the FlowReasonMutation builder.
func (m *FlowReasonMutation) Where(ps ...predicate.FlowReason) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *FlowReasonMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (FlowReason).
func (m *FlowReasonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FlowReasonMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.flow_reason_group_id != nil {
		fields = append(fields, flowreason.FieldFlowReasonGroupID)
	}
	if m.flow_reason_comment != nil {
		fields = append(fields, flowreason.FieldFlowReasonComment)
	}
	if m.flow_reason_num_subjects != nil {
		fields = append(fields, flowreason.FieldFlowReasonNumSubjects)
	}
	if m.flow_reason_num_units != nil {
		fields = append(fields, flowreason.FieldFlowReasonNumUnits)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FlowReasonMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case flowreason.FieldFlowReasonGroupID:
		return m.FlowReasonGroupID()
	case flowreason.FieldFlowReasonComment:
		return m.FlowReasonComment()
	case flowreason.FieldFlowReasonNumSubjects:
		return m.FlowReasonNumSubjects()
	case flowreason.FieldFlowReasonNumUnits:
		return m.FlowReasonNumUnits()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FlowReasonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case flowreason.FieldFlowReasonGroupID:
		return m.OldFlowReasonGroupID(ctx)
	case flowreason.FieldFlowReasonComment:
		return m.OldFlowReasonComment(ctx)
	case flowreason.FieldFlowReasonNumSubjects:
		return m.OldFlowReasonNumSubjects(ctx)
	case flowreason.FieldFlowReasonNumUnits:
		return m.OldFlowReasonNumUnits(ctx)
	}
	return nil, fmt.Errorf("unknown FlowReason field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlowReasonMutation) SetField(name string, value ent.Value) error {
	switch name {
	case flowreason.FieldFlowReasonGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowReasonGroupID(v)
		return nil
	case flowreason.FieldFlowReasonComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowReasonComment(v)
		return nil
	case flowreason.FieldFlowReasonNumSubjects:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowReasonNumSubjects(v)
		return nil
	case flowreason.FieldFlowReasonNumUnits:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowReasonNumUnits(v)
		return nil
	}
	return fmt.Errorf("unknown FlowReason field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FlowReasonMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FlowReasonMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FlowReasonMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown FlowReason numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FlowReasonMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FlowReasonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FlowReasonMutation) ClearField(name string) error {
	return fmt.Errorf("unknown FlowReason nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FlowReasonMutation) ResetField(name string) error {
	switch name {
	case flowreason.FieldFlowReasonGroupID:
		m.ResetFlowReasonGroupID()
		return nil
	case flowreason.FieldFlowReasonComment:
		m.ResetFlowReasonComment()
		return nil
	case flowreason.FieldFlowReasonNumSubjects:
		m.ResetFlowReasonNumSubjects()
		return nil
	case flowreason.FieldFlowReasonNumUnits:
		m.ResetFlowReasonNumUnits()
		return nil
	}
	return fmt.Errorf("unknown FlowReason field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FlowReasonMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.parent != nil {
		edges = append(edges, flowreason.EdgeParent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FlowReasonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case flowreason.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FlowReasonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FlowReasonMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FlowReasonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparent {
		edges = append(edges, flowreason.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FlowReasonMutation) EdgeCleared(name string) bool {
	switch name {
	case flowreason.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FlowReasonMutation) ClearEdge(name string) error {
	switch name {
	case flowreason.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown FlowReason unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FlowReasonMutation) ResetEdge(name string) error {
	switch name {
	case flowreason.EdgeParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown FlowReason edge %s", name)
}

// ImmunocompromisedGroupsMutation represents an operation that mutates the ImmunocompromisedGroups nodes in the graph.
type ImmunocompromisedGroupsMutation struct {
	config
	op            Op
	typ           string
	id            *int
	group_name    *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ImmunocompromisedGroups, error)
	predicates    []predicate.ImmunocompromisedGroups
}

var _ ent.Mutation = (*ImmunocompromisedGroupsMutation)(nil)

// immunocompromisedgroupsOption allows management of the mutation configuration using functional options.
type immunocompromisedgroupsOption func(*ImmunocompromisedGroupsMutation)

// newImmunocompromisedGroupsMutation creates new mutation for the ImmunocompromisedGroups entity.
func newImmunocompromisedGroupsMutation(c config, op Op, opts ...immunocompromisedgroupsOption) *ImmunocompromisedGroupsMutation {
	m := &ImmunocompromisedGroupsMutation{
		config:        c,
		op:            op,
		typ:           TypeImmunocompromisedGroups,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImmunocompromisedGroupsID sets the ID field of the mutation.
func withImmunocompromisedGroupsID(id int) immunocompromisedgroupsOption {
	return func(m *ImmunocompromisedGroupsMutation) {
		var (
			err   error
			once  sync.Once
			value *ImmunocompromisedGroups
		)
		m.oldValue = func(ctx context.Context) (*ImmunocompromisedGroups, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ImmunocompromisedGroups.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImmunocompromisedGroups sets the old ImmunocompromisedGroups of the mutation.
func withImmunocompromisedGroups(node *ImmunocompromisedGroups) immunocompromisedgroupsOption {
	return func(m *ImmunocompromisedGroupsMutation) {
		m.oldValue = func(context.Context) (*ImmunocompromisedGroups, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImmunocompromisedGroupsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImmunocompromisedGroupsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImmunocompromisedGroupsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImmunocompromisedGroupsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ImmunocompromisedGroups.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGroupName sets the "group_name" field.
func (m *ImmunocompromisedGroupsMutation) SetGroupName(s string) {
	m.group_name = &s
}

// GroupName returns the value of the "group_name" field in the mutation.
func (m *ImmunocompromisedGroupsMutation) GroupName() (r string, exists bool) {
	v := m.group_name
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupName returns the old "group_name" field's value of the ImmunocompromisedGroups entity.
// If the ImmunocompromisedGroups object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImmunocompromisedGroupsMutation) OldGroupName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupName: %w", err)
	}
	return oldValue.GroupName, nil
}

// ResetGroupName resets all changes to the "group_name" field.
func (m *ImmunocompromisedGroupsMutation) ResetGroupName() {
	m.group_name = nil
}

// Where appends a list predicates to the ImmunocompromisedGroupsMutation builder.
func (m *ImmunocompromisedGroupsMutation) Where(ps ...predicate.ImmunocompromisedGroups) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ImmunocompromisedGroupsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ImmunocompromisedGroups).
func (m *ImmunocompromisedGroupsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImmunocompromisedGroupsMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.group_name != nil {
		fields = append(fields, immunocompromisedgroups.FieldGroupName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImmunocompromisedGroupsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case immunocompromisedgroups.FieldGroupName:
		return m.GroupName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImmunocompromisedGroupsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case immunocompromisedgroups.FieldGroupName:
		return m.OldGroupName(ctx)
	}
	return nil, fmt.Errorf("unknown ImmunocompromisedGroups field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImmunocompromisedGroupsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case immunocompromisedgroups.FieldGroupName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupName(v)
		return nil
	}
	return fmt.Errorf("unknown ImmunocompromisedGroups field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImmunocompromisedGroupsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImmunocompromisedGroupsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImmunocompromisedGroupsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ImmunocompromisedGroups numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImmunocompromisedGroupsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImmunocompromisedGroupsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImmunocompromisedGroupsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ImmunocompromisedGroups nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImmunocompromisedGroupsMutation) ResetField(name string) error {
	switch name {
	case immunocompromisedgroups.FieldGroupName:
		m.ResetGroupName()
		return nil
	}
	return fmt.Errorf("unknown ImmunocompromisedGroups field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImmunocompromisedGroupsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImmunocompromisedGroupsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImmunocompromisedGroupsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImmunocompromisedGroupsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImmunocompromisedGroupsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImmunocompromisedGroupsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImmunocompromisedGroupsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ImmunocompromisedGroups unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImmunocompromisedGroupsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ImmunocompromisedGroups edge %s", name)
}

// ManufacturerMutation represents an operation that mutates the Manufacturer nodes in the graph.
type ManufacturerMutation struct {
	config
	op                Op
	typ               string
	id                *int
	manufacturer_name *string
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Manufacturer, error)
	predicates        []predicate.Manufacturer
}

var _ ent.Mutation = (*ManufacturerMutation)(nil)

// manufacturerOption allows management of the mutation configuration using functional options.
type manufacturerOption func(*ManufacturerMutation)

// newManufacturerMutation creates new mutation for the Manufacturer entity.
func newManufacturerMutation(c config, op Op, opts ...manufacturerOption) *ManufacturerMutation {
	m := &ManufacturerMutation{
		config:        c,
		op:            op,
		typ:           TypeManufacturer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withManufacturerID sets the ID field of the mutation.
func withManufacturerID(id int) manufacturerOption {
	return func(m *ManufacturerMutation) {
		var (
			err   error
			once  sync.Once
			value *Manufacturer
		)
		m.oldValue = func(ctx context.Context) (*Manufacturer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Manufacturer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withManufacturer sets the old Manufacturer of the mutation.
func withManufacturer(node *Manufacturer) manufacturerOption {
	return func(m *ManufacturerMutation) {
		m.oldValue = func(context.Context) (*Manufacturer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ManufacturerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ManufacturerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ManufacturerMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ManufacturerMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Manufacturer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetManufacturerName sets the "manufacturer_name" field.
func (m *ManufacturerMutation) SetManufacturerName(s string) {
	m.manufacturer_name = &s
}

// ManufacturerName returns the value of the "manufacturer_name" field in the mutation.
func (m *ManufacturerMutation) ManufacturerName() (r string, exists bool) {
	v := m.manufacturer_name
	if v == nil {
		return
	}
	return *v, true
}

// OldManufacturerName returns the old "manufacturer_name" field's value of the Manufacturer entity.
// If the Manufacturer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ManufacturerMutation) OldManufacturerName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManufacturerName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManufacturerName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManufacturerName: %w", err)
	}
	return oldValue.ManufacturerName, nil
}

// ResetManufacturerName resets all changes to the "manufacturer_name" field.
func (m *ManufacturerMutation) ResetManufacturerName() {
	m.manufacturer_name = nil
}

// Where appends a list predicates to the ManufacturerMutation builder.
func (m *ManufacturerMutation) Where(ps ...predicate.Manufacturer) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ManufacturerMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Manufacturer).
func (m *ManufacturerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ManufacturerMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.manufacturer_name != nil {
		fields = append(fields, manufacturer.FieldManufacturerName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ManufacturerMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case manufacturer.FieldManufacturerName:
		return m.ManufacturerName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ManufacturerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case manufacturer.FieldManufacturerName:
		return m.OldManufacturerName(ctx)
	}
	return nil, fmt.Errorf("unknown Manufacturer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ManufacturerMutation) SetField(name string, value ent.Value) error {
	switch name {
	case manufacturer.FieldManufacturerName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManufacturerName(v)
		return nil
	}
	return fmt.Errorf("unknown Manufacturer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ManufacturerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ManufacturerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ManufacturerMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Manufacturer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ManufacturerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ManufacturerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ManufacturerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Manufacturer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ManufacturerMutation) ResetField(name string) error {
	switch name {
	case manufacturer.FieldManufacturerName:
		m.ResetManufacturerName()
		return nil
	}
	return fmt.Errorf("unknown Manufacturer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ManufacturerMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ManufacturerMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ManufacturerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ManufacturerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ManufacturerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ManufacturerMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ManufacturerMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Manufacturer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ManufacturerMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Manufacturer edge %s", name)
}

// MoreInfoModuleMutation represents an operation that mutates the MoreInfoModule nodes in the graph.
type MoreInfoModuleMutation struct {
	config
	op                                  Op
	typ                                 string
	id                                  *int
	limitations_and_caveats_description *string
	clearedFields                       map[string]struct{}
	parent                              *int
	clearedparent                       bool
	certain_agreement                   *int
	clearedcertain_agreement            bool
	point_of_contact                    *int
	clearedpoint_of_contact             bool
	done                                bool
	oldValue                            func(context.Context) (*MoreInfoModule, error)
	predicates                          []predicate.MoreInfoModule
}

var _ ent.Mutation = (*MoreInfoModuleMutation)(nil)

// moreinfomoduleOption allows management of the mutation configuration using functional options.
type moreinfomoduleOption func(*MoreInfoModuleMutation)

// newMoreInfoModuleMutation creates new mutation for the MoreInfoModule entity.
func newMoreInfoModuleMutation(c config, op Op, opts ...moreinfomoduleOption) *MoreInfoModuleMutation {
	m := &MoreInfoModuleMutation{
		config:        c,
		op:            op,
		typ:           TypeMoreInfoModule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMoreInfoModuleID sets the ID field of the mutation.
func withMoreInfoModuleID(id int) moreinfomoduleOption {
	return func(m *MoreInfoModuleMutation) {
		var (
			err   error
			once  sync.Once
			value *MoreInfoModule
		)
		m.oldValue = func(ctx context.Context) (*MoreInfoModule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MoreInfoModule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMoreInfoModule sets the old MoreInfoModule of the mutation.
func withMoreInfoModule(node *MoreInfoModule) moreinfomoduleOption {
	return func(m *MoreInfoModuleMutation) {
		m.oldValue = func(context.Context) (*MoreInfoModule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MoreInfoModuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MoreInfoModuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MoreInfoModuleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MoreInfoModuleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MoreInfoModule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLimitationsAndCaveatsDescription sets the "limitations_and_caveats_description" field.
func (m *MoreInfoModuleMutation) SetLimitationsAndCaveatsDescription(s string) {
	m.limitations_and_caveats_description = &s
}

// LimitationsAndCaveatsDescription returns the value of the "limitations_and_caveats_description" field in the mutation.
func (m *MoreInfoModuleMutation) LimitationsAndCaveatsDescription() (r string, exists bool) {
	v := m.limitations_and_caveats_description
	if v == nil {
		return
	}
	return *v, true
}

// OldLimitationsAndCaveatsDescription returns the old "limitations_and_caveats_description" field's value of the MoreInfoModule entity.
// If the MoreInfoModule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MoreInfoModuleMutation) OldLimitationsAndCaveatsDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLimitationsAndCaveatsDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLimitationsAndCaveatsDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLimitationsAndCaveatsDescription: %w", err)
	}
	return oldValue.LimitationsAndCaveatsDescription, nil
}

// ResetLimitationsAndCaveatsDescription resets all changes to the "limitations_and_caveats_description" field.
func (m *MoreInfoModuleMutation) ResetLimitationsAndCaveatsDescription() {
	m.limitations_and_caveats_description = nil
}

// SetParentID sets the "parent" edge to the ResultsDefinition entity by id.
func (m *MoreInfoModuleMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ResultsDefinition entity.
func (m *MoreInfoModuleMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ResultsDefinition entity was cleared.
func (m *MoreInfoModuleMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *MoreInfoModuleMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *MoreInfoModuleMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *MoreInfoModuleMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// SetCertainAgreementID sets the "certain_agreement" edge to the CertainAgreement entity by id.
func (m *MoreInfoModuleMutation) SetCertainAgreementID(id int) {
	m.certain_agreement = &id
}

// ClearCertainAgreement clears the "certain_agreement" edge to the CertainAgreement entity.
func (m *MoreInfoModuleMutation) ClearCertainAgreement() {
	m.clearedcertain_agreement = true
}

// CertainAgreementCleared reports if the "certain_agreement" edge to the CertainAgreement entity was cleared.
func (m *MoreInfoModuleMutation) CertainAgreementCleared() bool {
	return m.clearedcertain_agreement
}

// CertainAgreementID returns the "certain_agreement" edge ID in the mutation.
func (m *MoreInfoModuleMutation) CertainAgreementID() (id int, exists bool) {
	if m.certain_agreement != nil {
		return *m.certain_agreement, true
	}
	return
}

// CertainAgreementIDs returns the "certain_agreement" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CertainAgreementID instead. It exists only for internal usage by the builders.
func (m *MoreInfoModuleMutation) CertainAgreementIDs() (ids []int) {
	if id := m.certain_agreement; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCertainAgreement resets all changes to the "certain_agreement" edge.
func (m *MoreInfoModuleMutation) ResetCertainAgreement() {
	m.certain_agreement = nil
	m.clearedcertain_agreement = false
}

// SetPointOfContactID sets the "point_of_contact" edge to the PointOfContact entity by id.
func (m *MoreInfoModuleMutation) SetPointOfContactID(id int) {
	m.point_of_contact = &id
}

// ClearPointOfContact clears the "point_of_contact" edge to the PointOfContact entity.
func (m *MoreInfoModuleMutation) ClearPointOfContact() {
	m.clearedpoint_of_contact = true
}

// PointOfContactCleared reports if the "point_of_contact" edge to the PointOfContact entity was cleared.
func (m *MoreInfoModuleMutation) PointOfContactCleared() bool {
	return m.clearedpoint_of_contact
}

// PointOfContactID returns the "point_of_contact" edge ID in the mutation.
func (m *MoreInfoModuleMutation) PointOfContactID() (id int, exists bool) {
	if m.point_of_contact != nil {
		return *m.point_of_contact, true
	}
	return
}

// PointOfContactIDs returns the "point_of_contact" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PointOfContactID instead. It exists only for internal usage by the builders.
func (m *MoreInfoModuleMutation) PointOfContactIDs() (ids []int) {
	if id := m.point_of_contact; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPointOfContact resets all changes to the "point_of_contact" edge.
func (m *MoreInfoModuleMutation) ResetPointOfContact() {
	m.point_of_contact = nil
	m.clearedpoint_of_contact = false
}

// Where appends a list predicates to the MoreInfoModuleMutation builder.
func (m *MoreInfoModuleMutation) Where(ps ...predicate.MoreInfoModule) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *MoreInfoModuleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (MoreInfoModule).
func (m *MoreInfoModuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MoreInfoModuleMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.limitations_and_caveats_description != nil {
		fields = append(fields, moreinfomodule.FieldLimitationsAndCaveatsDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MoreInfoModuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case moreinfomodule.FieldLimitationsAndCaveatsDescription:
		return m.LimitationsAndCaveatsDescription()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MoreInfoModuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case moreinfomodule.FieldLimitationsAndCaveatsDescription:
		return m.OldLimitationsAndCaveatsDescription(ctx)
	}
	return nil, fmt.Errorf("unknown MoreInfoModule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MoreInfoModuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case moreinfomodule.FieldLimitationsAndCaveatsDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLimitationsAndCaveatsDescription(v)
		return nil
	}
	return fmt.Errorf("unknown MoreInfoModule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MoreInfoModuleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MoreInfoModuleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MoreInfoModuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown MoreInfoModule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MoreInfoModuleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MoreInfoModuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MoreInfoModuleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown MoreInfoModule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MoreInfoModuleMutation) ResetField(name string) error {
	switch name {
	case moreinfomodule.FieldLimitationsAndCaveatsDescription:
		m.ResetLimitationsAndCaveatsDescription()
		return nil
	}
	return fmt.Errorf("unknown MoreInfoModule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MoreInfoModuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent != nil {
		edges = append(edges, moreinfomodule.EdgeParent)
	}
	if m.certain_agreement != nil {
		edges = append(edges, moreinfomodule.EdgeCertainAgreement)
	}
	if m.point_of_contact != nil {
		edges = append(edges, moreinfomodule.EdgePointOfContact)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MoreInfoModuleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case moreinfomodule.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case moreinfomodule.EdgeCertainAgreement:
		if id := m.certain_agreement; id != nil {
			return []ent.Value{*id}
		}
	case moreinfomodule.EdgePointOfContact:
		if id := m.point_of_contact; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MoreInfoModuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MoreInfoModuleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MoreInfoModuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent {
		edges = append(edges, moreinfomodule.EdgeParent)
	}
	if m.clearedcertain_agreement {
		edges = append(edges, moreinfomodule.EdgeCertainAgreement)
	}
	if m.clearedpoint_of_contact {
		edges = append(edges, moreinfomodule.EdgePointOfContact)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MoreInfoModuleMutation) EdgeCleared(name string) bool {
	switch name {
	case moreinfomodule.EdgeParent:
		return m.clearedparent
	case moreinfomodule.EdgeCertainAgreement:
		return m.clearedcertain_agreement
	case moreinfomodule.EdgePointOfContact:
		return m.clearedpoint_of_contact
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MoreInfoModuleMutation) ClearEdge(name string) error {
	switch name {
	case moreinfomodule.EdgeParent:
		m.ClearParent()
		return nil
	case moreinfomodule.EdgeCertainAgreement:
		m.ClearCertainAgreement()
		return nil
	case moreinfomodule.EdgePointOfContact:
		m.ClearPointOfContact()
		return nil
	}
	return fmt.Errorf("unknown MoreInfoModule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MoreInfoModuleMutation) ResetEdge(name string) error {
	switch name {
	case moreinfomodule.EdgeParent:
		m.ResetParent()
		return nil
	case moreinfomodule.EdgeCertainAgreement:
		m.ResetCertainAgreement()
		return nil
	case moreinfomodule.EdgePointOfContact:
		m.ResetPointOfContact()
		return nil
	}
	return fmt.Errorf("unknown MoreInfoModule edge %s", name)
}

// OtherEventMutation represents an operation that mutates the OtherEvent nodes in the graph.
type OtherEventMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	other_event_term              *string
	other_event_organ_system      *string
	other_event_source_vocabulary *string
	other_event_assessment_type   *string
	other_event_notes             *string
	clearedFields                 map[string]struct{}
	parent                        *int
	clearedparent                 bool
	other_event_stats_list        map[int]struct{}
	removedother_event_stats_list map[int]struct{}
	clearedother_event_stats_list bool
	done                          bool
	oldValue                      func(context.Context) (*OtherEvent, error)
	predicates                    []predicate.OtherEvent
}

var _ ent.Mutation = (*OtherEventMutation)(nil)

// othereventOption allows management of the mutation configuration using functional options.
type othereventOption func(*OtherEventMutation)

// newOtherEventMutation creates new mutation for the OtherEvent entity.
func newOtherEventMutation(c config, op Op, opts ...othereventOption) *OtherEventMutation {
	m := &OtherEventMutation{
		config:        c,
		op:            op,
		typ:           TypeOtherEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOtherEventID sets the ID field of the mutation.
func withOtherEventID(id int) othereventOption {
	return func(m *OtherEventMutation) {
		var (
			err   error
			once  sync.Once
			value *OtherEvent
		)
		m.oldValue = func(ctx context.Context) (*OtherEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OtherEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOtherEvent sets the old OtherEvent of the mutation.
func withOtherEvent(node *OtherEvent) othereventOption {
	return func(m *OtherEventMutation) {
		m.oldValue = func(context.Context) (*OtherEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OtherEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OtherEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OtherEventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OtherEventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OtherEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOtherEventTerm sets the "other_event_term" field.
func (m *OtherEventMutation) SetOtherEventTerm(s string) {
	m.other_event_term = &s
}

// OtherEventTerm returns the value of the "other_event_term" field in the mutation.
func (m *OtherEventMutation) OtherEventTerm() (r string, exists bool) {
	v := m.other_event_term
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherEventTerm returns the old "other_event_term" field's value of the OtherEvent entity.
// If the OtherEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtherEventMutation) OldOtherEventTerm(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherEventTerm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherEventTerm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherEventTerm: %w", err)
	}
	return oldValue.OtherEventTerm, nil
}

// ResetOtherEventTerm resets all changes to the "other_event_term" field.
func (m *OtherEventMutation) ResetOtherEventTerm() {
	m.other_event_term = nil
}

// SetOtherEventOrganSystem sets the "other_event_organ_system" field.
func (m *OtherEventMutation) SetOtherEventOrganSystem(s string) {
	m.other_event_organ_system = &s
}

// OtherEventOrganSystem returns the value of the "other_event_organ_system" field in the mutation.
func (m *OtherEventMutation) OtherEventOrganSystem() (r string, exists bool) {
	v := m.other_event_organ_system
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherEventOrganSystem returns the old "other_event_organ_system" field's value of the OtherEvent entity.
// If the OtherEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtherEventMutation) OldOtherEventOrganSystem(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherEventOrganSystem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherEventOrganSystem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherEventOrganSystem: %w", err)
	}
	return oldValue.OtherEventOrganSystem, nil
}

// ResetOtherEventOrganSystem resets all changes to the "other_event_organ_system" field.
func (m *OtherEventMutation) ResetOtherEventOrganSystem() {
	m.other_event_organ_system = nil
}

// SetOtherEventSourceVocabulary sets the "other_event_source_vocabulary" field.
func (m *OtherEventMutation) SetOtherEventSourceVocabulary(s string) {
	m.other_event_source_vocabulary = &s
}

// OtherEventSourceVocabulary returns the value of the "other_event_source_vocabulary" field in the mutation.
func (m *OtherEventMutation) OtherEventSourceVocabulary() (r string, exists bool) {
	v := m.other_event_source_vocabulary
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherEventSourceVocabulary returns the old "other_event_source_vocabulary" field's value of the OtherEvent entity.
// If the OtherEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtherEventMutation) OldOtherEventSourceVocabulary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherEventSourceVocabulary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherEventSourceVocabulary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherEventSourceVocabulary: %w", err)
	}
	return oldValue.OtherEventSourceVocabulary, nil
}

// ResetOtherEventSourceVocabulary resets all changes to the "other_event_source_vocabulary" field.
func (m *OtherEventMutation) ResetOtherEventSourceVocabulary() {
	m.other_event_source_vocabulary = nil
}

// SetOtherEventAssessmentType sets the "other_event_assessment_type" field.
func (m *OtherEventMutation) SetOtherEventAssessmentType(s string) {
	m.other_event_assessment_type = &s
}

// OtherEventAssessmentType returns the value of the "other_event_assessment_type" field in the mutation.
func (m *OtherEventMutation) OtherEventAssessmentType() (r string, exists bool) {
	v := m.other_event_assessment_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherEventAssessmentType returns the old "other_event_assessment_type" field's value of the OtherEvent entity.
// If the OtherEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtherEventMutation) OldOtherEventAssessmentType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherEventAssessmentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherEventAssessmentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherEventAssessmentType: %w", err)
	}
	return oldValue.OtherEventAssessmentType, nil
}

// ResetOtherEventAssessmentType resets all changes to the "other_event_assessment_type" field.
func (m *OtherEventMutation) ResetOtherEventAssessmentType() {
	m.other_event_assessment_type = nil
}

// SetOtherEventNotes sets the "other_event_notes" field.
func (m *OtherEventMutation) SetOtherEventNotes(s string) {
	m.other_event_notes = &s
}

// OtherEventNotes returns the value of the "other_event_notes" field in the mutation.
func (m *OtherEventMutation) OtherEventNotes() (r string, exists bool) {
	v := m.other_event_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherEventNotes returns the old "other_event_notes" field's value of the OtherEvent entity.
// If the OtherEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtherEventMutation) OldOtherEventNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherEventNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherEventNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherEventNotes: %w", err)
	}
	return oldValue.OtherEventNotes, nil
}

// ResetOtherEventNotes resets all changes to the "other_event_notes" field.
func (m *OtherEventMutation) ResetOtherEventNotes() {
	m.other_event_notes = nil
}

// SetParentID sets the "parent" edge to the AdverseEventsModule entity by id.
func (m *OtherEventMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the AdverseEventsModule entity.
func (m *OtherEventMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the AdverseEventsModule entity was cleared.
func (m *OtherEventMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *OtherEventMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *OtherEventMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *OtherEventMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddOtherEventStatsListIDs adds the "other_event_stats_list" edge to the OtherEventStats entity by ids.
func (m *OtherEventMutation) AddOtherEventStatsListIDs(ids ...int) {
	if m.other_event_stats_list == nil {
		m.other_event_stats_list = make(map[int]struct{})
	}
	for i := range ids {
		m.other_event_stats_list[ids[i]] = struct{}{}
	}
}

// ClearOtherEventStatsList clears the "other_event_stats_list" edge to the OtherEventStats entity.
func (m *OtherEventMutation) ClearOtherEventStatsList() {
	m.clearedother_event_stats_list = true
}

// OtherEventStatsListCleared reports if the "other_event_stats_list" edge to the OtherEventStats entity was cleared.
func (m *OtherEventMutation) OtherEventStatsListCleared() bool {
	return m.clearedother_event_stats_list
}

// RemoveOtherEventStatsListIDs removes the "other_event_stats_list" edge to the OtherEventStats entity by IDs.
func (m *OtherEventMutation) RemoveOtherEventStatsListIDs(ids ...int) {
	if m.removedother_event_stats_list == nil {
		m.removedother_event_stats_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.other_event_stats_list, ids[i])
		m.removedother_event_stats_list[ids[i]] = struct{}{}
	}
}

// RemovedOtherEventStatsList returns the removed IDs of the "other_event_stats_list" edge to the OtherEventStats entity.
func (m *OtherEventMutation) RemovedOtherEventStatsListIDs() (ids []int) {
	for id := range m.removedother_event_stats_list {
		ids = append(ids, id)
	}
	return
}

// OtherEventStatsListIDs returns the "other_event_stats_list" edge IDs in the mutation.
func (m *OtherEventMutation) OtherEventStatsListIDs() (ids []int) {
	for id := range m.other_event_stats_list {
		ids = append(ids, id)
	}
	return
}

// ResetOtherEventStatsList resets all changes to the "other_event_stats_list" edge.
func (m *OtherEventMutation) ResetOtherEventStatsList() {
	m.other_event_stats_list = nil
	m.clearedother_event_stats_list = false
	m.removedother_event_stats_list = nil
}

// Where appends a list predicates to the OtherEventMutation builder.
func (m *OtherEventMutation) Where(ps ...predicate.OtherEvent) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OtherEventMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OtherEvent).
func (m *OtherEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OtherEventMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.other_event_term != nil {
		fields = append(fields, otherevent.FieldOtherEventTerm)
	}
	if m.other_event_organ_system != nil {
		fields = append(fields, otherevent.FieldOtherEventOrganSystem)
	}
	if m.other_event_source_vocabulary != nil {
		fields = append(fields, otherevent.FieldOtherEventSourceVocabulary)
	}
	if m.other_event_assessment_type != nil {
		fields = append(fields, otherevent.FieldOtherEventAssessmentType)
	}
	if m.other_event_notes != nil {
		fields = append(fields, otherevent.FieldOtherEventNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OtherEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case otherevent.FieldOtherEventTerm:
		return m.OtherEventTerm()
	case otherevent.FieldOtherEventOrganSystem:
		return m.OtherEventOrganSystem()
	case otherevent.FieldOtherEventSourceVocabulary:
		return m.OtherEventSourceVocabulary()
	case otherevent.FieldOtherEventAssessmentType:
		return m.OtherEventAssessmentType()
	case otherevent.FieldOtherEventNotes:
		return m.OtherEventNotes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OtherEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case otherevent.FieldOtherEventTerm:
		return m.OldOtherEventTerm(ctx)
	case otherevent.FieldOtherEventOrganSystem:
		return m.OldOtherEventOrganSystem(ctx)
	case otherevent.FieldOtherEventSourceVocabulary:
		return m.OldOtherEventSourceVocabulary(ctx)
	case otherevent.FieldOtherEventAssessmentType:
		return m.OldOtherEventAssessmentType(ctx)
	case otherevent.FieldOtherEventNotes:
		return m.OldOtherEventNotes(ctx)
	}
	return nil, fmt.Errorf("unknown OtherEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OtherEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case otherevent.FieldOtherEventTerm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherEventTerm(v)
		return nil
	case otherevent.FieldOtherEventOrganSystem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherEventOrganSystem(v)
		return nil
	case otherevent.FieldOtherEventSourceVocabulary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherEventSourceVocabulary(v)
		return nil
	case otherevent.FieldOtherEventAssessmentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherEventAssessmentType(v)
		return nil
	case otherevent.FieldOtherEventNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherEventNotes(v)
		return nil
	}
	return fmt.Errorf("unknown OtherEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OtherEventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OtherEventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OtherEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OtherEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OtherEventMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OtherEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OtherEventMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OtherEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OtherEventMutation) ResetField(name string) error {
	switch name {
	case otherevent.FieldOtherEventTerm:
		m.ResetOtherEventTerm()
		return nil
	case otherevent.FieldOtherEventOrganSystem:
		m.ResetOtherEventOrganSystem()
		return nil
	case otherevent.FieldOtherEventSourceVocabulary:
		m.ResetOtherEventSourceVocabulary()
		return nil
	case otherevent.FieldOtherEventAssessmentType:
		m.ResetOtherEventAssessmentType()
		return nil
	case otherevent.FieldOtherEventNotes:
		m.ResetOtherEventNotes()
		return nil
	}
	return fmt.Errorf("unknown OtherEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OtherEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.parent != nil {
		edges = append(edges, otherevent.EdgeParent)
	}
	if m.other_event_stats_list != nil {
		edges = append(edges, otherevent.EdgeOtherEventStatsList)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OtherEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case otherevent.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case otherevent.EdgeOtherEventStatsList:
		ids := make([]ent.Value, 0, len(m.other_event_stats_list))
		for id := range m.other_event_stats_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OtherEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedother_event_stats_list != nil {
		edges = append(edges, otherevent.EdgeOtherEventStatsList)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OtherEventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case otherevent.EdgeOtherEventStatsList:
		ids := make([]ent.Value, 0, len(m.removedother_event_stats_list))
		for id := range m.removedother_event_stats_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OtherEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedparent {
		edges = append(edges, otherevent.EdgeParent)
	}
	if m.clearedother_event_stats_list {
		edges = append(edges, otherevent.EdgeOtherEventStatsList)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OtherEventMutation) EdgeCleared(name string) bool {
	switch name {
	case otherevent.EdgeParent:
		return m.clearedparent
	case otherevent.EdgeOtherEventStatsList:
		return m.clearedother_event_stats_list
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OtherEventMutation) ClearEdge(name string) error {
	switch name {
	case otherevent.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown OtherEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OtherEventMutation) ResetEdge(name string) error {
	switch name {
	case otherevent.EdgeParent:
		m.ResetParent()
		return nil
	case otherevent.EdgeOtherEventStatsList:
		m.ResetOtherEventStatsList()
		return nil
	}
	return fmt.Errorf("unknown OtherEvent edge %s", name)
}

// OtherEventStatsMutation represents an operation that mutates the OtherEventStats nodes in the graph.
type OtherEventStatsMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	other_event_stats_group_id     *string
	other_event_stats_num_events   *string
	other_event_stats_num_affected *string
	other_event_stats_num_at_risk  *string
	clearedFields                  map[string]struct{}
	parent                         *int
	clearedparent                  bool
	done                           bool
	oldValue                       func(context.Context) (*OtherEventStats, error)
	predicates                     []predicate.OtherEventStats
}

var _ ent.Mutation = (*OtherEventStatsMutation)(nil)

// othereventstatsOption allows management of the mutation configuration using functional options.
type othereventstatsOption func(*OtherEventStatsMutation)

// newOtherEventStatsMutation creates new mutation for the OtherEventStats entity.
func newOtherEventStatsMutation(c config, op Op, opts ...othereventstatsOption) *OtherEventStatsMutation {
	m := &OtherEventStatsMutation{
		config:        c,
		op:            op,
		typ:           TypeOtherEventStats,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOtherEventStatsID sets the ID field of the mutation.
func withOtherEventStatsID(id int) othereventstatsOption {
	return func(m *OtherEventStatsMutation) {
		var (
			err   error
			once  sync.Once
			value *OtherEventStats
		)
		m.oldValue = func(ctx context.Context) (*OtherEventStats, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OtherEventStats.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOtherEventStats sets the old OtherEventStats of the mutation.
func withOtherEventStats(node *OtherEventStats) othereventstatsOption {
	return func(m *OtherEventStatsMutation) {
		m.oldValue = func(context.Context) (*OtherEventStats, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OtherEventStatsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OtherEventStatsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OtherEventStatsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OtherEventStatsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OtherEventStats.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOtherEventStatsGroupID sets the "other_event_stats_group_id" field.
func (m *OtherEventStatsMutation) SetOtherEventStatsGroupID(s string) {
	m.other_event_stats_group_id = &s
}

// OtherEventStatsGroupID returns the value of the "other_event_stats_group_id" field in the mutation.
func (m *OtherEventStatsMutation) OtherEventStatsGroupID() (r string, exists bool) {
	v := m.other_event_stats_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherEventStatsGroupID returns the old "other_event_stats_group_id" field's value of the OtherEventStats entity.
// If the OtherEventStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtherEventStatsMutation) OldOtherEventStatsGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherEventStatsGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherEventStatsGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherEventStatsGroupID: %w", err)
	}
	return oldValue.OtherEventStatsGroupID, nil
}

// ResetOtherEventStatsGroupID resets all changes to the "other_event_stats_group_id" field.
func (m *OtherEventStatsMutation) ResetOtherEventStatsGroupID() {
	m.other_event_stats_group_id = nil
}

// SetOtherEventStatsNumEvents sets the "other_event_stats_num_events" field.
func (m *OtherEventStatsMutation) SetOtherEventStatsNumEvents(s string) {
	m.other_event_stats_num_events = &s
}

// OtherEventStatsNumEvents returns the value of the "other_event_stats_num_events" field in the mutation.
func (m *OtherEventStatsMutation) OtherEventStatsNumEvents() (r string, exists bool) {
	v := m.other_event_stats_num_events
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherEventStatsNumEvents returns the old "other_event_stats_num_events" field's value of the OtherEventStats entity.
// If the OtherEventStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtherEventStatsMutation) OldOtherEventStatsNumEvents(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherEventStatsNumEvents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherEventStatsNumEvents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherEventStatsNumEvents: %w", err)
	}
	return oldValue.OtherEventStatsNumEvents, nil
}

// ResetOtherEventStatsNumEvents resets all changes to the "other_event_stats_num_events" field.
func (m *OtherEventStatsMutation) ResetOtherEventStatsNumEvents() {
	m.other_event_stats_num_events = nil
}

// SetOtherEventStatsNumAffected sets the "other_event_stats_num_affected" field.
func (m *OtherEventStatsMutation) SetOtherEventStatsNumAffected(s string) {
	m.other_event_stats_num_affected = &s
}

// OtherEventStatsNumAffected returns the value of the "other_event_stats_num_affected" field in the mutation.
func (m *OtherEventStatsMutation) OtherEventStatsNumAffected() (r string, exists bool) {
	v := m.other_event_stats_num_affected
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherEventStatsNumAffected returns the old "other_event_stats_num_affected" field's value of the OtherEventStats entity.
// If the OtherEventStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtherEventStatsMutation) OldOtherEventStatsNumAffected(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherEventStatsNumAffected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherEventStatsNumAffected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherEventStatsNumAffected: %w", err)
	}
	return oldValue.OtherEventStatsNumAffected, nil
}

// ResetOtherEventStatsNumAffected resets all changes to the "other_event_stats_num_affected" field.
func (m *OtherEventStatsMutation) ResetOtherEventStatsNumAffected() {
	m.other_event_stats_num_affected = nil
}

// SetOtherEventStatsNumAtRisk sets the "other_event_stats_num_at_risk" field.
func (m *OtherEventStatsMutation) SetOtherEventStatsNumAtRisk(s string) {
	m.other_event_stats_num_at_risk = &s
}

// OtherEventStatsNumAtRisk returns the value of the "other_event_stats_num_at_risk" field in the mutation.
func (m *OtherEventStatsMutation) OtherEventStatsNumAtRisk() (r string, exists bool) {
	v := m.other_event_stats_num_at_risk
	if v == nil {
		return
	}
	return *v, true
}

// OldOtherEventStatsNumAtRisk returns the old "other_event_stats_num_at_risk" field's value of the OtherEventStats entity.
// If the OtherEventStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OtherEventStatsMutation) OldOtherEventStatsNumAtRisk(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtherEventStatsNumAtRisk is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtherEventStatsNumAtRisk requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtherEventStatsNumAtRisk: %w", err)
	}
	return oldValue.OtherEventStatsNumAtRisk, nil
}

// ResetOtherEventStatsNumAtRisk resets all changes to the "other_event_stats_num_at_risk" field.
func (m *OtherEventStatsMutation) ResetOtherEventStatsNumAtRisk() {
	m.other_event_stats_num_at_risk = nil
}

// SetParentID sets the "parent" edge to the OtherEvent entity by id.
func (m *OtherEventStatsMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the OtherEvent entity.
func (m *OtherEventStatsMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the OtherEvent entity was cleared.
func (m *OtherEventStatsMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *OtherEventStatsMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *OtherEventStatsMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *OtherEventStatsMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// Where appends a list predicates to the OtherEventStatsMutation builder.
func (m *OtherEventStatsMutation) Where(ps ...predicate.OtherEventStats) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OtherEventStatsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OtherEventStats).
func (m *OtherEventStatsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OtherEventStatsMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.other_event_stats_group_id != nil {
		fields = append(fields, othereventstats.FieldOtherEventStatsGroupID)
	}
	if m.other_event_stats_num_events != nil {
		fields = append(fields, othereventstats.FieldOtherEventStatsNumEvents)
	}
	if m.other_event_stats_num_affected != nil {
		fields = append(fields, othereventstats.FieldOtherEventStatsNumAffected)
	}
	if m.other_event_stats_num_at_risk != nil {
		fields = append(fields, othereventstats.FieldOtherEventStatsNumAtRisk)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OtherEventStatsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case othereventstats.FieldOtherEventStatsGroupID:
		return m.OtherEventStatsGroupID()
	case othereventstats.FieldOtherEventStatsNumEvents:
		return m.OtherEventStatsNumEvents()
	case othereventstats.FieldOtherEventStatsNumAffected:
		return m.OtherEventStatsNumAffected()
	case othereventstats.FieldOtherEventStatsNumAtRisk:
		return m.OtherEventStatsNumAtRisk()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OtherEventStatsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case othereventstats.FieldOtherEventStatsGroupID:
		return m.OldOtherEventStatsGroupID(ctx)
	case othereventstats.FieldOtherEventStatsNumEvents:
		return m.OldOtherEventStatsNumEvents(ctx)
	case othereventstats.FieldOtherEventStatsNumAffected:
		return m.OldOtherEventStatsNumAffected(ctx)
	case othereventstats.FieldOtherEventStatsNumAtRisk:
		return m.OldOtherEventStatsNumAtRisk(ctx)
	}
	return nil, fmt.Errorf("unknown OtherEventStats field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OtherEventStatsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case othereventstats.FieldOtherEventStatsGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherEventStatsGroupID(v)
		return nil
	case othereventstats.FieldOtherEventStatsNumEvents:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherEventStatsNumEvents(v)
		return nil
	case othereventstats.FieldOtherEventStatsNumAffected:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherEventStatsNumAffected(v)
		return nil
	case othereventstats.FieldOtherEventStatsNumAtRisk:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtherEventStatsNumAtRisk(v)
		return nil
	}
	return fmt.Errorf("unknown OtherEventStats field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OtherEventStatsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OtherEventStatsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OtherEventStatsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OtherEventStats numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OtherEventStatsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OtherEventStatsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OtherEventStatsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OtherEventStats nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OtherEventStatsMutation) ResetField(name string) error {
	switch name {
	case othereventstats.FieldOtherEventStatsGroupID:
		m.ResetOtherEventStatsGroupID()
		return nil
	case othereventstats.FieldOtherEventStatsNumEvents:
		m.ResetOtherEventStatsNumEvents()
		return nil
	case othereventstats.FieldOtherEventStatsNumAffected:
		m.ResetOtherEventStatsNumAffected()
		return nil
	case othereventstats.FieldOtherEventStatsNumAtRisk:
		m.ResetOtherEventStatsNumAtRisk()
		return nil
	}
	return fmt.Errorf("unknown OtherEventStats field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OtherEventStatsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.parent != nil {
		edges = append(edges, othereventstats.EdgeParent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OtherEventStatsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case othereventstats.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OtherEventStatsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OtherEventStatsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OtherEventStatsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparent {
		edges = append(edges, othereventstats.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OtherEventStatsMutation) EdgeCleared(name string) bool {
	switch name {
	case othereventstats.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OtherEventStatsMutation) ClearEdge(name string) error {
	switch name {
	case othereventstats.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown OtherEventStats unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OtherEventStatsMutation) ResetEdge(name string) error {
	switch name {
	case othereventstats.EdgeParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown OtherEventStats edge %s", name)
}

// OutcomeAnalysisMutation represents an operation that mutates the OutcomeAnalysis nodes in the graph.
type OutcomeAnalysisMutation struct {
	config
	op                                          Op
	typ                                         string
	id                                          *int
	outcome_analysis_group_description          *string
	outcome_analysis_tested_non_inferiority     *string
	outcome_analysis_non_inferiority_type       *string
	outcome_analysis_non_inferiority_comment    *string
	outcome_analysis_p_value                    *string
	outcome_analysis_p_value_comment            *string
	outcome_analysis_statistical_method         *string
	outcome_analysis_statistical_comment        *string
	outcome_analysis_param_type                 *string
	outcome_analysis_param_value                *string
	outcome_analysis_ci_pct_value               *string
	outcome_analysis_ci_num_sides               *string
	outcome_analysis_ci_lower_limit             *string
	outcome_analysis_ci_upper_limit             *string
	outcome_analysis_ci_lower_limit_comment     *string
	outcome_analysis_ci_upper_limit_comment     *string
	outcome_analysis_dispersion_type            *string
	outcome_analysis_dispersion_value           *string
	outcome_analysis_estimate_comment           *string
	outcome_analysis_other_analysis_description *string
	clearedFields                               map[string]struct{}
	parent                                      *int
	clearedparent                               bool
	outcome_analysis_group_id_list              map[int]struct{}
	removedoutcome_analysis_group_id_list       map[int]struct{}
	clearedoutcome_analysis_group_id_list       bool
	done                                        bool
	oldValue                                    func(context.Context) (*OutcomeAnalysis, error)
	predicates                                  []predicate.OutcomeAnalysis
}

var _ ent.Mutation = (*OutcomeAnalysisMutation)(nil)

// outcomeanalysisOption allows management of the mutation configuration using functional options.
type outcomeanalysisOption func(*OutcomeAnalysisMutation)

// newOutcomeAnalysisMutation creates new mutation for the OutcomeAnalysis entity.
func newOutcomeAnalysisMutation(c config, op Op, opts ...outcomeanalysisOption) *OutcomeAnalysisMutation {
	m := &OutcomeAnalysisMutation{
		config:        c,
		op:            op,
		typ:           TypeOutcomeAnalysis,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOutcomeAnalysisID sets the ID field of the mutation.
func withOutcomeAnalysisID(id int) outcomeanalysisOption {
	return func(m *OutcomeAnalysisMutation) {
		var (
			err   error
			once  sync.Once
			value *OutcomeAnalysis
		)
		m.oldValue = func(ctx context.Context) (*OutcomeAnalysis, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OutcomeAnalysis.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOutcomeAnalysis sets the old OutcomeAnalysis of the mutation.
func withOutcomeAnalysis(node *OutcomeAnalysis) outcomeanalysisOption {
	return func(m *OutcomeAnalysisMutation) {
		m.oldValue = func(context.Context) (*OutcomeAnalysis, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OutcomeAnalysisMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OutcomeAnalysisMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OutcomeAnalysisMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OutcomeAnalysisMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OutcomeAnalysis.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOutcomeAnalysisGroupDescription sets the "outcome_analysis_group_description" field.
func (m *OutcomeAnalysisMutation) SetOutcomeAnalysisGroupDescription(s string) {
	m.outcome_analysis_group_description = &s
}

// OutcomeAnalysisGroupDescription returns the value of the "outcome_analysis_group_description" field in the mutation.
func (m *OutcomeAnalysisMutation) OutcomeAnalysisGroupDescription() (r string, exists bool) {
	v := m.outcome_analysis_group_description
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeAnalysisGroupDescription returns the old "outcome_analysis_group_description" field's value of the OutcomeAnalysis entity.
// If the OutcomeAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeAnalysisMutation) OldOutcomeAnalysisGroupDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeAnalysisGroupDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeAnalysisGroupDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeAnalysisGroupDescription: %w", err)
	}
	return oldValue.OutcomeAnalysisGroupDescription, nil
}

// ResetOutcomeAnalysisGroupDescription resets all changes to the "outcome_analysis_group_description" field.
func (m *OutcomeAnalysisMutation) ResetOutcomeAnalysisGroupDescription() {
	m.outcome_analysis_group_description = nil
}

// SetOutcomeAnalysisTestedNonInferiority sets the "outcome_analysis_tested_non_inferiority" field.
func (m *OutcomeAnalysisMutation) SetOutcomeAnalysisTestedNonInferiority(s string) {
	m.outcome_analysis_tested_non_inferiority = &s
}

// OutcomeAnalysisTestedNonInferiority returns the value of the "outcome_analysis_tested_non_inferiority" field in the mutation.
func (m *OutcomeAnalysisMutation) OutcomeAnalysisTestedNonInferiority() (r string, exists bool) {
	v := m.outcome_analysis_tested_non_inferiority
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeAnalysisTestedNonInferiority returns the old "outcome_analysis_tested_non_inferiority" field's value of the OutcomeAnalysis entity.
// If the OutcomeAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeAnalysisMutation) OldOutcomeAnalysisTestedNonInferiority(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeAnalysisTestedNonInferiority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeAnalysisTestedNonInferiority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeAnalysisTestedNonInferiority: %w", err)
	}
	return oldValue.OutcomeAnalysisTestedNonInferiority, nil
}

// ResetOutcomeAnalysisTestedNonInferiority resets all changes to the "outcome_analysis_tested_non_inferiority" field.
func (m *OutcomeAnalysisMutation) ResetOutcomeAnalysisTestedNonInferiority() {
	m.outcome_analysis_tested_non_inferiority = nil
}

// SetOutcomeAnalysisNonInferiorityType sets the "outcome_analysis_non_inferiority_type" field.
func (m *OutcomeAnalysisMutation) SetOutcomeAnalysisNonInferiorityType(s string) {
	m.outcome_analysis_non_inferiority_type = &s
}

// OutcomeAnalysisNonInferiorityType returns the value of the "outcome_analysis_non_inferiority_type" field in the mutation.
func (m *OutcomeAnalysisMutation) OutcomeAnalysisNonInferiorityType() (r string, exists bool) {
	v := m.outcome_analysis_non_inferiority_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeAnalysisNonInferiorityType returns the old "outcome_analysis_non_inferiority_type" field's value of the OutcomeAnalysis entity.
// If the OutcomeAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeAnalysisMutation) OldOutcomeAnalysisNonInferiorityType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeAnalysisNonInferiorityType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeAnalysisNonInferiorityType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeAnalysisNonInferiorityType: %w", err)
	}
	return oldValue.OutcomeAnalysisNonInferiorityType, nil
}

// ResetOutcomeAnalysisNonInferiorityType resets all changes to the "outcome_analysis_non_inferiority_type" field.
func (m *OutcomeAnalysisMutation) ResetOutcomeAnalysisNonInferiorityType() {
	m.outcome_analysis_non_inferiority_type = nil
}

// SetOutcomeAnalysisNonInferiorityComment sets the "outcome_analysis_non_inferiority_comment" field.
func (m *OutcomeAnalysisMutation) SetOutcomeAnalysisNonInferiorityComment(s string) {
	m.outcome_analysis_non_inferiority_comment = &s
}

// OutcomeAnalysisNonInferiorityComment returns the value of the "outcome_analysis_non_inferiority_comment" field in the mutation.
func (m *OutcomeAnalysisMutation) OutcomeAnalysisNonInferiorityComment() (r string, exists bool) {
	v := m.outcome_analysis_non_inferiority_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeAnalysisNonInferiorityComment returns the old "outcome_analysis_non_inferiority_comment" field's value of the OutcomeAnalysis entity.
// If the OutcomeAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeAnalysisMutation) OldOutcomeAnalysisNonInferiorityComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeAnalysisNonInferiorityComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeAnalysisNonInferiorityComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeAnalysisNonInferiorityComment: %w", err)
	}
	return oldValue.OutcomeAnalysisNonInferiorityComment, nil
}

// ResetOutcomeAnalysisNonInferiorityComment resets all changes to the "outcome_analysis_non_inferiority_comment" field.
func (m *OutcomeAnalysisMutation) ResetOutcomeAnalysisNonInferiorityComment() {
	m.outcome_analysis_non_inferiority_comment = nil
}

// SetOutcomeAnalysisPValue sets the "outcome_analysis_p_value" field.
func (m *OutcomeAnalysisMutation) SetOutcomeAnalysisPValue(s string) {
	m.outcome_analysis_p_value = &s
}

// OutcomeAnalysisPValue returns the value of the "outcome_analysis_p_value" field in the mutation.
func (m *OutcomeAnalysisMutation) OutcomeAnalysisPValue() (r string, exists bool) {
	v := m.outcome_analysis_p_value
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeAnalysisPValue returns the old "outcome_analysis_p_value" field's value of the OutcomeAnalysis entity.
// If the OutcomeAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeAnalysisMutation) OldOutcomeAnalysisPValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeAnalysisPValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeAnalysisPValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeAnalysisPValue: %w", err)
	}
	return oldValue.OutcomeAnalysisPValue, nil
}

// ResetOutcomeAnalysisPValue resets all changes to the "outcome_analysis_p_value" field.
func (m *OutcomeAnalysisMutation) ResetOutcomeAnalysisPValue() {
	m.outcome_analysis_p_value = nil
}

// SetOutcomeAnalysisPValueComment sets the "outcome_analysis_p_value_comment" field.
func (m *OutcomeAnalysisMutation) SetOutcomeAnalysisPValueComment(s string) {
	m.outcome_analysis_p_value_comment = &s
}

// OutcomeAnalysisPValueComment returns the value of the "outcome_analysis_p_value_comment" field in the mutation.
func (m *OutcomeAnalysisMutation) OutcomeAnalysisPValueComment() (r string, exists bool) {
	v := m.outcome_analysis_p_value_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeAnalysisPValueComment returns the old "outcome_analysis_p_value_comment" field's value of the OutcomeAnalysis entity.
// If the OutcomeAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeAnalysisMutation) OldOutcomeAnalysisPValueComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeAnalysisPValueComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeAnalysisPValueComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeAnalysisPValueComment: %w", err)
	}
	return oldValue.OutcomeAnalysisPValueComment, nil
}

// ResetOutcomeAnalysisPValueComment resets all changes to the "outcome_analysis_p_value_comment" field.
func (m *OutcomeAnalysisMutation) ResetOutcomeAnalysisPValueComment() {
	m.outcome_analysis_p_value_comment = nil
}

// SetOutcomeAnalysisStatisticalMethod sets the "outcome_analysis_statistical_method" field.
func (m *OutcomeAnalysisMutation) SetOutcomeAnalysisStatisticalMethod(s string) {
	m.outcome_analysis_statistical_method = &s
}

// OutcomeAnalysisStatisticalMethod returns the value of the "outcome_analysis_statistical_method" field in the mutation.
func (m *OutcomeAnalysisMutation) OutcomeAnalysisStatisticalMethod() (r string, exists bool) {
	v := m.outcome_analysis_statistical_method
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeAnalysisStatisticalMethod returns the old "outcome_analysis_statistical_method" field's value of the OutcomeAnalysis entity.
// If the OutcomeAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeAnalysisMutation) OldOutcomeAnalysisStatisticalMethod(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeAnalysisStatisticalMethod is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeAnalysisStatisticalMethod requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeAnalysisStatisticalMethod: %w", err)
	}
	return oldValue.OutcomeAnalysisStatisticalMethod, nil
}

// ResetOutcomeAnalysisStatisticalMethod resets all changes to the "outcome_analysis_statistical_method" field.
func (m *OutcomeAnalysisMutation) ResetOutcomeAnalysisStatisticalMethod() {
	m.outcome_analysis_statistical_method = nil
}

// SetOutcomeAnalysisStatisticalComment sets the "outcome_analysis_statistical_comment" field.
func (m *OutcomeAnalysisMutation) SetOutcomeAnalysisStatisticalComment(s string) {
	m.outcome_analysis_statistical_comment = &s
}

// OutcomeAnalysisStatisticalComment returns the value of the "outcome_analysis_statistical_comment" field in the mutation.
func (m *OutcomeAnalysisMutation) OutcomeAnalysisStatisticalComment() (r string, exists bool) {
	v := m.outcome_analysis_statistical_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeAnalysisStatisticalComment returns the old "outcome_analysis_statistical_comment" field's value of the OutcomeAnalysis entity.
// If the OutcomeAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeAnalysisMutation) OldOutcomeAnalysisStatisticalComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeAnalysisStatisticalComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeAnalysisStatisticalComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeAnalysisStatisticalComment: %w", err)
	}
	return oldValue.OutcomeAnalysisStatisticalComment, nil
}

// ResetOutcomeAnalysisStatisticalComment resets all changes to the "outcome_analysis_statistical_comment" field.
func (m *OutcomeAnalysisMutation) ResetOutcomeAnalysisStatisticalComment() {
	m.outcome_analysis_statistical_comment = nil
}

// SetOutcomeAnalysisParamType sets the "outcome_analysis_param_type" field.
func (m *OutcomeAnalysisMutation) SetOutcomeAnalysisParamType(s string) {
	m.outcome_analysis_param_type = &s
}

// OutcomeAnalysisParamType returns the value of the "outcome_analysis_param_type" field in the mutation.
func (m *OutcomeAnalysisMutation) OutcomeAnalysisParamType() (r string, exists bool) {
	v := m.outcome_analysis_param_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeAnalysisParamType returns the old "outcome_analysis_param_type" field's value of the OutcomeAnalysis entity.
// If the OutcomeAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeAnalysisMutation) OldOutcomeAnalysisParamType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeAnalysisParamType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeAnalysisParamType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeAnalysisParamType: %w", err)
	}
	return oldValue.OutcomeAnalysisParamType, nil
}

// ResetOutcomeAnalysisParamType resets all changes to the "outcome_analysis_param_type" field.
func (m *OutcomeAnalysisMutation) ResetOutcomeAnalysisParamType() {
	m.outcome_analysis_param_type = nil
}

// SetOutcomeAnalysisParamValue sets the "outcome_analysis_param_value" field.
func (m *OutcomeAnalysisMutation) SetOutcomeAnalysisParamValue(s string) {
	m.outcome_analysis_param_value = &s
}

// OutcomeAnalysisParamValue returns the value of the "outcome_analysis_param_value" field in the mutation.
func (m *OutcomeAnalysisMutation) OutcomeAnalysisParamValue() (r string, exists bool) {
	v := m.outcome_analysis_param_value
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeAnalysisParamValue returns the old "outcome_analysis_param_value" field's value of the OutcomeAnalysis entity.
// If the OutcomeAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeAnalysisMutation) OldOutcomeAnalysisParamValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeAnalysisParamValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeAnalysisParamValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeAnalysisParamValue: %w", err)
	}
	return oldValue.OutcomeAnalysisParamValue, nil
}

// ResetOutcomeAnalysisParamValue resets all changes to the "outcome_analysis_param_value" field.
func (m *OutcomeAnalysisMutation) ResetOutcomeAnalysisParamValue() {
	m.outcome_analysis_param_value = nil
}

// SetOutcomeAnalysisCiPctValue sets the "outcome_analysis_ci_pct_value" field.
func (m *OutcomeAnalysisMutation) SetOutcomeAnalysisCiPctValue(s string) {
	m.outcome_analysis_ci_pct_value = &s
}

// OutcomeAnalysisCiPctValue returns the value of the "outcome_analysis_ci_pct_value" field in the mutation.
func (m *OutcomeAnalysisMutation) OutcomeAnalysisCiPctValue() (r string, exists bool) {
	v := m.outcome_analysis_ci_pct_value
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeAnalysisCiPctValue returns the old "outcome_analysis_ci_pct_value" field's value of the OutcomeAnalysis entity.
// If the OutcomeAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeAnalysisMutation) OldOutcomeAnalysisCiPctValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeAnalysisCiPctValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeAnalysisCiPctValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeAnalysisCiPctValue: %w", err)
	}
	return oldValue.OutcomeAnalysisCiPctValue, nil
}

// ResetOutcomeAnalysisCiPctValue resets all changes to the "outcome_analysis_ci_pct_value" field.
func (m *OutcomeAnalysisMutation) ResetOutcomeAnalysisCiPctValue() {
	m.outcome_analysis_ci_pct_value = nil
}

// SetOutcomeAnalysisCiNumSides sets the "outcome_analysis_ci_num_sides" field.
func (m *OutcomeAnalysisMutation) SetOutcomeAnalysisCiNumSides(s string) {
	m.outcome_analysis_ci_num_sides = &s
}

// OutcomeAnalysisCiNumSides returns the value of the "outcome_analysis_ci_num_sides" field in the mutation.
func (m *OutcomeAnalysisMutation) OutcomeAnalysisCiNumSides() (r string, exists bool) {
	v := m.outcome_analysis_ci_num_sides
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeAnalysisCiNumSides returns the old "outcome_analysis_ci_num_sides" field's value of the OutcomeAnalysis entity.
// If the OutcomeAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeAnalysisMutation) OldOutcomeAnalysisCiNumSides(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeAnalysisCiNumSides is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeAnalysisCiNumSides requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeAnalysisCiNumSides: %w", err)
	}
	return oldValue.OutcomeAnalysisCiNumSides, nil
}

// ResetOutcomeAnalysisCiNumSides resets all changes to the "outcome_analysis_ci_num_sides" field.
func (m *OutcomeAnalysisMutation) ResetOutcomeAnalysisCiNumSides() {
	m.outcome_analysis_ci_num_sides = nil
}

// SetOutcomeAnalysisCiLowerLimit sets the "outcome_analysis_ci_lower_limit" field.
func (m *OutcomeAnalysisMutation) SetOutcomeAnalysisCiLowerLimit(s string) {
	m.outcome_analysis_ci_lower_limit = &s
}

// OutcomeAnalysisCiLowerLimit returns the value of the "outcome_analysis_ci_lower_limit" field in the mutation.
func (m *OutcomeAnalysisMutation) OutcomeAnalysisCiLowerLimit() (r string, exists bool) {
	v := m.outcome_analysis_ci_lower_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeAnalysisCiLowerLimit returns the old "outcome_analysis_ci_lower_limit" field's value of the OutcomeAnalysis entity.
// If the OutcomeAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeAnalysisMutation) OldOutcomeAnalysisCiLowerLimit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeAnalysisCiLowerLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeAnalysisCiLowerLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeAnalysisCiLowerLimit: %w", err)
	}
	return oldValue.OutcomeAnalysisCiLowerLimit, nil
}

// ResetOutcomeAnalysisCiLowerLimit resets all changes to the "outcome_analysis_ci_lower_limit" field.
func (m *OutcomeAnalysisMutation) ResetOutcomeAnalysisCiLowerLimit() {
	m.outcome_analysis_ci_lower_limit = nil
}

// SetOutcomeAnalysisCiUpperLimit sets the "outcome_analysis_ci_upper_limit" field.
func (m *OutcomeAnalysisMutation) SetOutcomeAnalysisCiUpperLimit(s string) {
	m.outcome_analysis_ci_upper_limit = &s
}

// OutcomeAnalysisCiUpperLimit returns the value of the "outcome_analysis_ci_upper_limit" field in the mutation.
func (m *OutcomeAnalysisMutation) OutcomeAnalysisCiUpperLimit() (r string, exists bool) {
	v := m.outcome_analysis_ci_upper_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeAnalysisCiUpperLimit returns the old "outcome_analysis_ci_upper_limit" field's value of the OutcomeAnalysis entity.
// If the OutcomeAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeAnalysisMutation) OldOutcomeAnalysisCiUpperLimit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeAnalysisCiUpperLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeAnalysisCiUpperLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeAnalysisCiUpperLimit: %w", err)
	}
	return oldValue.OutcomeAnalysisCiUpperLimit, nil
}

// ResetOutcomeAnalysisCiUpperLimit resets all changes to the "outcome_analysis_ci_upper_limit" field.
func (m *OutcomeAnalysisMutation) ResetOutcomeAnalysisCiUpperLimit() {
	m.outcome_analysis_ci_upper_limit = nil
}

// SetOutcomeAnalysisCiLowerLimitComment sets the "outcome_analysis_ci_lower_limit_comment" field.
func (m *OutcomeAnalysisMutation) SetOutcomeAnalysisCiLowerLimitComment(s string) {
	m.outcome_analysis_ci_lower_limit_comment = &s
}

// OutcomeAnalysisCiLowerLimitComment returns the value of the "outcome_analysis_ci_lower_limit_comment" field in the mutation.
func (m *OutcomeAnalysisMutation) OutcomeAnalysisCiLowerLimitComment() (r string, exists bool) {
	v := m.outcome_analysis_ci_lower_limit_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeAnalysisCiLowerLimitComment returns the old "outcome_analysis_ci_lower_limit_comment" field's value of the OutcomeAnalysis entity.
// If the OutcomeAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeAnalysisMutation) OldOutcomeAnalysisCiLowerLimitComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeAnalysisCiLowerLimitComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeAnalysisCiLowerLimitComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeAnalysisCiLowerLimitComment: %w", err)
	}
	return oldValue.OutcomeAnalysisCiLowerLimitComment, nil
}

// ResetOutcomeAnalysisCiLowerLimitComment resets all changes to the "outcome_analysis_ci_lower_limit_comment" field.
func (m *OutcomeAnalysisMutation) ResetOutcomeAnalysisCiLowerLimitComment() {
	m.outcome_analysis_ci_lower_limit_comment = nil
}

// SetOutcomeAnalysisCiUpperLimitComment sets the "outcome_analysis_ci_upper_limit_comment" field.
func (m *OutcomeAnalysisMutation) SetOutcomeAnalysisCiUpperLimitComment(s string) {
	m.outcome_analysis_ci_upper_limit_comment = &s
}

// OutcomeAnalysisCiUpperLimitComment returns the value of the "outcome_analysis_ci_upper_limit_comment" field in the mutation.
func (m *OutcomeAnalysisMutation) OutcomeAnalysisCiUpperLimitComment() (r string, exists bool) {
	v := m.outcome_analysis_ci_upper_limit_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeAnalysisCiUpperLimitComment returns the old "outcome_analysis_ci_upper_limit_comment" field's value of the OutcomeAnalysis entity.
// If the OutcomeAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeAnalysisMutation) OldOutcomeAnalysisCiUpperLimitComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeAnalysisCiUpperLimitComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeAnalysisCiUpperLimitComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeAnalysisCiUpperLimitComment: %w", err)
	}
	return oldValue.OutcomeAnalysisCiUpperLimitComment, nil
}

// ResetOutcomeAnalysisCiUpperLimitComment resets all changes to the "outcome_analysis_ci_upper_limit_comment" field.
func (m *OutcomeAnalysisMutation) ResetOutcomeAnalysisCiUpperLimitComment() {
	m.outcome_analysis_ci_upper_limit_comment = nil
}

// SetOutcomeAnalysisDispersionType sets the "outcome_analysis_dispersion_type" field.
func (m *OutcomeAnalysisMutation) SetOutcomeAnalysisDispersionType(s string) {
	m.outcome_analysis_dispersion_type = &s
}

// OutcomeAnalysisDispersionType returns the value of the "outcome_analysis_dispersion_type" field in the mutation.
func (m *OutcomeAnalysisMutation) OutcomeAnalysisDispersionType() (r string, exists bool) {
	v := m.outcome_analysis_dispersion_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeAnalysisDispersionType returns the old "outcome_analysis_dispersion_type" field's value of the OutcomeAnalysis entity.
// If the OutcomeAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeAnalysisMutation) OldOutcomeAnalysisDispersionType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeAnalysisDispersionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeAnalysisDispersionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeAnalysisDispersionType: %w", err)
	}
	return oldValue.OutcomeAnalysisDispersionType, nil
}

// ResetOutcomeAnalysisDispersionType resets all changes to the "outcome_analysis_dispersion_type" field.
func (m *OutcomeAnalysisMutation) ResetOutcomeAnalysisDispersionType() {
	m.outcome_analysis_dispersion_type = nil
}

// SetOutcomeAnalysisDispersionValue sets the "outcome_analysis_dispersion_value" field.
func (m *OutcomeAnalysisMutation) SetOutcomeAnalysisDispersionValue(s string) {
	m.outcome_analysis_dispersion_value = &s
}

// OutcomeAnalysisDispersionValue returns the value of the "outcome_analysis_dispersion_value" field in the mutation.
func (m *OutcomeAnalysisMutation) OutcomeAnalysisDispersionValue() (r string, exists bool) {
	v := m.outcome_analysis_dispersion_value
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeAnalysisDispersionValue returns the old "outcome_analysis_dispersion_value" field's value of the OutcomeAnalysis entity.
// If the OutcomeAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeAnalysisMutation) OldOutcomeAnalysisDispersionValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeAnalysisDispersionValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeAnalysisDispersionValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeAnalysisDispersionValue: %w", err)
	}
	return oldValue.OutcomeAnalysisDispersionValue, nil
}

// ResetOutcomeAnalysisDispersionValue resets all changes to the "outcome_analysis_dispersion_value" field.
func (m *OutcomeAnalysisMutation) ResetOutcomeAnalysisDispersionValue() {
	m.outcome_analysis_dispersion_value = nil
}

// SetOutcomeAnalysisEstimateComment sets the "outcome_analysis_estimate_comment" field.
func (m *OutcomeAnalysisMutation) SetOutcomeAnalysisEstimateComment(s string) {
	m.outcome_analysis_estimate_comment = &s
}

// OutcomeAnalysisEstimateComment returns the value of the "outcome_analysis_estimate_comment" field in the mutation.
func (m *OutcomeAnalysisMutation) OutcomeAnalysisEstimateComment() (r string, exists bool) {
	v := m.outcome_analysis_estimate_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeAnalysisEstimateComment returns the old "outcome_analysis_estimate_comment" field's value of the OutcomeAnalysis entity.
// If the OutcomeAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeAnalysisMutation) OldOutcomeAnalysisEstimateComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeAnalysisEstimateComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeAnalysisEstimateComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeAnalysisEstimateComment: %w", err)
	}
	return oldValue.OutcomeAnalysisEstimateComment, nil
}

// ResetOutcomeAnalysisEstimateComment resets all changes to the "outcome_analysis_estimate_comment" field.
func (m *OutcomeAnalysisMutation) ResetOutcomeAnalysisEstimateComment() {
	m.outcome_analysis_estimate_comment = nil
}

// SetOutcomeAnalysisOtherAnalysisDescription sets the "outcome_analysis_other_analysis_description" field.
func (m *OutcomeAnalysisMutation) SetOutcomeAnalysisOtherAnalysisDescription(s string) {
	m.outcome_analysis_other_analysis_description = &s
}

// OutcomeAnalysisOtherAnalysisDescription returns the value of the "outcome_analysis_other_analysis_description" field in the mutation.
func (m *OutcomeAnalysisMutation) OutcomeAnalysisOtherAnalysisDescription() (r string, exists bool) {
	v := m.outcome_analysis_other_analysis_description
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeAnalysisOtherAnalysisDescription returns the old "outcome_analysis_other_analysis_description" field's value of the OutcomeAnalysis entity.
// If the OutcomeAnalysis object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeAnalysisMutation) OldOutcomeAnalysisOtherAnalysisDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeAnalysisOtherAnalysisDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeAnalysisOtherAnalysisDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeAnalysisOtherAnalysisDescription: %w", err)
	}
	return oldValue.OutcomeAnalysisOtherAnalysisDescription, nil
}

// ResetOutcomeAnalysisOtherAnalysisDescription resets all changes to the "outcome_analysis_other_analysis_description" field.
func (m *OutcomeAnalysisMutation) ResetOutcomeAnalysisOtherAnalysisDescription() {
	m.outcome_analysis_other_analysis_description = nil
}

// SetParentID sets the "parent" edge to the OutcomeMeasure entity by id.
func (m *OutcomeAnalysisMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the OutcomeMeasure entity.
func (m *OutcomeAnalysisMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the OutcomeMeasure entity was cleared.
func (m *OutcomeAnalysisMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *OutcomeAnalysisMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *OutcomeAnalysisMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *OutcomeAnalysisMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddOutcomeAnalysisGroupIDListIDs adds the "outcome_analysis_group_id_list" edge to the OutcomeAnalysisGroupID entity by ids.
func (m *OutcomeAnalysisMutation) AddOutcomeAnalysisGroupIDListIDs(ids ...int) {
	if m.outcome_analysis_group_id_list == nil {
		m.outcome_analysis_group_id_list = make(map[int]struct{})
	}
	for i := range ids {
		m.outcome_analysis_group_id_list[ids[i]] = struct{}{}
	}
}

// ClearOutcomeAnalysisGroupIDList clears the "outcome_analysis_group_id_list" edge to the OutcomeAnalysisGroupID entity.
func (m *OutcomeAnalysisMutation) ClearOutcomeAnalysisGroupIDList() {
	m.clearedoutcome_analysis_group_id_list = true
}

// OutcomeAnalysisGroupIDListCleared reports if the "outcome_analysis_group_id_list" edge to the OutcomeAnalysisGroupID entity was cleared.
func (m *OutcomeAnalysisMutation) OutcomeAnalysisGroupIDListCleared() bool {
	return m.clearedoutcome_analysis_group_id_list
}

// RemoveOutcomeAnalysisGroupIDListIDs removes the "outcome_analysis_group_id_list" edge to the OutcomeAnalysisGroupID entity by IDs.
func (m *OutcomeAnalysisMutation) RemoveOutcomeAnalysisGroupIDListIDs(ids ...int) {
	if m.removedoutcome_analysis_group_id_list == nil {
		m.removedoutcome_analysis_group_id_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.outcome_analysis_group_id_list, ids[i])
		m.removedoutcome_analysis_group_id_list[ids[i]] = struct{}{}
	}
}

// RemovedOutcomeAnalysisGroupIDList returns the removed IDs of the "outcome_analysis_group_id_list" edge to the OutcomeAnalysisGroupID entity.
func (m *OutcomeAnalysisMutation) RemovedOutcomeAnalysisGroupIDListIDs() (ids []int) {
	for id := range m.removedoutcome_analysis_group_id_list {
		ids = append(ids, id)
	}
	return
}

// OutcomeAnalysisGroupIDListIDs returns the "outcome_analysis_group_id_list" edge IDs in the mutation.
func (m *OutcomeAnalysisMutation) OutcomeAnalysisGroupIDListIDs() (ids []int) {
	for id := range m.outcome_analysis_group_id_list {
		ids = append(ids, id)
	}
	return
}

// ResetOutcomeAnalysisGroupIDList resets all changes to the "outcome_analysis_group_id_list" edge.
func (m *OutcomeAnalysisMutation) ResetOutcomeAnalysisGroupIDList() {
	m.outcome_analysis_group_id_list = nil
	m.clearedoutcome_analysis_group_id_list = false
	m.removedoutcome_analysis_group_id_list = nil
}

// Where appends a list predicates to the OutcomeAnalysisMutation builder.
func (m *OutcomeAnalysisMutation) Where(ps ...predicate.OutcomeAnalysis) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OutcomeAnalysisMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OutcomeAnalysis).
func (m *OutcomeAnalysisMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OutcomeAnalysisMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.outcome_analysis_group_description != nil {
		fields = append(fields, outcomeanalysis.FieldOutcomeAnalysisGroupDescription)
	}
	if m.outcome_analysis_tested_non_inferiority != nil {
		fields = append(fields, outcomeanalysis.FieldOutcomeAnalysisTestedNonInferiority)
	}
	if m.outcome_analysis_non_inferiority_type != nil {
		fields = append(fields, outcomeanalysis.FieldOutcomeAnalysisNonInferiorityType)
	}
	if m.outcome_analysis_non_inferiority_comment != nil {
		fields = append(fields, outcomeanalysis.FieldOutcomeAnalysisNonInferiorityComment)
	}
	if m.outcome_analysis_p_value != nil {
		fields = append(fields, outcomeanalysis.FieldOutcomeAnalysisPValue)
	}
	if m.outcome_analysis_p_value_comment != nil {
		fields = append(fields, outcomeanalysis.FieldOutcomeAnalysisPValueComment)
	}
	if m.outcome_analysis_statistical_method != nil {
		fields = append(fields, outcomeanalysis.FieldOutcomeAnalysisStatisticalMethod)
	}
	if m.outcome_analysis_statistical_comment != nil {
		fields = append(fields, outcomeanalysis.FieldOutcomeAnalysisStatisticalComment)
	}
	if m.outcome_analysis_param_type != nil {
		fields = append(fields, outcomeanalysis.FieldOutcomeAnalysisParamType)
	}
	if m.outcome_analysis_param_value != nil {
		fields = append(fields, outcomeanalysis.FieldOutcomeAnalysisParamValue)
	}
	if m.outcome_analysis_ci_pct_value != nil {
		fields = append(fields, outcomeanalysis.FieldOutcomeAnalysisCiPctValue)
	}
	if m.outcome_analysis_ci_num_sides != nil {
		fields = append(fields, outcomeanalysis.FieldOutcomeAnalysisCiNumSides)
	}
	if m.outcome_analysis_ci_lower_limit != nil {
		fields = append(fields, outcomeanalysis.FieldOutcomeAnalysisCiLowerLimit)
	}
	if m.outcome_analysis_ci_upper_limit != nil {
		fields = append(fields, outcomeanalysis.FieldOutcomeAnalysisCiUpperLimit)
	}
	if m.outcome_analysis_ci_lower_limit_comment != nil {
		fields = append(fields, outcomeanalysis.FieldOutcomeAnalysisCiLowerLimitComment)
	}
	if m.outcome_analysis_ci_upper_limit_comment != nil {
		fields = append(fields, outcomeanalysis.FieldOutcomeAnalysisCiUpperLimitComment)
	}
	if m.outcome_analysis_dispersion_type != nil {
		fields = append(fields, outcomeanalysis.FieldOutcomeAnalysisDispersionType)
	}
	if m.outcome_analysis_dispersion_value != nil {
		fields = append(fields, outcomeanalysis.FieldOutcomeAnalysisDispersionValue)
	}
	if m.outcome_analysis_estimate_comment != nil {
		fields = append(fields, outcomeanalysis.FieldOutcomeAnalysisEstimateComment)
	}
	if m.outcome_analysis_other_analysis_description != nil {
		fields = append(fields, outcomeanalysis.FieldOutcomeAnalysisOtherAnalysisDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OutcomeAnalysisMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case outcomeanalysis.FieldOutcomeAnalysisGroupDescription:
		return m.OutcomeAnalysisGroupDescription()
	case outcomeanalysis.FieldOutcomeAnalysisTestedNonInferiority:
		return m.OutcomeAnalysisTestedNonInferiority()
	case outcomeanalysis.FieldOutcomeAnalysisNonInferiorityType:
		return m.OutcomeAnalysisNonInferiorityType()
	case outcomeanalysis.FieldOutcomeAnalysisNonInferiorityComment:
		return m.OutcomeAnalysisNonInferiorityComment()
	case outcomeanalysis.FieldOutcomeAnalysisPValue:
		return m.OutcomeAnalysisPValue()
	case outcomeanalysis.FieldOutcomeAnalysisPValueComment:
		return m.OutcomeAnalysisPValueComment()
	case outcomeanalysis.FieldOutcomeAnalysisStatisticalMethod:
		return m.OutcomeAnalysisStatisticalMethod()
	case outcomeanalysis.FieldOutcomeAnalysisStatisticalComment:
		return m.OutcomeAnalysisStatisticalComment()
	case outcomeanalysis.FieldOutcomeAnalysisParamType:
		return m.OutcomeAnalysisParamType()
	case outcomeanalysis.FieldOutcomeAnalysisParamValue:
		return m.OutcomeAnalysisParamValue()
	case outcomeanalysis.FieldOutcomeAnalysisCiPctValue:
		return m.OutcomeAnalysisCiPctValue()
	case outcomeanalysis.FieldOutcomeAnalysisCiNumSides:
		return m.OutcomeAnalysisCiNumSides()
	case outcomeanalysis.FieldOutcomeAnalysisCiLowerLimit:
		return m.OutcomeAnalysisCiLowerLimit()
	case outcomeanalysis.FieldOutcomeAnalysisCiUpperLimit:
		return m.OutcomeAnalysisCiUpperLimit()
	case outcomeanalysis.FieldOutcomeAnalysisCiLowerLimitComment:
		return m.OutcomeAnalysisCiLowerLimitComment()
	case outcomeanalysis.FieldOutcomeAnalysisCiUpperLimitComment:
		return m.OutcomeAnalysisCiUpperLimitComment()
	case outcomeanalysis.FieldOutcomeAnalysisDispersionType:
		return m.OutcomeAnalysisDispersionType()
	case outcomeanalysis.FieldOutcomeAnalysisDispersionValue:
		return m.OutcomeAnalysisDispersionValue()
	case outcomeanalysis.FieldOutcomeAnalysisEstimateComment:
		return m.OutcomeAnalysisEstimateComment()
	case outcomeanalysis.FieldOutcomeAnalysisOtherAnalysisDescription:
		return m.OutcomeAnalysisOtherAnalysisDescription()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OutcomeAnalysisMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case outcomeanalysis.FieldOutcomeAnalysisGroupDescription:
		return m.OldOutcomeAnalysisGroupDescription(ctx)
	case outcomeanalysis.FieldOutcomeAnalysisTestedNonInferiority:
		return m.OldOutcomeAnalysisTestedNonInferiority(ctx)
	case outcomeanalysis.FieldOutcomeAnalysisNonInferiorityType:
		return m.OldOutcomeAnalysisNonInferiorityType(ctx)
	case outcomeanalysis.FieldOutcomeAnalysisNonInferiorityComment:
		return m.OldOutcomeAnalysisNonInferiorityComment(ctx)
	case outcomeanalysis.FieldOutcomeAnalysisPValue:
		return m.OldOutcomeAnalysisPValue(ctx)
	case outcomeanalysis.FieldOutcomeAnalysisPValueComment:
		return m.OldOutcomeAnalysisPValueComment(ctx)
	case outcomeanalysis.FieldOutcomeAnalysisStatisticalMethod:
		return m.OldOutcomeAnalysisStatisticalMethod(ctx)
	case outcomeanalysis.FieldOutcomeAnalysisStatisticalComment:
		return m.OldOutcomeAnalysisStatisticalComment(ctx)
	case outcomeanalysis.FieldOutcomeAnalysisParamType:
		return m.OldOutcomeAnalysisParamType(ctx)
	case outcomeanalysis.FieldOutcomeAnalysisParamValue:
		return m.OldOutcomeAnalysisParamValue(ctx)
	case outcomeanalysis.FieldOutcomeAnalysisCiPctValue:
		return m.OldOutcomeAnalysisCiPctValue(ctx)
	case outcomeanalysis.FieldOutcomeAnalysisCiNumSides:
		return m.OldOutcomeAnalysisCiNumSides(ctx)
	case outcomeanalysis.FieldOutcomeAnalysisCiLowerLimit:
		return m.OldOutcomeAnalysisCiLowerLimit(ctx)
	case outcomeanalysis.FieldOutcomeAnalysisCiUpperLimit:
		return m.OldOutcomeAnalysisCiUpperLimit(ctx)
	case outcomeanalysis.FieldOutcomeAnalysisCiLowerLimitComment:
		return m.OldOutcomeAnalysisCiLowerLimitComment(ctx)
	case outcomeanalysis.FieldOutcomeAnalysisCiUpperLimitComment:
		return m.OldOutcomeAnalysisCiUpperLimitComment(ctx)
	case outcomeanalysis.FieldOutcomeAnalysisDispersionType:
		return m.OldOutcomeAnalysisDispersionType(ctx)
	case outcomeanalysis.FieldOutcomeAnalysisDispersionValue:
		return m.OldOutcomeAnalysisDispersionValue(ctx)
	case outcomeanalysis.FieldOutcomeAnalysisEstimateComment:
		return m.OldOutcomeAnalysisEstimateComment(ctx)
	case outcomeanalysis.FieldOutcomeAnalysisOtherAnalysisDescription:
		return m.OldOutcomeAnalysisOtherAnalysisDescription(ctx)
	}
	return nil, fmt.Errorf("unknown OutcomeAnalysis field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutcomeAnalysisMutation) SetField(name string, value ent.Value) error {
	switch name {
	case outcomeanalysis.FieldOutcomeAnalysisGroupDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeAnalysisGroupDescription(v)
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisTestedNonInferiority:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeAnalysisTestedNonInferiority(v)
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisNonInferiorityType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeAnalysisNonInferiorityType(v)
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisNonInferiorityComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeAnalysisNonInferiorityComment(v)
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisPValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeAnalysisPValue(v)
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisPValueComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeAnalysisPValueComment(v)
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisStatisticalMethod:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeAnalysisStatisticalMethod(v)
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisStatisticalComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeAnalysisStatisticalComment(v)
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisParamType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeAnalysisParamType(v)
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisParamValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeAnalysisParamValue(v)
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisCiPctValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeAnalysisCiPctValue(v)
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisCiNumSides:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeAnalysisCiNumSides(v)
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisCiLowerLimit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeAnalysisCiLowerLimit(v)
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisCiUpperLimit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeAnalysisCiUpperLimit(v)
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisCiLowerLimitComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeAnalysisCiLowerLimitComment(v)
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisCiUpperLimitComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeAnalysisCiUpperLimitComment(v)
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisDispersionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeAnalysisDispersionType(v)
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisDispersionValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeAnalysisDispersionValue(v)
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisEstimateComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeAnalysisEstimateComment(v)
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisOtherAnalysisDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeAnalysisOtherAnalysisDescription(v)
		return nil
	}
	return fmt.Errorf("unknown OutcomeAnalysis field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OutcomeAnalysisMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OutcomeAnalysisMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutcomeAnalysisMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OutcomeAnalysis numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OutcomeAnalysisMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OutcomeAnalysisMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OutcomeAnalysisMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OutcomeAnalysis nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OutcomeAnalysisMutation) ResetField(name string) error {
	switch name {
	case outcomeanalysis.FieldOutcomeAnalysisGroupDescription:
		m.ResetOutcomeAnalysisGroupDescription()
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisTestedNonInferiority:
		m.ResetOutcomeAnalysisTestedNonInferiority()
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisNonInferiorityType:
		m.ResetOutcomeAnalysisNonInferiorityType()
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisNonInferiorityComment:
		m.ResetOutcomeAnalysisNonInferiorityComment()
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisPValue:
		m.ResetOutcomeAnalysisPValue()
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisPValueComment:
		m.ResetOutcomeAnalysisPValueComment()
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisStatisticalMethod:
		m.ResetOutcomeAnalysisStatisticalMethod()
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisStatisticalComment:
		m.ResetOutcomeAnalysisStatisticalComment()
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisParamType:
		m.ResetOutcomeAnalysisParamType()
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisParamValue:
		m.ResetOutcomeAnalysisParamValue()
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisCiPctValue:
		m.ResetOutcomeAnalysisCiPctValue()
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisCiNumSides:
		m.ResetOutcomeAnalysisCiNumSides()
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisCiLowerLimit:
		m.ResetOutcomeAnalysisCiLowerLimit()
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisCiUpperLimit:
		m.ResetOutcomeAnalysisCiUpperLimit()
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisCiLowerLimitComment:
		m.ResetOutcomeAnalysisCiLowerLimitComment()
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisCiUpperLimitComment:
		m.ResetOutcomeAnalysisCiUpperLimitComment()
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisDispersionType:
		m.ResetOutcomeAnalysisDispersionType()
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisDispersionValue:
		m.ResetOutcomeAnalysisDispersionValue()
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisEstimateComment:
		m.ResetOutcomeAnalysisEstimateComment()
		return nil
	case outcomeanalysis.FieldOutcomeAnalysisOtherAnalysisDescription:
		m.ResetOutcomeAnalysisOtherAnalysisDescription()
		return nil
	}
	return fmt.Errorf("unknown OutcomeAnalysis field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OutcomeAnalysisMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.parent != nil {
		edges = append(edges, outcomeanalysis.EdgeParent)
	}
	if m.outcome_analysis_group_id_list != nil {
		edges = append(edges, outcomeanalysis.EdgeOutcomeAnalysisGroupIDList)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OutcomeAnalysisMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case outcomeanalysis.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case outcomeanalysis.EdgeOutcomeAnalysisGroupIDList:
		ids := make([]ent.Value, 0, len(m.outcome_analysis_group_id_list))
		for id := range m.outcome_analysis_group_id_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OutcomeAnalysisMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedoutcome_analysis_group_id_list != nil {
		edges = append(edges, outcomeanalysis.EdgeOutcomeAnalysisGroupIDList)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OutcomeAnalysisMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case outcomeanalysis.EdgeOutcomeAnalysisGroupIDList:
		ids := make([]ent.Value, 0, len(m.removedoutcome_analysis_group_id_list))
		for id := range m.removedoutcome_analysis_group_id_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OutcomeAnalysisMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedparent {
		edges = append(edges, outcomeanalysis.EdgeParent)
	}
	if m.clearedoutcome_analysis_group_id_list {
		edges = append(edges, outcomeanalysis.EdgeOutcomeAnalysisGroupIDList)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OutcomeAnalysisMutation) EdgeCleared(name string) bool {
	switch name {
	case outcomeanalysis.EdgeParent:
		return m.clearedparent
	case outcomeanalysis.EdgeOutcomeAnalysisGroupIDList:
		return m.clearedoutcome_analysis_group_id_list
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OutcomeAnalysisMutation) ClearEdge(name string) error {
	switch name {
	case outcomeanalysis.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown OutcomeAnalysis unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OutcomeAnalysisMutation) ResetEdge(name string) error {
	switch name {
	case outcomeanalysis.EdgeParent:
		m.ResetParent()
		return nil
	case outcomeanalysis.EdgeOutcomeAnalysisGroupIDList:
		m.ResetOutcomeAnalysisGroupIDList()
		return nil
	}
	return fmt.Errorf("unknown OutcomeAnalysis edge %s", name)
}

// OutcomeAnalysisGroupIDMutation represents an operation that mutates the OutcomeAnalysisGroupID nodes in the graph.
type OutcomeAnalysisGroupIDMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	outcome_analysis_group_id *string
	clearedFields             map[string]struct{}
	parent                    *int
	clearedparent             bool
	done                      bool
	oldValue                  func(context.Context) (*OutcomeAnalysisGroupID, error)
	predicates                []predicate.OutcomeAnalysisGroupID
}

var _ ent.Mutation = (*OutcomeAnalysisGroupIDMutation)(nil)

// outcomeanalysisgroupidOption allows management of the mutation configuration using functional options.
type outcomeanalysisgroupidOption func(*OutcomeAnalysisGroupIDMutation)

// newOutcomeAnalysisGroupIDMutation creates new mutation for the OutcomeAnalysisGroupID entity.
func newOutcomeAnalysisGroupIDMutation(c config, op Op, opts ...outcomeanalysisgroupidOption) *OutcomeAnalysisGroupIDMutation {
	m := &OutcomeAnalysisGroupIDMutation{
		config:        c,
		op:            op,
		typ:           TypeOutcomeAnalysisGroupID,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOutcomeAnalysisGroupIDID sets the ID field of the mutation.
func withOutcomeAnalysisGroupIDID(id int) outcomeanalysisgroupidOption {
	return func(m *OutcomeAnalysisGroupIDMutation) {
		var (
			err   error
			once  sync.Once
			value *OutcomeAnalysisGroupID
		)
		m.oldValue = func(ctx context.Context) (*OutcomeAnalysisGroupID, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OutcomeAnalysisGroupID.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOutcomeAnalysisGroupID sets the old OutcomeAnalysisGroupID of the mutation.
func withOutcomeAnalysisGroupID(node *OutcomeAnalysisGroupID) outcomeanalysisgroupidOption {
	return func(m *OutcomeAnalysisGroupIDMutation) {
		m.oldValue = func(context.Context) (*OutcomeAnalysisGroupID, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OutcomeAnalysisGroupIDMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OutcomeAnalysisGroupIDMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OutcomeAnalysisGroupIDMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OutcomeAnalysisGroupIDMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OutcomeAnalysisGroupID.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOutcomeAnalysisGroupID sets the "outcome_analysis_group_id" field.
func (m *OutcomeAnalysisGroupIDMutation) SetOutcomeAnalysisGroupID(s string) {
	m.outcome_analysis_group_id = &s
}

// OutcomeAnalysisGroupID returns the value of the "outcome_analysis_group_id" field in the mutation.
func (m *OutcomeAnalysisGroupIDMutation) OutcomeAnalysisGroupID() (r string, exists bool) {
	v := m.outcome_analysis_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeAnalysisGroupID returns the old "outcome_analysis_group_id" field's value of the OutcomeAnalysisGroupID entity.
// If the OutcomeAnalysisGroupID object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeAnalysisGroupIDMutation) OldOutcomeAnalysisGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeAnalysisGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeAnalysisGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeAnalysisGroupID: %w", err)
	}
	return oldValue.OutcomeAnalysisGroupID, nil
}

// ResetOutcomeAnalysisGroupID resets all changes to the "outcome_analysis_group_id" field.
func (m *OutcomeAnalysisGroupIDMutation) ResetOutcomeAnalysisGroupID() {
	m.outcome_analysis_group_id = nil
}

// SetParentID sets the "parent" edge to the OutcomeAnalysis entity by id.
func (m *OutcomeAnalysisGroupIDMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the OutcomeAnalysis entity.
func (m *OutcomeAnalysisGroupIDMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the OutcomeAnalysis entity was cleared.
func (m *OutcomeAnalysisGroupIDMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *OutcomeAnalysisGroupIDMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *OutcomeAnalysisGroupIDMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *OutcomeAnalysisGroupIDMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// Where appends a list predicates to the OutcomeAnalysisGroupIDMutation builder.
func (m *OutcomeAnalysisGroupIDMutation) Where(ps ...predicate.OutcomeAnalysisGroupID) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OutcomeAnalysisGroupIDMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OutcomeAnalysisGroupID).
func (m *OutcomeAnalysisGroupIDMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OutcomeAnalysisGroupIDMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.outcome_analysis_group_id != nil {
		fields = append(fields, outcomeanalysisgroupid.FieldOutcomeAnalysisGroupID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OutcomeAnalysisGroupIDMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case outcomeanalysisgroupid.FieldOutcomeAnalysisGroupID:
		return m.OutcomeAnalysisGroupID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OutcomeAnalysisGroupIDMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case outcomeanalysisgroupid.FieldOutcomeAnalysisGroupID:
		return m.OldOutcomeAnalysisGroupID(ctx)
	}
	return nil, fmt.Errorf("unknown OutcomeAnalysisGroupID field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutcomeAnalysisGroupIDMutation) SetField(name string, value ent.Value) error {
	switch name {
	case outcomeanalysisgroupid.FieldOutcomeAnalysisGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeAnalysisGroupID(v)
		return nil
	}
	return fmt.Errorf("unknown OutcomeAnalysisGroupID field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OutcomeAnalysisGroupIDMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OutcomeAnalysisGroupIDMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutcomeAnalysisGroupIDMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OutcomeAnalysisGroupID numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OutcomeAnalysisGroupIDMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OutcomeAnalysisGroupIDMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OutcomeAnalysisGroupIDMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OutcomeAnalysisGroupID nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OutcomeAnalysisGroupIDMutation) ResetField(name string) error {
	switch name {
	case outcomeanalysisgroupid.FieldOutcomeAnalysisGroupID:
		m.ResetOutcomeAnalysisGroupID()
		return nil
	}
	return fmt.Errorf("unknown OutcomeAnalysisGroupID field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OutcomeAnalysisGroupIDMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.parent != nil {
		edges = append(edges, outcomeanalysisgroupid.EdgeParent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OutcomeAnalysisGroupIDMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case outcomeanalysisgroupid.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OutcomeAnalysisGroupIDMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OutcomeAnalysisGroupIDMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OutcomeAnalysisGroupIDMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparent {
		edges = append(edges, outcomeanalysisgroupid.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OutcomeAnalysisGroupIDMutation) EdgeCleared(name string) bool {
	switch name {
	case outcomeanalysisgroupid.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OutcomeAnalysisGroupIDMutation) ClearEdge(name string) error {
	switch name {
	case outcomeanalysisgroupid.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown OutcomeAnalysisGroupID unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OutcomeAnalysisGroupIDMutation) ResetEdge(name string) error {
	switch name {
	case outcomeanalysisgroupid.EdgeParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown OutcomeAnalysisGroupID edge %s", name)
}

// OutcomeCategoryMutation represents an operation that mutates the OutcomeCategory nodes in the graph.
type OutcomeCategoryMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	outcome_category_title          *string
	clearedFields                   map[string]struct{}
	parent                          *int
	clearedparent                   bool
	outcome_measurement_list        map[int]struct{}
	removedoutcome_measurement_list map[int]struct{}
	clearedoutcome_measurement_list bool
	done                            bool
	oldValue                        func(context.Context) (*OutcomeCategory, error)
	predicates                      []predicate.OutcomeCategory
}

var _ ent.Mutation = (*OutcomeCategoryMutation)(nil)

// outcomecategoryOption allows management of the mutation configuration using functional options.
type outcomecategoryOption func(*OutcomeCategoryMutation)

// newOutcomeCategoryMutation creates new mutation for the OutcomeCategory entity.
func newOutcomeCategoryMutation(c config, op Op, opts ...outcomecategoryOption) *OutcomeCategoryMutation {
	m := &OutcomeCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypeOutcomeCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOutcomeCategoryID sets the ID field of the mutation.
func withOutcomeCategoryID(id int) outcomecategoryOption {
	return func(m *OutcomeCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *OutcomeCategory
		)
		m.oldValue = func(ctx context.Context) (*OutcomeCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OutcomeCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOutcomeCategory sets the old OutcomeCategory of the mutation.
func withOutcomeCategory(node *OutcomeCategory) outcomecategoryOption {
	return func(m *OutcomeCategoryMutation) {
		m.oldValue = func(context.Context) (*OutcomeCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OutcomeCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OutcomeCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OutcomeCategoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OutcomeCategoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OutcomeCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOutcomeCategoryTitle sets the "outcome_category_title" field.
func (m *OutcomeCategoryMutation) SetOutcomeCategoryTitle(s string) {
	m.outcome_category_title = &s
}

// OutcomeCategoryTitle returns the value of the "outcome_category_title" field in the mutation.
func (m *OutcomeCategoryMutation) OutcomeCategoryTitle() (r string, exists bool) {
	v := m.outcome_category_title
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeCategoryTitle returns the old "outcome_category_title" field's value of the OutcomeCategory entity.
// If the OutcomeCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeCategoryMutation) OldOutcomeCategoryTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeCategoryTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeCategoryTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeCategoryTitle: %w", err)
	}
	return oldValue.OutcomeCategoryTitle, nil
}

// ResetOutcomeCategoryTitle resets all changes to the "outcome_category_title" field.
func (m *OutcomeCategoryMutation) ResetOutcomeCategoryTitle() {
	m.outcome_category_title = nil
}

// SetParentID sets the "parent" edge to the OutcomeClass entity by id.
func (m *OutcomeCategoryMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the OutcomeClass entity.
func (m *OutcomeCategoryMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the OutcomeClass entity was cleared.
func (m *OutcomeCategoryMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *OutcomeCategoryMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *OutcomeCategoryMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *OutcomeCategoryMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddOutcomeMeasurementListIDs adds the "outcome_measurement_list" edge to the OutcomeMeasurement entity by ids.
func (m *OutcomeCategoryMutation) AddOutcomeMeasurementListIDs(ids ...int) {
	if m.outcome_measurement_list == nil {
		m.outcome_measurement_list = make(map[int]struct{})
	}
	for i := range ids {
		m.outcome_measurement_list[ids[i]] = struct{}{}
	}
}

// ClearOutcomeMeasurementList clears the "outcome_measurement_list" edge to the OutcomeMeasurement entity.
func (m *OutcomeCategoryMutation) ClearOutcomeMeasurementList() {
	m.clearedoutcome_measurement_list = true
}

// OutcomeMeasurementListCleared reports if the "outcome_measurement_list" edge to the OutcomeMeasurement entity was cleared.
func (m *OutcomeCategoryMutation) OutcomeMeasurementListCleared() bool {
	return m.clearedoutcome_measurement_list
}

// RemoveOutcomeMeasurementListIDs removes the "outcome_measurement_list" edge to the OutcomeMeasurement entity by IDs.
func (m *OutcomeCategoryMutation) RemoveOutcomeMeasurementListIDs(ids ...int) {
	if m.removedoutcome_measurement_list == nil {
		m.removedoutcome_measurement_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.outcome_measurement_list, ids[i])
		m.removedoutcome_measurement_list[ids[i]] = struct{}{}
	}
}

// RemovedOutcomeMeasurementList returns the removed IDs of the "outcome_measurement_list" edge to the OutcomeMeasurement entity.
func (m *OutcomeCategoryMutation) RemovedOutcomeMeasurementListIDs() (ids []int) {
	for id := range m.removedoutcome_measurement_list {
		ids = append(ids, id)
	}
	return
}

// OutcomeMeasurementListIDs returns the "outcome_measurement_list" edge IDs in the mutation.
func (m *OutcomeCategoryMutation) OutcomeMeasurementListIDs() (ids []int) {
	for id := range m.outcome_measurement_list {
		ids = append(ids, id)
	}
	return
}

// ResetOutcomeMeasurementList resets all changes to the "outcome_measurement_list" edge.
func (m *OutcomeCategoryMutation) ResetOutcomeMeasurementList() {
	m.outcome_measurement_list = nil
	m.clearedoutcome_measurement_list = false
	m.removedoutcome_measurement_list = nil
}

// Where appends a list predicates to the OutcomeCategoryMutation builder.
func (m *OutcomeCategoryMutation) Where(ps ...predicate.OutcomeCategory) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OutcomeCategoryMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OutcomeCategory).
func (m *OutcomeCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OutcomeCategoryMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.outcome_category_title != nil {
		fields = append(fields, outcomecategory.FieldOutcomeCategoryTitle)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OutcomeCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case outcomecategory.FieldOutcomeCategoryTitle:
		return m.OutcomeCategoryTitle()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OutcomeCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case outcomecategory.FieldOutcomeCategoryTitle:
		return m.OldOutcomeCategoryTitle(ctx)
	}
	return nil, fmt.Errorf("unknown OutcomeCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutcomeCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case outcomecategory.FieldOutcomeCategoryTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeCategoryTitle(v)
		return nil
	}
	return fmt.Errorf("unknown OutcomeCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OutcomeCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OutcomeCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutcomeCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OutcomeCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OutcomeCategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OutcomeCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OutcomeCategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OutcomeCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OutcomeCategoryMutation) ResetField(name string) error {
	switch name {
	case outcomecategory.FieldOutcomeCategoryTitle:
		m.ResetOutcomeCategoryTitle()
		return nil
	}
	return fmt.Errorf("unknown OutcomeCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OutcomeCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.parent != nil {
		edges = append(edges, outcomecategory.EdgeParent)
	}
	if m.outcome_measurement_list != nil {
		edges = append(edges, outcomecategory.EdgeOutcomeMeasurementList)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OutcomeCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case outcomecategory.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case outcomecategory.EdgeOutcomeMeasurementList:
		ids := make([]ent.Value, 0, len(m.outcome_measurement_list))
		for id := range m.outcome_measurement_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OutcomeCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedoutcome_measurement_list != nil {
		edges = append(edges, outcomecategory.EdgeOutcomeMeasurementList)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OutcomeCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case outcomecategory.EdgeOutcomeMeasurementList:
		ids := make([]ent.Value, 0, len(m.removedoutcome_measurement_list))
		for id := range m.removedoutcome_measurement_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OutcomeCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedparent {
		edges = append(edges, outcomecategory.EdgeParent)
	}
	if m.clearedoutcome_measurement_list {
		edges = append(edges, outcomecategory.EdgeOutcomeMeasurementList)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OutcomeCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case outcomecategory.EdgeParent:
		return m.clearedparent
	case outcomecategory.EdgeOutcomeMeasurementList:
		return m.clearedoutcome_measurement_list
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OutcomeCategoryMutation) ClearEdge(name string) error {
	switch name {
	case outcomecategory.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown OutcomeCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OutcomeCategoryMutation) ResetEdge(name string) error {
	switch name {
	case outcomecategory.EdgeParent:
		m.ResetParent()
		return nil
	case outcomecategory.EdgeOutcomeMeasurementList:
		m.ResetOutcomeMeasurementList()
		return nil
	}
	return fmt.Errorf("unknown OutcomeCategory edge %s", name)
}

// OutcomeClassMutation represents an operation that mutates the OutcomeClass nodes in the graph.
type OutcomeClassMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	outcome_class_title             *string
	clearedFields                   map[string]struct{}
	parent                          *int
	clearedparent                   bool
	outcome_class_denom_list        map[int]struct{}
	removedoutcome_class_denom_list map[int]struct{}
	clearedoutcome_class_denom_list bool
	outcome_category_list           map[int]struct{}
	removedoutcome_category_list    map[int]struct{}
	clearedoutcome_category_list    bool
	done                            bool
	oldValue                        func(context.Context) (*OutcomeClass, error)
	predicates                      []predicate.OutcomeClass
}

var _ ent.Mutation = (*OutcomeClassMutation)(nil)

// outcomeclassOption allows management of the mutation configuration using functional options.
type outcomeclassOption func(*OutcomeClassMutation)

// newOutcomeClassMutation creates new mutation for the OutcomeClass entity.
func newOutcomeClassMutation(c config, op Op, opts ...outcomeclassOption) *OutcomeClassMutation {
	m := &OutcomeClassMutation{
		config:        c,
		op:            op,
		typ:           TypeOutcomeClass,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOutcomeClassID sets the ID field of the mutation.
func withOutcomeClassID(id int) outcomeclassOption {
	return func(m *OutcomeClassMutation) {
		var (
			err   error
			once  sync.Once
			value *OutcomeClass
		)
		m.oldValue = func(ctx context.Context) (*OutcomeClass, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OutcomeClass.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOutcomeClass sets the old OutcomeClass of the mutation.
func withOutcomeClass(node *OutcomeClass) outcomeclassOption {
	return func(m *OutcomeClassMutation) {
		m.oldValue = func(context.Context) (*OutcomeClass, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OutcomeClassMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OutcomeClassMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OutcomeClassMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OutcomeClassMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OutcomeClass.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOutcomeClassTitle sets the "outcome_class_title" field.
func (m *OutcomeClassMutation) SetOutcomeClassTitle(s string) {
	m.outcome_class_title = &s
}

// OutcomeClassTitle returns the value of the "outcome_class_title" field in the mutation.
func (m *OutcomeClassMutation) OutcomeClassTitle() (r string, exists bool) {
	v := m.outcome_class_title
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeClassTitle returns the old "outcome_class_title" field's value of the OutcomeClass entity.
// If the OutcomeClass object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeClassMutation) OldOutcomeClassTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeClassTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeClassTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeClassTitle: %w", err)
	}
	return oldValue.OutcomeClassTitle, nil
}

// ResetOutcomeClassTitle resets all changes to the "outcome_class_title" field.
func (m *OutcomeClassMutation) ResetOutcomeClassTitle() {
	m.outcome_class_title = nil
}

// SetParentID sets the "parent" edge to the OutcomeMeasure entity by id.
func (m *OutcomeClassMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the OutcomeMeasure entity.
func (m *OutcomeClassMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the OutcomeMeasure entity was cleared.
func (m *OutcomeClassMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *OutcomeClassMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *OutcomeClassMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *OutcomeClassMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddOutcomeClassDenomListIDs adds the "outcome_class_denom_list" edge to the OutcomeClassDenom entity by ids.
func (m *OutcomeClassMutation) AddOutcomeClassDenomListIDs(ids ...int) {
	if m.outcome_class_denom_list == nil {
		m.outcome_class_denom_list = make(map[int]struct{})
	}
	for i := range ids {
		m.outcome_class_denom_list[ids[i]] = struct{}{}
	}
}

// ClearOutcomeClassDenomList clears the "outcome_class_denom_list" edge to the OutcomeClassDenom entity.
func (m *OutcomeClassMutation) ClearOutcomeClassDenomList() {
	m.clearedoutcome_class_denom_list = true
}

// OutcomeClassDenomListCleared reports if the "outcome_class_denom_list" edge to the OutcomeClassDenom entity was cleared.
func (m *OutcomeClassMutation) OutcomeClassDenomListCleared() bool {
	return m.clearedoutcome_class_denom_list
}

// RemoveOutcomeClassDenomListIDs removes the "outcome_class_denom_list" edge to the OutcomeClassDenom entity by IDs.
func (m *OutcomeClassMutation) RemoveOutcomeClassDenomListIDs(ids ...int) {
	if m.removedoutcome_class_denom_list == nil {
		m.removedoutcome_class_denom_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.outcome_class_denom_list, ids[i])
		m.removedoutcome_class_denom_list[ids[i]] = struct{}{}
	}
}

// RemovedOutcomeClassDenomList returns the removed IDs of the "outcome_class_denom_list" edge to the OutcomeClassDenom entity.
func (m *OutcomeClassMutation) RemovedOutcomeClassDenomListIDs() (ids []int) {
	for id := range m.removedoutcome_class_denom_list {
		ids = append(ids, id)
	}
	return
}

// OutcomeClassDenomListIDs returns the "outcome_class_denom_list" edge IDs in the mutation.
func (m *OutcomeClassMutation) OutcomeClassDenomListIDs() (ids []int) {
	for id := range m.outcome_class_denom_list {
		ids = append(ids, id)
	}
	return
}

// ResetOutcomeClassDenomList resets all changes to the "outcome_class_denom_list" edge.
func (m *OutcomeClassMutation) ResetOutcomeClassDenomList() {
	m.outcome_class_denom_list = nil
	m.clearedoutcome_class_denom_list = false
	m.removedoutcome_class_denom_list = nil
}

// AddOutcomeCategoryListIDs adds the "outcome_category_list" edge to the OutcomeCategory entity by ids.
func (m *OutcomeClassMutation) AddOutcomeCategoryListIDs(ids ...int) {
	if m.outcome_category_list == nil {
		m.outcome_category_list = make(map[int]struct{})
	}
	for i := range ids {
		m.outcome_category_list[ids[i]] = struct{}{}
	}
}

// ClearOutcomeCategoryList clears the "outcome_category_list" edge to the OutcomeCategory entity.
func (m *OutcomeClassMutation) ClearOutcomeCategoryList() {
	m.clearedoutcome_category_list = true
}

// OutcomeCategoryListCleared reports if the "outcome_category_list" edge to the OutcomeCategory entity was cleared.
func (m *OutcomeClassMutation) OutcomeCategoryListCleared() bool {
	return m.clearedoutcome_category_list
}

// RemoveOutcomeCategoryListIDs removes the "outcome_category_list" edge to the OutcomeCategory entity by IDs.
func (m *OutcomeClassMutation) RemoveOutcomeCategoryListIDs(ids ...int) {
	if m.removedoutcome_category_list == nil {
		m.removedoutcome_category_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.outcome_category_list, ids[i])
		m.removedoutcome_category_list[ids[i]] = struct{}{}
	}
}

// RemovedOutcomeCategoryList returns the removed IDs of the "outcome_category_list" edge to the OutcomeCategory entity.
func (m *OutcomeClassMutation) RemovedOutcomeCategoryListIDs() (ids []int) {
	for id := range m.removedoutcome_category_list {
		ids = append(ids, id)
	}
	return
}

// OutcomeCategoryListIDs returns the "outcome_category_list" edge IDs in the mutation.
func (m *OutcomeClassMutation) OutcomeCategoryListIDs() (ids []int) {
	for id := range m.outcome_category_list {
		ids = append(ids, id)
	}
	return
}

// ResetOutcomeCategoryList resets all changes to the "outcome_category_list" edge.
func (m *OutcomeClassMutation) ResetOutcomeCategoryList() {
	m.outcome_category_list = nil
	m.clearedoutcome_category_list = false
	m.removedoutcome_category_list = nil
}

// Where appends a list predicates to the OutcomeClassMutation builder.
func (m *OutcomeClassMutation) Where(ps ...predicate.OutcomeClass) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OutcomeClassMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OutcomeClass).
func (m *OutcomeClassMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OutcomeClassMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.outcome_class_title != nil {
		fields = append(fields, outcomeclass.FieldOutcomeClassTitle)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OutcomeClassMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case outcomeclass.FieldOutcomeClassTitle:
		return m.OutcomeClassTitle()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OutcomeClassMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case outcomeclass.FieldOutcomeClassTitle:
		return m.OldOutcomeClassTitle(ctx)
	}
	return nil, fmt.Errorf("unknown OutcomeClass field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutcomeClassMutation) SetField(name string, value ent.Value) error {
	switch name {
	case outcomeclass.FieldOutcomeClassTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeClassTitle(v)
		return nil
	}
	return fmt.Errorf("unknown OutcomeClass field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OutcomeClassMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OutcomeClassMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutcomeClassMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OutcomeClass numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OutcomeClassMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OutcomeClassMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OutcomeClassMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OutcomeClass nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OutcomeClassMutation) ResetField(name string) error {
	switch name {
	case outcomeclass.FieldOutcomeClassTitle:
		m.ResetOutcomeClassTitle()
		return nil
	}
	return fmt.Errorf("unknown OutcomeClass field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OutcomeClassMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent != nil {
		edges = append(edges, outcomeclass.EdgeParent)
	}
	if m.outcome_class_denom_list != nil {
		edges = append(edges, outcomeclass.EdgeOutcomeClassDenomList)
	}
	if m.outcome_category_list != nil {
		edges = append(edges, outcomeclass.EdgeOutcomeCategoryList)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OutcomeClassMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case outcomeclass.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case outcomeclass.EdgeOutcomeClassDenomList:
		ids := make([]ent.Value, 0, len(m.outcome_class_denom_list))
		for id := range m.outcome_class_denom_list {
			ids = append(ids, id)
		}
		return ids
	case outcomeclass.EdgeOutcomeCategoryList:
		ids := make([]ent.Value, 0, len(m.outcome_category_list))
		for id := range m.outcome_category_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OutcomeClassMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedoutcome_class_denom_list != nil {
		edges = append(edges, outcomeclass.EdgeOutcomeClassDenomList)
	}
	if m.removedoutcome_category_list != nil {
		edges = append(edges, outcomeclass.EdgeOutcomeCategoryList)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OutcomeClassMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case outcomeclass.EdgeOutcomeClassDenomList:
		ids := make([]ent.Value, 0, len(m.removedoutcome_class_denom_list))
		for id := range m.removedoutcome_class_denom_list {
			ids = append(ids, id)
		}
		return ids
	case outcomeclass.EdgeOutcomeCategoryList:
		ids := make([]ent.Value, 0, len(m.removedoutcome_category_list))
		for id := range m.removedoutcome_category_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OutcomeClassMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent {
		edges = append(edges, outcomeclass.EdgeParent)
	}
	if m.clearedoutcome_class_denom_list {
		edges = append(edges, outcomeclass.EdgeOutcomeClassDenomList)
	}
	if m.clearedoutcome_category_list {
		edges = append(edges, outcomeclass.EdgeOutcomeCategoryList)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OutcomeClassMutation) EdgeCleared(name string) bool {
	switch name {
	case outcomeclass.EdgeParent:
		return m.clearedparent
	case outcomeclass.EdgeOutcomeClassDenomList:
		return m.clearedoutcome_class_denom_list
	case outcomeclass.EdgeOutcomeCategoryList:
		return m.clearedoutcome_category_list
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OutcomeClassMutation) ClearEdge(name string) error {
	switch name {
	case outcomeclass.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown OutcomeClass unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OutcomeClassMutation) ResetEdge(name string) error {
	switch name {
	case outcomeclass.EdgeParent:
		m.ResetParent()
		return nil
	case outcomeclass.EdgeOutcomeClassDenomList:
		m.ResetOutcomeClassDenomList()
		return nil
	case outcomeclass.EdgeOutcomeCategoryList:
		m.ResetOutcomeCategoryList()
		return nil
	}
	return fmt.Errorf("unknown OutcomeClass edge %s", name)
}

// OutcomeClassDenomMutation represents an operation that mutates the OutcomeClassDenom nodes in the graph.
type OutcomeClassDenomMutation struct {
	config
	op                                    Op
	typ                                   string
	id                                    *int
	outcome_class_denom_units             *string
	clearedFields                         map[string]struct{}
	parent                                *int
	clearedparent                         bool
	outcome_class_denom_count_list        map[int]struct{}
	removedoutcome_class_denom_count_list map[int]struct{}
	clearedoutcome_class_denom_count_list bool
	done                                  bool
	oldValue                              func(context.Context) (*OutcomeClassDenom, error)
	predicates                            []predicate.OutcomeClassDenom
}

var _ ent.Mutation = (*OutcomeClassDenomMutation)(nil)

// outcomeclassdenomOption allows management of the mutation configuration using functional options.
type outcomeclassdenomOption func(*OutcomeClassDenomMutation)

// newOutcomeClassDenomMutation creates new mutation for the OutcomeClassDenom entity.
func newOutcomeClassDenomMutation(c config, op Op, opts ...outcomeclassdenomOption) *OutcomeClassDenomMutation {
	m := &OutcomeClassDenomMutation{
		config:        c,
		op:            op,
		typ:           TypeOutcomeClassDenom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOutcomeClassDenomID sets the ID field of the mutation.
func withOutcomeClassDenomID(id int) outcomeclassdenomOption {
	return func(m *OutcomeClassDenomMutation) {
		var (
			err   error
			once  sync.Once
			value *OutcomeClassDenom
		)
		m.oldValue = func(ctx context.Context) (*OutcomeClassDenom, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OutcomeClassDenom.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOutcomeClassDenom sets the old OutcomeClassDenom of the mutation.
func withOutcomeClassDenom(node *OutcomeClassDenom) outcomeclassdenomOption {
	return func(m *OutcomeClassDenomMutation) {
		m.oldValue = func(context.Context) (*OutcomeClassDenom, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OutcomeClassDenomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OutcomeClassDenomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OutcomeClassDenomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OutcomeClassDenomMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OutcomeClassDenom.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOutcomeClassDenomUnits sets the "outcome_class_denom_units" field.
func (m *OutcomeClassDenomMutation) SetOutcomeClassDenomUnits(s string) {
	m.outcome_class_denom_units = &s
}

// OutcomeClassDenomUnits returns the value of the "outcome_class_denom_units" field in the mutation.
func (m *OutcomeClassDenomMutation) OutcomeClassDenomUnits() (r string, exists bool) {
	v := m.outcome_class_denom_units
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeClassDenomUnits returns the old "outcome_class_denom_units" field's value of the OutcomeClassDenom entity.
// If the OutcomeClassDenom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeClassDenomMutation) OldOutcomeClassDenomUnits(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeClassDenomUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeClassDenomUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeClassDenomUnits: %w", err)
	}
	return oldValue.OutcomeClassDenomUnits, nil
}

// ResetOutcomeClassDenomUnits resets all changes to the "outcome_class_denom_units" field.
func (m *OutcomeClassDenomMutation) ResetOutcomeClassDenomUnits() {
	m.outcome_class_denom_units = nil
}

// SetParentID sets the "parent" edge to the OutcomeClass entity by id.
func (m *OutcomeClassDenomMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the OutcomeClass entity.
func (m *OutcomeClassDenomMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the OutcomeClass entity was cleared.
func (m *OutcomeClassDenomMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *OutcomeClassDenomMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *OutcomeClassDenomMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *OutcomeClassDenomMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddOutcomeClassDenomCountListIDs adds the "outcome_class_denom_count_list" edge to the OutcomeClassDenomCount entity by ids.
func (m *OutcomeClassDenomMutation) AddOutcomeClassDenomCountListIDs(ids ...int) {
	if m.outcome_class_denom_count_list == nil {
		m.outcome_class_denom_count_list = make(map[int]struct{})
	}
	for i := range ids {
		m.outcome_class_denom_count_list[ids[i]] = struct{}{}
	}
}

// ClearOutcomeClassDenomCountList clears the "outcome_class_denom_count_list" edge to the OutcomeClassDenomCount entity.
func (m *OutcomeClassDenomMutation) ClearOutcomeClassDenomCountList() {
	m.clearedoutcome_class_denom_count_list = true
}

// OutcomeClassDenomCountListCleared reports if the "outcome_class_denom_count_list" edge to the OutcomeClassDenomCount entity was cleared.
func (m *OutcomeClassDenomMutation) OutcomeClassDenomCountListCleared() bool {
	return m.clearedoutcome_class_denom_count_list
}

// RemoveOutcomeClassDenomCountListIDs removes the "outcome_class_denom_count_list" edge to the OutcomeClassDenomCount entity by IDs.
func (m *OutcomeClassDenomMutation) RemoveOutcomeClassDenomCountListIDs(ids ...int) {
	if m.removedoutcome_class_denom_count_list == nil {
		m.removedoutcome_class_denom_count_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.outcome_class_denom_count_list, ids[i])
		m.removedoutcome_class_denom_count_list[ids[i]] = struct{}{}
	}
}

// RemovedOutcomeClassDenomCountList returns the removed IDs of the "outcome_class_denom_count_list" edge to the OutcomeClassDenomCount entity.
func (m *OutcomeClassDenomMutation) RemovedOutcomeClassDenomCountListIDs() (ids []int) {
	for id := range m.removedoutcome_class_denom_count_list {
		ids = append(ids, id)
	}
	return
}

// OutcomeClassDenomCountListIDs returns the "outcome_class_denom_count_list" edge IDs in the mutation.
func (m *OutcomeClassDenomMutation) OutcomeClassDenomCountListIDs() (ids []int) {
	for id := range m.outcome_class_denom_count_list {
		ids = append(ids, id)
	}
	return
}

// ResetOutcomeClassDenomCountList resets all changes to the "outcome_class_denom_count_list" edge.
func (m *OutcomeClassDenomMutation) ResetOutcomeClassDenomCountList() {
	m.outcome_class_denom_count_list = nil
	m.clearedoutcome_class_denom_count_list = false
	m.removedoutcome_class_denom_count_list = nil
}

// Where appends a list predicates to the OutcomeClassDenomMutation builder.
func (m *OutcomeClassDenomMutation) Where(ps ...predicate.OutcomeClassDenom) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OutcomeClassDenomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OutcomeClassDenom).
func (m *OutcomeClassDenomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OutcomeClassDenomMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.outcome_class_denom_units != nil {
		fields = append(fields, outcomeclassdenom.FieldOutcomeClassDenomUnits)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OutcomeClassDenomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case outcomeclassdenom.FieldOutcomeClassDenomUnits:
		return m.OutcomeClassDenomUnits()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OutcomeClassDenomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case outcomeclassdenom.FieldOutcomeClassDenomUnits:
		return m.OldOutcomeClassDenomUnits(ctx)
	}
	return nil, fmt.Errorf("unknown OutcomeClassDenom field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutcomeClassDenomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case outcomeclassdenom.FieldOutcomeClassDenomUnits:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeClassDenomUnits(v)
		return nil
	}
	return fmt.Errorf("unknown OutcomeClassDenom field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OutcomeClassDenomMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OutcomeClassDenomMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutcomeClassDenomMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OutcomeClassDenom numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OutcomeClassDenomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OutcomeClassDenomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OutcomeClassDenomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OutcomeClassDenom nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OutcomeClassDenomMutation) ResetField(name string) error {
	switch name {
	case outcomeclassdenom.FieldOutcomeClassDenomUnits:
		m.ResetOutcomeClassDenomUnits()
		return nil
	}
	return fmt.Errorf("unknown OutcomeClassDenom field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OutcomeClassDenomMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.parent != nil {
		edges = append(edges, outcomeclassdenom.EdgeParent)
	}
	if m.outcome_class_denom_count_list != nil {
		edges = append(edges, outcomeclassdenom.EdgeOutcomeClassDenomCountList)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OutcomeClassDenomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case outcomeclassdenom.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case outcomeclassdenom.EdgeOutcomeClassDenomCountList:
		ids := make([]ent.Value, 0, len(m.outcome_class_denom_count_list))
		for id := range m.outcome_class_denom_count_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OutcomeClassDenomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedoutcome_class_denom_count_list != nil {
		edges = append(edges, outcomeclassdenom.EdgeOutcomeClassDenomCountList)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OutcomeClassDenomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case outcomeclassdenom.EdgeOutcomeClassDenomCountList:
		ids := make([]ent.Value, 0, len(m.removedoutcome_class_denom_count_list))
		for id := range m.removedoutcome_class_denom_count_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OutcomeClassDenomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedparent {
		edges = append(edges, outcomeclassdenom.EdgeParent)
	}
	if m.clearedoutcome_class_denom_count_list {
		edges = append(edges, outcomeclassdenom.EdgeOutcomeClassDenomCountList)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OutcomeClassDenomMutation) EdgeCleared(name string) bool {
	switch name {
	case outcomeclassdenom.EdgeParent:
		return m.clearedparent
	case outcomeclassdenom.EdgeOutcomeClassDenomCountList:
		return m.clearedoutcome_class_denom_count_list
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OutcomeClassDenomMutation) ClearEdge(name string) error {
	switch name {
	case outcomeclassdenom.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown OutcomeClassDenom unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OutcomeClassDenomMutation) ResetEdge(name string) error {
	switch name {
	case outcomeclassdenom.EdgeParent:
		m.ResetParent()
		return nil
	case outcomeclassdenom.EdgeOutcomeClassDenomCountList:
		m.ResetOutcomeClassDenomCountList()
		return nil
	}
	return fmt.Errorf("unknown OutcomeClassDenom edge %s", name)
}

// OutcomeClassDenomCountMutation represents an operation that mutates the OutcomeClassDenomCount nodes in the graph.
type OutcomeClassDenomCountMutation struct {
	config
	op                                 Op
	typ                                string
	id                                 *int
	outcome_class_denom_count_group_id *string
	outcome_class_denom_count_value    *string
	clearedFields                      map[string]struct{}
	parent                             *int
	clearedparent                      bool
	done                               bool
	oldValue                           func(context.Context) (*OutcomeClassDenomCount, error)
	predicates                         []predicate.OutcomeClassDenomCount
}

var _ ent.Mutation = (*OutcomeClassDenomCountMutation)(nil)

// outcomeclassdenomcountOption allows management of the mutation configuration using functional options.
type outcomeclassdenomcountOption func(*OutcomeClassDenomCountMutation)

// newOutcomeClassDenomCountMutation creates new mutation for the OutcomeClassDenomCount entity.
func newOutcomeClassDenomCountMutation(c config, op Op, opts ...outcomeclassdenomcountOption) *OutcomeClassDenomCountMutation {
	m := &OutcomeClassDenomCountMutation{
		config:        c,
		op:            op,
		typ:           TypeOutcomeClassDenomCount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOutcomeClassDenomCountID sets the ID field of the mutation.
func withOutcomeClassDenomCountID(id int) outcomeclassdenomcountOption {
	return func(m *OutcomeClassDenomCountMutation) {
		var (
			err   error
			once  sync.Once
			value *OutcomeClassDenomCount
		)
		m.oldValue = func(ctx context.Context) (*OutcomeClassDenomCount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OutcomeClassDenomCount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOutcomeClassDenomCount sets the old OutcomeClassDenomCount of the mutation.
func withOutcomeClassDenomCount(node *OutcomeClassDenomCount) outcomeclassdenomcountOption {
	return func(m *OutcomeClassDenomCountMutation) {
		m.oldValue = func(context.Context) (*OutcomeClassDenomCount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OutcomeClassDenomCountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OutcomeClassDenomCountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OutcomeClassDenomCountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OutcomeClassDenomCountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OutcomeClassDenomCount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOutcomeClassDenomCountGroupID sets the "outcome_class_denom_count_group_id" field.
func (m *OutcomeClassDenomCountMutation) SetOutcomeClassDenomCountGroupID(s string) {
	m.outcome_class_denom_count_group_id = &s
}

// OutcomeClassDenomCountGroupID returns the value of the "outcome_class_denom_count_group_id" field in the mutation.
func (m *OutcomeClassDenomCountMutation) OutcomeClassDenomCountGroupID() (r string, exists bool) {
	v := m.outcome_class_denom_count_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeClassDenomCountGroupID returns the old "outcome_class_denom_count_group_id" field's value of the OutcomeClassDenomCount entity.
// If the OutcomeClassDenomCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeClassDenomCountMutation) OldOutcomeClassDenomCountGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeClassDenomCountGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeClassDenomCountGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeClassDenomCountGroupID: %w", err)
	}
	return oldValue.OutcomeClassDenomCountGroupID, nil
}

// ResetOutcomeClassDenomCountGroupID resets all changes to the "outcome_class_denom_count_group_id" field.
func (m *OutcomeClassDenomCountMutation) ResetOutcomeClassDenomCountGroupID() {
	m.outcome_class_denom_count_group_id = nil
}

// SetOutcomeClassDenomCountValue sets the "outcome_class_denom_count_value" field.
func (m *OutcomeClassDenomCountMutation) SetOutcomeClassDenomCountValue(s string) {
	m.outcome_class_denom_count_value = &s
}

// OutcomeClassDenomCountValue returns the value of the "outcome_class_denom_count_value" field in the mutation.
func (m *OutcomeClassDenomCountMutation) OutcomeClassDenomCountValue() (r string, exists bool) {
	v := m.outcome_class_denom_count_value
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeClassDenomCountValue returns the old "outcome_class_denom_count_value" field's value of the OutcomeClassDenomCount entity.
// If the OutcomeClassDenomCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeClassDenomCountMutation) OldOutcomeClassDenomCountValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeClassDenomCountValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeClassDenomCountValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeClassDenomCountValue: %w", err)
	}
	return oldValue.OutcomeClassDenomCountValue, nil
}

// ResetOutcomeClassDenomCountValue resets all changes to the "outcome_class_denom_count_value" field.
func (m *OutcomeClassDenomCountMutation) ResetOutcomeClassDenomCountValue() {
	m.outcome_class_denom_count_value = nil
}

// SetParentID sets the "parent" edge to the OutcomeClassDenom entity by id.
func (m *OutcomeClassDenomCountMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the OutcomeClassDenom entity.
func (m *OutcomeClassDenomCountMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the OutcomeClassDenom entity was cleared.
func (m *OutcomeClassDenomCountMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *OutcomeClassDenomCountMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *OutcomeClassDenomCountMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *OutcomeClassDenomCountMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// Where appends a list predicates to the OutcomeClassDenomCountMutation builder.
func (m *OutcomeClassDenomCountMutation) Where(ps ...predicate.OutcomeClassDenomCount) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OutcomeClassDenomCountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OutcomeClassDenomCount).
func (m *OutcomeClassDenomCountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OutcomeClassDenomCountMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.outcome_class_denom_count_group_id != nil {
		fields = append(fields, outcomeclassdenomcount.FieldOutcomeClassDenomCountGroupID)
	}
	if m.outcome_class_denom_count_value != nil {
		fields = append(fields, outcomeclassdenomcount.FieldOutcomeClassDenomCountValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OutcomeClassDenomCountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case outcomeclassdenomcount.FieldOutcomeClassDenomCountGroupID:
		return m.OutcomeClassDenomCountGroupID()
	case outcomeclassdenomcount.FieldOutcomeClassDenomCountValue:
		return m.OutcomeClassDenomCountValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OutcomeClassDenomCountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case outcomeclassdenomcount.FieldOutcomeClassDenomCountGroupID:
		return m.OldOutcomeClassDenomCountGroupID(ctx)
	case outcomeclassdenomcount.FieldOutcomeClassDenomCountValue:
		return m.OldOutcomeClassDenomCountValue(ctx)
	}
	return nil, fmt.Errorf("unknown OutcomeClassDenomCount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutcomeClassDenomCountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case outcomeclassdenomcount.FieldOutcomeClassDenomCountGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeClassDenomCountGroupID(v)
		return nil
	case outcomeclassdenomcount.FieldOutcomeClassDenomCountValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeClassDenomCountValue(v)
		return nil
	}
	return fmt.Errorf("unknown OutcomeClassDenomCount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OutcomeClassDenomCountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OutcomeClassDenomCountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutcomeClassDenomCountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OutcomeClassDenomCount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OutcomeClassDenomCountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OutcomeClassDenomCountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OutcomeClassDenomCountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OutcomeClassDenomCount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OutcomeClassDenomCountMutation) ResetField(name string) error {
	switch name {
	case outcomeclassdenomcount.FieldOutcomeClassDenomCountGroupID:
		m.ResetOutcomeClassDenomCountGroupID()
		return nil
	case outcomeclassdenomcount.FieldOutcomeClassDenomCountValue:
		m.ResetOutcomeClassDenomCountValue()
		return nil
	}
	return fmt.Errorf("unknown OutcomeClassDenomCount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OutcomeClassDenomCountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.parent != nil {
		edges = append(edges, outcomeclassdenomcount.EdgeParent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OutcomeClassDenomCountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case outcomeclassdenomcount.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OutcomeClassDenomCountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OutcomeClassDenomCountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OutcomeClassDenomCountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparent {
		edges = append(edges, outcomeclassdenomcount.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OutcomeClassDenomCountMutation) EdgeCleared(name string) bool {
	switch name {
	case outcomeclassdenomcount.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OutcomeClassDenomCountMutation) ClearEdge(name string) error {
	switch name {
	case outcomeclassdenomcount.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown OutcomeClassDenomCount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OutcomeClassDenomCountMutation) ResetEdge(name string) error {
	switch name {
	case outcomeclassdenomcount.EdgeParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown OutcomeClassDenomCount edge %s", name)
}

// OutcomeDenomMutation represents an operation that mutates the OutcomeDenom nodes in the graph.
type OutcomeDenomMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	outcome_denom_units             *string
	clearedFields                   map[string]struct{}
	parent                          *int
	clearedparent                   bool
	outcome_denom_count_list        map[int]struct{}
	removedoutcome_denom_count_list map[int]struct{}
	clearedoutcome_denom_count_list bool
	done                            bool
	oldValue                        func(context.Context) (*OutcomeDenom, error)
	predicates                      []predicate.OutcomeDenom
}

var _ ent.Mutation = (*OutcomeDenomMutation)(nil)

// outcomedenomOption allows management of the mutation configuration using functional options.
type outcomedenomOption func(*OutcomeDenomMutation)

// newOutcomeDenomMutation creates new mutation for the OutcomeDenom entity.
func newOutcomeDenomMutation(c config, op Op, opts ...outcomedenomOption) *OutcomeDenomMutation {
	m := &OutcomeDenomMutation{
		config:        c,
		op:            op,
		typ:           TypeOutcomeDenom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOutcomeDenomID sets the ID field of the mutation.
func withOutcomeDenomID(id int) outcomedenomOption {
	return func(m *OutcomeDenomMutation) {
		var (
			err   error
			once  sync.Once
			value *OutcomeDenom
		)
		m.oldValue = func(ctx context.Context) (*OutcomeDenom, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OutcomeDenom.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOutcomeDenom sets the old OutcomeDenom of the mutation.
func withOutcomeDenom(node *OutcomeDenom) outcomedenomOption {
	return func(m *OutcomeDenomMutation) {
		m.oldValue = func(context.Context) (*OutcomeDenom, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OutcomeDenomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OutcomeDenomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OutcomeDenomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OutcomeDenomMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OutcomeDenom.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOutcomeDenomUnits sets the "outcome_denom_units" field.
func (m *OutcomeDenomMutation) SetOutcomeDenomUnits(s string) {
	m.outcome_denom_units = &s
}

// OutcomeDenomUnits returns the value of the "outcome_denom_units" field in the mutation.
func (m *OutcomeDenomMutation) OutcomeDenomUnits() (r string, exists bool) {
	v := m.outcome_denom_units
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeDenomUnits returns the old "outcome_denom_units" field's value of the OutcomeDenom entity.
// If the OutcomeDenom object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeDenomMutation) OldOutcomeDenomUnits(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeDenomUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeDenomUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeDenomUnits: %w", err)
	}
	return oldValue.OutcomeDenomUnits, nil
}

// ResetOutcomeDenomUnits resets all changes to the "outcome_denom_units" field.
func (m *OutcomeDenomMutation) ResetOutcomeDenomUnits() {
	m.outcome_denom_units = nil
}

// SetParentID sets the "parent" edge to the OutcomeMeasure entity by id.
func (m *OutcomeDenomMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the OutcomeMeasure entity.
func (m *OutcomeDenomMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the OutcomeMeasure entity was cleared.
func (m *OutcomeDenomMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *OutcomeDenomMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *OutcomeDenomMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *OutcomeDenomMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddOutcomeDenomCountListIDs adds the "outcome_denom_count_list" edge to the OutcomeDenomCount entity by ids.
func (m *OutcomeDenomMutation) AddOutcomeDenomCountListIDs(ids ...int) {
	if m.outcome_denom_count_list == nil {
		m.outcome_denom_count_list = make(map[int]struct{})
	}
	for i := range ids {
		m.outcome_denom_count_list[ids[i]] = struct{}{}
	}
}

// ClearOutcomeDenomCountList clears the "outcome_denom_count_list" edge to the OutcomeDenomCount entity.
func (m *OutcomeDenomMutation) ClearOutcomeDenomCountList() {
	m.clearedoutcome_denom_count_list = true
}

// OutcomeDenomCountListCleared reports if the "outcome_denom_count_list" edge to the OutcomeDenomCount entity was cleared.
func (m *OutcomeDenomMutation) OutcomeDenomCountListCleared() bool {
	return m.clearedoutcome_denom_count_list
}

// RemoveOutcomeDenomCountListIDs removes the "outcome_denom_count_list" edge to the OutcomeDenomCount entity by IDs.
func (m *OutcomeDenomMutation) RemoveOutcomeDenomCountListIDs(ids ...int) {
	if m.removedoutcome_denom_count_list == nil {
		m.removedoutcome_denom_count_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.outcome_denom_count_list, ids[i])
		m.removedoutcome_denom_count_list[ids[i]] = struct{}{}
	}
}

// RemovedOutcomeDenomCountList returns the removed IDs of the "outcome_denom_count_list" edge to the OutcomeDenomCount entity.
func (m *OutcomeDenomMutation) RemovedOutcomeDenomCountListIDs() (ids []int) {
	for id := range m.removedoutcome_denom_count_list {
		ids = append(ids, id)
	}
	return
}

// OutcomeDenomCountListIDs returns the "outcome_denom_count_list" edge IDs in the mutation.
func (m *OutcomeDenomMutation) OutcomeDenomCountListIDs() (ids []int) {
	for id := range m.outcome_denom_count_list {
		ids = append(ids, id)
	}
	return
}

// ResetOutcomeDenomCountList resets all changes to the "outcome_denom_count_list" edge.
func (m *OutcomeDenomMutation) ResetOutcomeDenomCountList() {
	m.outcome_denom_count_list = nil
	m.clearedoutcome_denom_count_list = false
	m.removedoutcome_denom_count_list = nil
}

// Where appends a list predicates to the OutcomeDenomMutation builder.
func (m *OutcomeDenomMutation) Where(ps ...predicate.OutcomeDenom) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OutcomeDenomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OutcomeDenom).
func (m *OutcomeDenomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OutcomeDenomMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.outcome_denom_units != nil {
		fields = append(fields, outcomedenom.FieldOutcomeDenomUnits)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OutcomeDenomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case outcomedenom.FieldOutcomeDenomUnits:
		return m.OutcomeDenomUnits()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OutcomeDenomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case outcomedenom.FieldOutcomeDenomUnits:
		return m.OldOutcomeDenomUnits(ctx)
	}
	return nil, fmt.Errorf("unknown OutcomeDenom field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutcomeDenomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case outcomedenom.FieldOutcomeDenomUnits:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeDenomUnits(v)
		return nil
	}
	return fmt.Errorf("unknown OutcomeDenom field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OutcomeDenomMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OutcomeDenomMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutcomeDenomMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OutcomeDenom numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OutcomeDenomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OutcomeDenomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OutcomeDenomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OutcomeDenom nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OutcomeDenomMutation) ResetField(name string) error {
	switch name {
	case outcomedenom.FieldOutcomeDenomUnits:
		m.ResetOutcomeDenomUnits()
		return nil
	}
	return fmt.Errorf("unknown OutcomeDenom field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OutcomeDenomMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.parent != nil {
		edges = append(edges, outcomedenom.EdgeParent)
	}
	if m.outcome_denom_count_list != nil {
		edges = append(edges, outcomedenom.EdgeOutcomeDenomCountList)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OutcomeDenomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case outcomedenom.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case outcomedenom.EdgeOutcomeDenomCountList:
		ids := make([]ent.Value, 0, len(m.outcome_denom_count_list))
		for id := range m.outcome_denom_count_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OutcomeDenomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedoutcome_denom_count_list != nil {
		edges = append(edges, outcomedenom.EdgeOutcomeDenomCountList)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OutcomeDenomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case outcomedenom.EdgeOutcomeDenomCountList:
		ids := make([]ent.Value, 0, len(m.removedoutcome_denom_count_list))
		for id := range m.removedoutcome_denom_count_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OutcomeDenomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedparent {
		edges = append(edges, outcomedenom.EdgeParent)
	}
	if m.clearedoutcome_denom_count_list {
		edges = append(edges, outcomedenom.EdgeOutcomeDenomCountList)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OutcomeDenomMutation) EdgeCleared(name string) bool {
	switch name {
	case outcomedenom.EdgeParent:
		return m.clearedparent
	case outcomedenom.EdgeOutcomeDenomCountList:
		return m.clearedoutcome_denom_count_list
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OutcomeDenomMutation) ClearEdge(name string) error {
	switch name {
	case outcomedenom.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown OutcomeDenom unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OutcomeDenomMutation) ResetEdge(name string) error {
	switch name {
	case outcomedenom.EdgeParent:
		m.ResetParent()
		return nil
	case outcomedenom.EdgeOutcomeDenomCountList:
		m.ResetOutcomeDenomCountList()
		return nil
	}
	return fmt.Errorf("unknown OutcomeDenom edge %s", name)
}

// OutcomeDenomCountMutation represents an operation that mutates the OutcomeDenomCount nodes in the graph.
type OutcomeDenomCountMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	outcome_denom_count_group_id *string
	outcome_denom_count_value    *string
	clearedFields                map[string]struct{}
	parent                       *int
	clearedparent                bool
	done                         bool
	oldValue                     func(context.Context) (*OutcomeDenomCount, error)
	predicates                   []predicate.OutcomeDenomCount
}

var _ ent.Mutation = (*OutcomeDenomCountMutation)(nil)

// outcomedenomcountOption allows management of the mutation configuration using functional options.
type outcomedenomcountOption func(*OutcomeDenomCountMutation)

// newOutcomeDenomCountMutation creates new mutation for the OutcomeDenomCount entity.
func newOutcomeDenomCountMutation(c config, op Op, opts ...outcomedenomcountOption) *OutcomeDenomCountMutation {
	m := &OutcomeDenomCountMutation{
		config:        c,
		op:            op,
		typ:           TypeOutcomeDenomCount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOutcomeDenomCountID sets the ID field of the mutation.
func withOutcomeDenomCountID(id int) outcomedenomcountOption {
	return func(m *OutcomeDenomCountMutation) {
		var (
			err   error
			once  sync.Once
			value *OutcomeDenomCount
		)
		m.oldValue = func(ctx context.Context) (*OutcomeDenomCount, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OutcomeDenomCount.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOutcomeDenomCount sets the old OutcomeDenomCount of the mutation.
func withOutcomeDenomCount(node *OutcomeDenomCount) outcomedenomcountOption {
	return func(m *OutcomeDenomCountMutation) {
		m.oldValue = func(context.Context) (*OutcomeDenomCount, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OutcomeDenomCountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OutcomeDenomCountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OutcomeDenomCountMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OutcomeDenomCountMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OutcomeDenomCount.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOutcomeDenomCountGroupID sets the "outcome_denom_count_group_id" field.
func (m *OutcomeDenomCountMutation) SetOutcomeDenomCountGroupID(s string) {
	m.outcome_denom_count_group_id = &s
}

// OutcomeDenomCountGroupID returns the value of the "outcome_denom_count_group_id" field in the mutation.
func (m *OutcomeDenomCountMutation) OutcomeDenomCountGroupID() (r string, exists bool) {
	v := m.outcome_denom_count_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeDenomCountGroupID returns the old "outcome_denom_count_group_id" field's value of the OutcomeDenomCount entity.
// If the OutcomeDenomCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeDenomCountMutation) OldOutcomeDenomCountGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeDenomCountGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeDenomCountGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeDenomCountGroupID: %w", err)
	}
	return oldValue.OutcomeDenomCountGroupID, nil
}

// ResetOutcomeDenomCountGroupID resets all changes to the "outcome_denom_count_group_id" field.
func (m *OutcomeDenomCountMutation) ResetOutcomeDenomCountGroupID() {
	m.outcome_denom_count_group_id = nil
}

// SetOutcomeDenomCountValue sets the "outcome_denom_count_value" field.
func (m *OutcomeDenomCountMutation) SetOutcomeDenomCountValue(s string) {
	m.outcome_denom_count_value = &s
}

// OutcomeDenomCountValue returns the value of the "outcome_denom_count_value" field in the mutation.
func (m *OutcomeDenomCountMutation) OutcomeDenomCountValue() (r string, exists bool) {
	v := m.outcome_denom_count_value
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeDenomCountValue returns the old "outcome_denom_count_value" field's value of the OutcomeDenomCount entity.
// If the OutcomeDenomCount object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeDenomCountMutation) OldOutcomeDenomCountValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeDenomCountValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeDenomCountValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeDenomCountValue: %w", err)
	}
	return oldValue.OutcomeDenomCountValue, nil
}

// ResetOutcomeDenomCountValue resets all changes to the "outcome_denom_count_value" field.
func (m *OutcomeDenomCountMutation) ResetOutcomeDenomCountValue() {
	m.outcome_denom_count_value = nil
}

// SetParentID sets the "parent" edge to the OutcomeDenom entity by id.
func (m *OutcomeDenomCountMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the OutcomeDenom entity.
func (m *OutcomeDenomCountMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the OutcomeDenom entity was cleared.
func (m *OutcomeDenomCountMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *OutcomeDenomCountMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *OutcomeDenomCountMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *OutcomeDenomCountMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// Where appends a list predicates to the OutcomeDenomCountMutation builder.
func (m *OutcomeDenomCountMutation) Where(ps ...predicate.OutcomeDenomCount) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OutcomeDenomCountMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OutcomeDenomCount).
func (m *OutcomeDenomCountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OutcomeDenomCountMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.outcome_denom_count_group_id != nil {
		fields = append(fields, outcomedenomcount.FieldOutcomeDenomCountGroupID)
	}
	if m.outcome_denom_count_value != nil {
		fields = append(fields, outcomedenomcount.FieldOutcomeDenomCountValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OutcomeDenomCountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case outcomedenomcount.FieldOutcomeDenomCountGroupID:
		return m.OutcomeDenomCountGroupID()
	case outcomedenomcount.FieldOutcomeDenomCountValue:
		return m.OutcomeDenomCountValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OutcomeDenomCountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case outcomedenomcount.FieldOutcomeDenomCountGroupID:
		return m.OldOutcomeDenomCountGroupID(ctx)
	case outcomedenomcount.FieldOutcomeDenomCountValue:
		return m.OldOutcomeDenomCountValue(ctx)
	}
	return nil, fmt.Errorf("unknown OutcomeDenomCount field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutcomeDenomCountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case outcomedenomcount.FieldOutcomeDenomCountGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeDenomCountGroupID(v)
		return nil
	case outcomedenomcount.FieldOutcomeDenomCountValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeDenomCountValue(v)
		return nil
	}
	return fmt.Errorf("unknown OutcomeDenomCount field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OutcomeDenomCountMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OutcomeDenomCountMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutcomeDenomCountMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OutcomeDenomCount numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OutcomeDenomCountMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OutcomeDenomCountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OutcomeDenomCountMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OutcomeDenomCount nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OutcomeDenomCountMutation) ResetField(name string) error {
	switch name {
	case outcomedenomcount.FieldOutcomeDenomCountGroupID:
		m.ResetOutcomeDenomCountGroupID()
		return nil
	case outcomedenomcount.FieldOutcomeDenomCountValue:
		m.ResetOutcomeDenomCountValue()
		return nil
	}
	return fmt.Errorf("unknown OutcomeDenomCount field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OutcomeDenomCountMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.parent != nil {
		edges = append(edges, outcomedenomcount.EdgeParent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OutcomeDenomCountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case outcomedenomcount.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OutcomeDenomCountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OutcomeDenomCountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OutcomeDenomCountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparent {
		edges = append(edges, outcomedenomcount.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OutcomeDenomCountMutation) EdgeCleared(name string) bool {
	switch name {
	case outcomedenomcount.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OutcomeDenomCountMutation) ClearEdge(name string) error {
	switch name {
	case outcomedenomcount.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown OutcomeDenomCount unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OutcomeDenomCountMutation) ResetEdge(name string) error {
	switch name {
	case outcomedenomcount.EdgeParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown OutcomeDenomCount edge %s", name)
}

// OutcomeGroupMutation represents an operation that mutates the OutcomeGroup nodes in the graph.
type OutcomeGroupMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	outcome_group_id          *string
	outcome_group_title       *string
	outcome_group_description *string
	clearedFields             map[string]struct{}
	parent                    *int
	clearedparent             bool
	done                      bool
	oldValue                  func(context.Context) (*OutcomeGroup, error)
	predicates                []predicate.OutcomeGroup
}

var _ ent.Mutation = (*OutcomeGroupMutation)(nil)

// outcomegroupOption allows management of the mutation configuration using functional options.
type outcomegroupOption func(*OutcomeGroupMutation)

// newOutcomeGroupMutation creates new mutation for the OutcomeGroup entity.
func newOutcomeGroupMutation(c config, op Op, opts ...outcomegroupOption) *OutcomeGroupMutation {
	m := &OutcomeGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeOutcomeGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOutcomeGroupID sets the ID field of the mutation.
func withOutcomeGroupID(id int) outcomegroupOption {
	return func(m *OutcomeGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *OutcomeGroup
		)
		m.oldValue = func(ctx context.Context) (*OutcomeGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OutcomeGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOutcomeGroup sets the old OutcomeGroup of the mutation.
func withOutcomeGroup(node *OutcomeGroup) outcomegroupOption {
	return func(m *OutcomeGroupMutation) {
		m.oldValue = func(context.Context) (*OutcomeGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OutcomeGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OutcomeGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OutcomeGroupMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OutcomeGroupMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OutcomeGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOutcomeGroupID sets the "outcome_group_id" field.
func (m *OutcomeGroupMutation) SetOutcomeGroupID(s string) {
	m.outcome_group_id = &s
}

// OutcomeGroupID returns the value of the "outcome_group_id" field in the mutation.
func (m *OutcomeGroupMutation) OutcomeGroupID() (r string, exists bool) {
	v := m.outcome_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeGroupID returns the old "outcome_group_id" field's value of the OutcomeGroup entity.
// If the OutcomeGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeGroupMutation) OldOutcomeGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeGroupID: %w", err)
	}
	return oldValue.OutcomeGroupID, nil
}

// ResetOutcomeGroupID resets all changes to the "outcome_group_id" field.
func (m *OutcomeGroupMutation) ResetOutcomeGroupID() {
	m.outcome_group_id = nil
}

// SetOutcomeGroupTitle sets the "outcome_group_title" field.
func (m *OutcomeGroupMutation) SetOutcomeGroupTitle(s string) {
	m.outcome_group_title = &s
}

// OutcomeGroupTitle returns the value of the "outcome_group_title" field in the mutation.
func (m *OutcomeGroupMutation) OutcomeGroupTitle() (r string, exists bool) {
	v := m.outcome_group_title
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeGroupTitle returns the old "outcome_group_title" field's value of the OutcomeGroup entity.
// If the OutcomeGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeGroupMutation) OldOutcomeGroupTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeGroupTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeGroupTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeGroupTitle: %w", err)
	}
	return oldValue.OutcomeGroupTitle, nil
}

// ResetOutcomeGroupTitle resets all changes to the "outcome_group_title" field.
func (m *OutcomeGroupMutation) ResetOutcomeGroupTitle() {
	m.outcome_group_title = nil
}

// SetOutcomeGroupDescription sets the "outcome_group_description" field.
func (m *OutcomeGroupMutation) SetOutcomeGroupDescription(s string) {
	m.outcome_group_description = &s
}

// OutcomeGroupDescription returns the value of the "outcome_group_description" field in the mutation.
func (m *OutcomeGroupMutation) OutcomeGroupDescription() (r string, exists bool) {
	v := m.outcome_group_description
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeGroupDescription returns the old "outcome_group_description" field's value of the OutcomeGroup entity.
// If the OutcomeGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeGroupMutation) OldOutcomeGroupDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeGroupDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeGroupDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeGroupDescription: %w", err)
	}
	return oldValue.OutcomeGroupDescription, nil
}

// ResetOutcomeGroupDescription resets all changes to the "outcome_group_description" field.
func (m *OutcomeGroupMutation) ResetOutcomeGroupDescription() {
	m.outcome_group_description = nil
}

// SetParentID sets the "parent" edge to the OutcomeMeasure entity by id.
func (m *OutcomeGroupMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the OutcomeMeasure entity.
func (m *OutcomeGroupMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the OutcomeMeasure entity was cleared.
func (m *OutcomeGroupMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *OutcomeGroupMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *OutcomeGroupMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *OutcomeGroupMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// Where appends a list predicates to the OutcomeGroupMutation builder.
func (m *OutcomeGroupMutation) Where(ps ...predicate.OutcomeGroup) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OutcomeGroupMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OutcomeGroup).
func (m *OutcomeGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OutcomeGroupMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.outcome_group_id != nil {
		fields = append(fields, outcomegroup.FieldOutcomeGroupID)
	}
	if m.outcome_group_title != nil {
		fields = append(fields, outcomegroup.FieldOutcomeGroupTitle)
	}
	if m.outcome_group_description != nil {
		fields = append(fields, outcomegroup.FieldOutcomeGroupDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OutcomeGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case outcomegroup.FieldOutcomeGroupID:
		return m.OutcomeGroupID()
	case outcomegroup.FieldOutcomeGroupTitle:
		return m.OutcomeGroupTitle()
	case outcomegroup.FieldOutcomeGroupDescription:
		return m.OutcomeGroupDescription()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OutcomeGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case outcomegroup.FieldOutcomeGroupID:
		return m.OldOutcomeGroupID(ctx)
	case outcomegroup.FieldOutcomeGroupTitle:
		return m.OldOutcomeGroupTitle(ctx)
	case outcomegroup.FieldOutcomeGroupDescription:
		return m.OldOutcomeGroupDescription(ctx)
	}
	return nil, fmt.Errorf("unknown OutcomeGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutcomeGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case outcomegroup.FieldOutcomeGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeGroupID(v)
		return nil
	case outcomegroup.FieldOutcomeGroupTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeGroupTitle(v)
		return nil
	case outcomegroup.FieldOutcomeGroupDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeGroupDescription(v)
		return nil
	}
	return fmt.Errorf("unknown OutcomeGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OutcomeGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OutcomeGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutcomeGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OutcomeGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OutcomeGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OutcomeGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OutcomeGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OutcomeGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OutcomeGroupMutation) ResetField(name string) error {
	switch name {
	case outcomegroup.FieldOutcomeGroupID:
		m.ResetOutcomeGroupID()
		return nil
	case outcomegroup.FieldOutcomeGroupTitle:
		m.ResetOutcomeGroupTitle()
		return nil
	case outcomegroup.FieldOutcomeGroupDescription:
		m.ResetOutcomeGroupDescription()
		return nil
	}
	return fmt.Errorf("unknown OutcomeGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OutcomeGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.parent != nil {
		edges = append(edges, outcomegroup.EdgeParent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OutcomeGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case outcomegroup.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OutcomeGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OutcomeGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OutcomeGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparent {
		edges = append(edges, outcomegroup.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OutcomeGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case outcomegroup.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OutcomeGroupMutation) ClearEdge(name string) error {
	switch name {
	case outcomegroup.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown OutcomeGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OutcomeGroupMutation) ResetEdge(name string) error {
	switch name {
	case outcomegroup.EdgeParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown OutcomeGroup edge %s", name)
}

// OutcomeMeasureMutation represents an operation that mutates the OutcomeMeasure nodes in the graph.
type OutcomeMeasureMutation struct {
	config
	op                                       Op
	typ                                      string
	id                                       *int
	outcome_measure_type                     *string
	outcome_measure_title                    *string
	outcome_measure_description              *string
	outcome_measure_population_description   *string
	outcome_measure_reporting_status         *string
	outcome_measure_anticipated_posting_date *string
	outcome_measure_param_type               *string
	outcome_measure_dispersion_type          *string
	outcome_measure_unit_of_measure          *string
	outcome_measure_calculate_pct            *string
	outcome_measure_time_frame               *string
	outcome_measure_type_units_analyzed      *string
	outcome_measure_denom_units_selected     *string
	clearedFields                            map[string]struct{}
	parent                                   *int
	clearedparent                            bool
	outcome_group_list                       map[int]struct{}
	removedoutcome_group_list                map[int]struct{}
	clearedoutcome_group_list                bool
	outcome_overview_list                    map[int]struct{}
	removedoutcome_overview_list             map[int]struct{}
	clearedoutcome_overview_list             bool
	outcome_denom_list                       map[int]struct{}
	removedoutcome_denom_list                map[int]struct{}
	clearedoutcome_denom_list                bool
	outcome_class_list                       map[int]struct{}
	removedoutcome_class_list                map[int]struct{}
	clearedoutcome_class_list                bool
	outcome_analysis_list                    map[int]struct{}
	removedoutcome_analysis_list             map[int]struct{}
	clearedoutcome_analysis_list             bool
	done                                     bool
	oldValue                                 func(context.Context) (*OutcomeMeasure, error)
	predicates                               []predicate.OutcomeMeasure
}

var _ ent.Mutation = (*OutcomeMeasureMutation)(nil)

// outcomemeasureOption allows management of the mutation configuration using functional options.
type outcomemeasureOption func(*OutcomeMeasureMutation)

// newOutcomeMeasureMutation creates new mutation for the OutcomeMeasure entity.
func newOutcomeMeasureMutation(c config, op Op, opts ...outcomemeasureOption) *OutcomeMeasureMutation {
	m := &OutcomeMeasureMutation{
		config:        c,
		op:            op,
		typ:           TypeOutcomeMeasure,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOutcomeMeasureID sets the ID field of the mutation.
func withOutcomeMeasureID(id int) outcomemeasureOption {
	return func(m *OutcomeMeasureMutation) {
		var (
			err   error
			once  sync.Once
			value *OutcomeMeasure
		)
		m.oldValue = func(ctx context.Context) (*OutcomeMeasure, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OutcomeMeasure.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOutcomeMeasure sets the old OutcomeMeasure of the mutation.
func withOutcomeMeasure(node *OutcomeMeasure) outcomemeasureOption {
	return func(m *OutcomeMeasureMutation) {
		m.oldValue = func(context.Context) (*OutcomeMeasure, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OutcomeMeasureMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OutcomeMeasureMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OutcomeMeasureMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OutcomeMeasureMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OutcomeMeasure.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOutcomeMeasureType sets the "outcome_measure_type" field.
func (m *OutcomeMeasureMutation) SetOutcomeMeasureType(s string) {
	m.outcome_measure_type = &s
}

// OutcomeMeasureType returns the value of the "outcome_measure_type" field in the mutation.
func (m *OutcomeMeasureMutation) OutcomeMeasureType() (r string, exists bool) {
	v := m.outcome_measure_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeMeasureType returns the old "outcome_measure_type" field's value of the OutcomeMeasure entity.
// If the OutcomeMeasure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeMeasureMutation) OldOutcomeMeasureType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeMeasureType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeMeasureType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeMeasureType: %w", err)
	}
	return oldValue.OutcomeMeasureType, nil
}

// ResetOutcomeMeasureType resets all changes to the "outcome_measure_type" field.
func (m *OutcomeMeasureMutation) ResetOutcomeMeasureType() {
	m.outcome_measure_type = nil
}

// SetOutcomeMeasureTitle sets the "outcome_measure_title" field.
func (m *OutcomeMeasureMutation) SetOutcomeMeasureTitle(s string) {
	m.outcome_measure_title = &s
}

// OutcomeMeasureTitle returns the value of the "outcome_measure_title" field in the mutation.
func (m *OutcomeMeasureMutation) OutcomeMeasureTitle() (r string, exists bool) {
	v := m.outcome_measure_title
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeMeasureTitle returns the old "outcome_measure_title" field's value of the OutcomeMeasure entity.
// If the OutcomeMeasure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeMeasureMutation) OldOutcomeMeasureTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeMeasureTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeMeasureTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeMeasureTitle: %w", err)
	}
	return oldValue.OutcomeMeasureTitle, nil
}

// ResetOutcomeMeasureTitle resets all changes to the "outcome_measure_title" field.
func (m *OutcomeMeasureMutation) ResetOutcomeMeasureTitle() {
	m.outcome_measure_title = nil
}

// SetOutcomeMeasureDescription sets the "outcome_measure_description" field.
func (m *OutcomeMeasureMutation) SetOutcomeMeasureDescription(s string) {
	m.outcome_measure_description = &s
}

// OutcomeMeasureDescription returns the value of the "outcome_measure_description" field in the mutation.
func (m *OutcomeMeasureMutation) OutcomeMeasureDescription() (r string, exists bool) {
	v := m.outcome_measure_description
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeMeasureDescription returns the old "outcome_measure_description" field's value of the OutcomeMeasure entity.
// If the OutcomeMeasure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeMeasureMutation) OldOutcomeMeasureDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeMeasureDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeMeasureDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeMeasureDescription: %w", err)
	}
	return oldValue.OutcomeMeasureDescription, nil
}

// ResetOutcomeMeasureDescription resets all changes to the "outcome_measure_description" field.
func (m *OutcomeMeasureMutation) ResetOutcomeMeasureDescription() {
	m.outcome_measure_description = nil
}

// SetOutcomeMeasurePopulationDescription sets the "outcome_measure_population_description" field.
func (m *OutcomeMeasureMutation) SetOutcomeMeasurePopulationDescription(s string) {
	m.outcome_measure_population_description = &s
}

// OutcomeMeasurePopulationDescription returns the value of the "outcome_measure_population_description" field in the mutation.
func (m *OutcomeMeasureMutation) OutcomeMeasurePopulationDescription() (r string, exists bool) {
	v := m.outcome_measure_population_description
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeMeasurePopulationDescription returns the old "outcome_measure_population_description" field's value of the OutcomeMeasure entity.
// If the OutcomeMeasure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeMeasureMutation) OldOutcomeMeasurePopulationDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeMeasurePopulationDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeMeasurePopulationDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeMeasurePopulationDescription: %w", err)
	}
	return oldValue.OutcomeMeasurePopulationDescription, nil
}

// ResetOutcomeMeasurePopulationDescription resets all changes to the "outcome_measure_population_description" field.
func (m *OutcomeMeasureMutation) ResetOutcomeMeasurePopulationDescription() {
	m.outcome_measure_population_description = nil
}

// SetOutcomeMeasureReportingStatus sets the "outcome_measure_reporting_status" field.
func (m *OutcomeMeasureMutation) SetOutcomeMeasureReportingStatus(s string) {
	m.outcome_measure_reporting_status = &s
}

// OutcomeMeasureReportingStatus returns the value of the "outcome_measure_reporting_status" field in the mutation.
func (m *OutcomeMeasureMutation) OutcomeMeasureReportingStatus() (r string, exists bool) {
	v := m.outcome_measure_reporting_status
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeMeasureReportingStatus returns the old "outcome_measure_reporting_status" field's value of the OutcomeMeasure entity.
// If the OutcomeMeasure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeMeasureMutation) OldOutcomeMeasureReportingStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeMeasureReportingStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeMeasureReportingStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeMeasureReportingStatus: %w", err)
	}
	return oldValue.OutcomeMeasureReportingStatus, nil
}

// ResetOutcomeMeasureReportingStatus resets all changes to the "outcome_measure_reporting_status" field.
func (m *OutcomeMeasureMutation) ResetOutcomeMeasureReportingStatus() {
	m.outcome_measure_reporting_status = nil
}

// SetOutcomeMeasureAnticipatedPostingDate sets the "outcome_measure_anticipated_posting_date" field.
func (m *OutcomeMeasureMutation) SetOutcomeMeasureAnticipatedPostingDate(s string) {
	m.outcome_measure_anticipated_posting_date = &s
}

// OutcomeMeasureAnticipatedPostingDate returns the value of the "outcome_measure_anticipated_posting_date" field in the mutation.
func (m *OutcomeMeasureMutation) OutcomeMeasureAnticipatedPostingDate() (r string, exists bool) {
	v := m.outcome_measure_anticipated_posting_date
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeMeasureAnticipatedPostingDate returns the old "outcome_measure_anticipated_posting_date" field's value of the OutcomeMeasure entity.
// If the OutcomeMeasure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeMeasureMutation) OldOutcomeMeasureAnticipatedPostingDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeMeasureAnticipatedPostingDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeMeasureAnticipatedPostingDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeMeasureAnticipatedPostingDate: %w", err)
	}
	return oldValue.OutcomeMeasureAnticipatedPostingDate, nil
}

// ResetOutcomeMeasureAnticipatedPostingDate resets all changes to the "outcome_measure_anticipated_posting_date" field.
func (m *OutcomeMeasureMutation) ResetOutcomeMeasureAnticipatedPostingDate() {
	m.outcome_measure_anticipated_posting_date = nil
}

// SetOutcomeMeasureParamType sets the "outcome_measure_param_type" field.
func (m *OutcomeMeasureMutation) SetOutcomeMeasureParamType(s string) {
	m.outcome_measure_param_type = &s
}

// OutcomeMeasureParamType returns the value of the "outcome_measure_param_type" field in the mutation.
func (m *OutcomeMeasureMutation) OutcomeMeasureParamType() (r string, exists bool) {
	v := m.outcome_measure_param_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeMeasureParamType returns the old "outcome_measure_param_type" field's value of the OutcomeMeasure entity.
// If the OutcomeMeasure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeMeasureMutation) OldOutcomeMeasureParamType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeMeasureParamType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeMeasureParamType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeMeasureParamType: %w", err)
	}
	return oldValue.OutcomeMeasureParamType, nil
}

// ResetOutcomeMeasureParamType resets all changes to the "outcome_measure_param_type" field.
func (m *OutcomeMeasureMutation) ResetOutcomeMeasureParamType() {
	m.outcome_measure_param_type = nil
}

// SetOutcomeMeasureDispersionType sets the "outcome_measure_dispersion_type" field.
func (m *OutcomeMeasureMutation) SetOutcomeMeasureDispersionType(s string) {
	m.outcome_measure_dispersion_type = &s
}

// OutcomeMeasureDispersionType returns the value of the "outcome_measure_dispersion_type" field in the mutation.
func (m *OutcomeMeasureMutation) OutcomeMeasureDispersionType() (r string, exists bool) {
	v := m.outcome_measure_dispersion_type
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeMeasureDispersionType returns the old "outcome_measure_dispersion_type" field's value of the OutcomeMeasure entity.
// If the OutcomeMeasure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeMeasureMutation) OldOutcomeMeasureDispersionType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeMeasureDispersionType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeMeasureDispersionType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeMeasureDispersionType: %w", err)
	}
	return oldValue.OutcomeMeasureDispersionType, nil
}

// ResetOutcomeMeasureDispersionType resets all changes to the "outcome_measure_dispersion_type" field.
func (m *OutcomeMeasureMutation) ResetOutcomeMeasureDispersionType() {
	m.outcome_measure_dispersion_type = nil
}

// SetOutcomeMeasureUnitOfMeasure sets the "outcome_measure_unit_of_measure" field.
func (m *OutcomeMeasureMutation) SetOutcomeMeasureUnitOfMeasure(s string) {
	m.outcome_measure_unit_of_measure = &s
}

// OutcomeMeasureUnitOfMeasure returns the value of the "outcome_measure_unit_of_measure" field in the mutation.
func (m *OutcomeMeasureMutation) OutcomeMeasureUnitOfMeasure() (r string, exists bool) {
	v := m.outcome_measure_unit_of_measure
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeMeasureUnitOfMeasure returns the old "outcome_measure_unit_of_measure" field's value of the OutcomeMeasure entity.
// If the OutcomeMeasure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeMeasureMutation) OldOutcomeMeasureUnitOfMeasure(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeMeasureUnitOfMeasure is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeMeasureUnitOfMeasure requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeMeasureUnitOfMeasure: %w", err)
	}
	return oldValue.OutcomeMeasureUnitOfMeasure, nil
}

// ResetOutcomeMeasureUnitOfMeasure resets all changes to the "outcome_measure_unit_of_measure" field.
func (m *OutcomeMeasureMutation) ResetOutcomeMeasureUnitOfMeasure() {
	m.outcome_measure_unit_of_measure = nil
}

// SetOutcomeMeasureCalculatePct sets the "outcome_measure_calculate_pct" field.
func (m *OutcomeMeasureMutation) SetOutcomeMeasureCalculatePct(s string) {
	m.outcome_measure_calculate_pct = &s
}

// OutcomeMeasureCalculatePct returns the value of the "outcome_measure_calculate_pct" field in the mutation.
func (m *OutcomeMeasureMutation) OutcomeMeasureCalculatePct() (r string, exists bool) {
	v := m.outcome_measure_calculate_pct
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeMeasureCalculatePct returns the old "outcome_measure_calculate_pct" field's value of the OutcomeMeasure entity.
// If the OutcomeMeasure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeMeasureMutation) OldOutcomeMeasureCalculatePct(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeMeasureCalculatePct is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeMeasureCalculatePct requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeMeasureCalculatePct: %w", err)
	}
	return oldValue.OutcomeMeasureCalculatePct, nil
}

// ResetOutcomeMeasureCalculatePct resets all changes to the "outcome_measure_calculate_pct" field.
func (m *OutcomeMeasureMutation) ResetOutcomeMeasureCalculatePct() {
	m.outcome_measure_calculate_pct = nil
}

// SetOutcomeMeasureTimeFrame sets the "outcome_measure_time_frame" field.
func (m *OutcomeMeasureMutation) SetOutcomeMeasureTimeFrame(s string) {
	m.outcome_measure_time_frame = &s
}

// OutcomeMeasureTimeFrame returns the value of the "outcome_measure_time_frame" field in the mutation.
func (m *OutcomeMeasureMutation) OutcomeMeasureTimeFrame() (r string, exists bool) {
	v := m.outcome_measure_time_frame
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeMeasureTimeFrame returns the old "outcome_measure_time_frame" field's value of the OutcomeMeasure entity.
// If the OutcomeMeasure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeMeasureMutation) OldOutcomeMeasureTimeFrame(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeMeasureTimeFrame is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeMeasureTimeFrame requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeMeasureTimeFrame: %w", err)
	}
	return oldValue.OutcomeMeasureTimeFrame, nil
}

// ResetOutcomeMeasureTimeFrame resets all changes to the "outcome_measure_time_frame" field.
func (m *OutcomeMeasureMutation) ResetOutcomeMeasureTimeFrame() {
	m.outcome_measure_time_frame = nil
}

// SetOutcomeMeasureTypeUnitsAnalyzed sets the "outcome_measure_type_units_analyzed" field.
func (m *OutcomeMeasureMutation) SetOutcomeMeasureTypeUnitsAnalyzed(s string) {
	m.outcome_measure_type_units_analyzed = &s
}

// OutcomeMeasureTypeUnitsAnalyzed returns the value of the "outcome_measure_type_units_analyzed" field in the mutation.
func (m *OutcomeMeasureMutation) OutcomeMeasureTypeUnitsAnalyzed() (r string, exists bool) {
	v := m.outcome_measure_type_units_analyzed
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeMeasureTypeUnitsAnalyzed returns the old "outcome_measure_type_units_analyzed" field's value of the OutcomeMeasure entity.
// If the OutcomeMeasure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeMeasureMutation) OldOutcomeMeasureTypeUnitsAnalyzed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeMeasureTypeUnitsAnalyzed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeMeasureTypeUnitsAnalyzed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeMeasureTypeUnitsAnalyzed: %w", err)
	}
	return oldValue.OutcomeMeasureTypeUnitsAnalyzed, nil
}

// ResetOutcomeMeasureTypeUnitsAnalyzed resets all changes to the "outcome_measure_type_units_analyzed" field.
func (m *OutcomeMeasureMutation) ResetOutcomeMeasureTypeUnitsAnalyzed() {
	m.outcome_measure_type_units_analyzed = nil
}

// SetOutcomeMeasureDenomUnitsSelected sets the "outcome_measure_denom_units_selected" field.
func (m *OutcomeMeasureMutation) SetOutcomeMeasureDenomUnitsSelected(s string) {
	m.outcome_measure_denom_units_selected = &s
}

// OutcomeMeasureDenomUnitsSelected returns the value of the "outcome_measure_denom_units_selected" field in the mutation.
func (m *OutcomeMeasureMutation) OutcomeMeasureDenomUnitsSelected() (r string, exists bool) {
	v := m.outcome_measure_denom_units_selected
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeMeasureDenomUnitsSelected returns the old "outcome_measure_denom_units_selected" field's value of the OutcomeMeasure entity.
// If the OutcomeMeasure object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeMeasureMutation) OldOutcomeMeasureDenomUnitsSelected(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeMeasureDenomUnitsSelected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeMeasureDenomUnitsSelected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeMeasureDenomUnitsSelected: %w", err)
	}
	return oldValue.OutcomeMeasureDenomUnitsSelected, nil
}

// ResetOutcomeMeasureDenomUnitsSelected resets all changes to the "outcome_measure_denom_units_selected" field.
func (m *OutcomeMeasureMutation) ResetOutcomeMeasureDenomUnitsSelected() {
	m.outcome_measure_denom_units_selected = nil
}

// SetParentID sets the "parent" edge to the OutcomeMeasuresModule entity by id.
func (m *OutcomeMeasureMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the OutcomeMeasuresModule entity.
func (m *OutcomeMeasureMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the OutcomeMeasuresModule entity was cleared.
func (m *OutcomeMeasureMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *OutcomeMeasureMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *OutcomeMeasureMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *OutcomeMeasureMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddOutcomeGroupListIDs adds the "outcome_group_list" edge to the OutcomeGroup entity by ids.
func (m *OutcomeMeasureMutation) AddOutcomeGroupListIDs(ids ...int) {
	if m.outcome_group_list == nil {
		m.outcome_group_list = make(map[int]struct{})
	}
	for i := range ids {
		m.outcome_group_list[ids[i]] = struct{}{}
	}
}

// ClearOutcomeGroupList clears the "outcome_group_list" edge to the OutcomeGroup entity.
func (m *OutcomeMeasureMutation) ClearOutcomeGroupList() {
	m.clearedoutcome_group_list = true
}

// OutcomeGroupListCleared reports if the "outcome_group_list" edge to the OutcomeGroup entity was cleared.
func (m *OutcomeMeasureMutation) OutcomeGroupListCleared() bool {
	return m.clearedoutcome_group_list
}

// RemoveOutcomeGroupListIDs removes the "outcome_group_list" edge to the OutcomeGroup entity by IDs.
func (m *OutcomeMeasureMutation) RemoveOutcomeGroupListIDs(ids ...int) {
	if m.removedoutcome_group_list == nil {
		m.removedoutcome_group_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.outcome_group_list, ids[i])
		m.removedoutcome_group_list[ids[i]] = struct{}{}
	}
}

// RemovedOutcomeGroupList returns the removed IDs of the "outcome_group_list" edge to the OutcomeGroup entity.
func (m *OutcomeMeasureMutation) RemovedOutcomeGroupListIDs() (ids []int) {
	for id := range m.removedoutcome_group_list {
		ids = append(ids, id)
	}
	return
}

// OutcomeGroupListIDs returns the "outcome_group_list" edge IDs in the mutation.
func (m *OutcomeMeasureMutation) OutcomeGroupListIDs() (ids []int) {
	for id := range m.outcome_group_list {
		ids = append(ids, id)
	}
	return
}

// ResetOutcomeGroupList resets all changes to the "outcome_group_list" edge.
func (m *OutcomeMeasureMutation) ResetOutcomeGroupList() {
	m.outcome_group_list = nil
	m.clearedoutcome_group_list = false
	m.removedoutcome_group_list = nil
}

// AddOutcomeOverviewListIDs adds the "outcome_overview_list" edge to the OutcomeOverview entity by ids.
func (m *OutcomeMeasureMutation) AddOutcomeOverviewListIDs(ids ...int) {
	if m.outcome_overview_list == nil {
		m.outcome_overview_list = make(map[int]struct{})
	}
	for i := range ids {
		m.outcome_overview_list[ids[i]] = struct{}{}
	}
}

// ClearOutcomeOverviewList clears the "outcome_overview_list" edge to the OutcomeOverview entity.
func (m *OutcomeMeasureMutation) ClearOutcomeOverviewList() {
	m.clearedoutcome_overview_list = true
}

// OutcomeOverviewListCleared reports if the "outcome_overview_list" edge to the OutcomeOverview entity was cleared.
func (m *OutcomeMeasureMutation) OutcomeOverviewListCleared() bool {
	return m.clearedoutcome_overview_list
}

// RemoveOutcomeOverviewListIDs removes the "outcome_overview_list" edge to the OutcomeOverview entity by IDs.
func (m *OutcomeMeasureMutation) RemoveOutcomeOverviewListIDs(ids ...int) {
	if m.removedoutcome_overview_list == nil {
		m.removedoutcome_overview_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.outcome_overview_list, ids[i])
		m.removedoutcome_overview_list[ids[i]] = struct{}{}
	}
}

// RemovedOutcomeOverviewList returns the removed IDs of the "outcome_overview_list" edge to the OutcomeOverview entity.
func (m *OutcomeMeasureMutation) RemovedOutcomeOverviewListIDs() (ids []int) {
	for id := range m.removedoutcome_overview_list {
		ids = append(ids, id)
	}
	return
}

// OutcomeOverviewListIDs returns the "outcome_overview_list" edge IDs in the mutation.
func (m *OutcomeMeasureMutation) OutcomeOverviewListIDs() (ids []int) {
	for id := range m.outcome_overview_list {
		ids = append(ids, id)
	}
	return
}

// ResetOutcomeOverviewList resets all changes to the "outcome_overview_list" edge.
func (m *OutcomeMeasureMutation) ResetOutcomeOverviewList() {
	m.outcome_overview_list = nil
	m.clearedoutcome_overview_list = false
	m.removedoutcome_overview_list = nil
}

// AddOutcomeDenomListIDs adds the "outcome_denom_list" edge to the OutcomeDenom entity by ids.
func (m *OutcomeMeasureMutation) AddOutcomeDenomListIDs(ids ...int) {
	if m.outcome_denom_list == nil {
		m.outcome_denom_list = make(map[int]struct{})
	}
	for i := range ids {
		m.outcome_denom_list[ids[i]] = struct{}{}
	}
}

// ClearOutcomeDenomList clears the "outcome_denom_list" edge to the OutcomeDenom entity.
func (m *OutcomeMeasureMutation) ClearOutcomeDenomList() {
	m.clearedoutcome_denom_list = true
}

// OutcomeDenomListCleared reports if the "outcome_denom_list" edge to the OutcomeDenom entity was cleared.
func (m *OutcomeMeasureMutation) OutcomeDenomListCleared() bool {
	return m.clearedoutcome_denom_list
}

// RemoveOutcomeDenomListIDs removes the "outcome_denom_list" edge to the OutcomeDenom entity by IDs.
func (m *OutcomeMeasureMutation) RemoveOutcomeDenomListIDs(ids ...int) {
	if m.removedoutcome_denom_list == nil {
		m.removedoutcome_denom_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.outcome_denom_list, ids[i])
		m.removedoutcome_denom_list[ids[i]] = struct{}{}
	}
}

// RemovedOutcomeDenomList returns the removed IDs of the "outcome_denom_list" edge to the OutcomeDenom entity.
func (m *OutcomeMeasureMutation) RemovedOutcomeDenomListIDs() (ids []int) {
	for id := range m.removedoutcome_denom_list {
		ids = append(ids, id)
	}
	return
}

// OutcomeDenomListIDs returns the "outcome_denom_list" edge IDs in the mutation.
func (m *OutcomeMeasureMutation) OutcomeDenomListIDs() (ids []int) {
	for id := range m.outcome_denom_list {
		ids = append(ids, id)
	}
	return
}

// ResetOutcomeDenomList resets all changes to the "outcome_denom_list" edge.
func (m *OutcomeMeasureMutation) ResetOutcomeDenomList() {
	m.outcome_denom_list = nil
	m.clearedoutcome_denom_list = false
	m.removedoutcome_denom_list = nil
}

// AddOutcomeClassListIDs adds the "outcome_class_list" edge to the OutcomeClass entity by ids.
func (m *OutcomeMeasureMutation) AddOutcomeClassListIDs(ids ...int) {
	if m.outcome_class_list == nil {
		m.outcome_class_list = make(map[int]struct{})
	}
	for i := range ids {
		m.outcome_class_list[ids[i]] = struct{}{}
	}
}

// ClearOutcomeClassList clears the "outcome_class_list" edge to the OutcomeClass entity.
func (m *OutcomeMeasureMutation) ClearOutcomeClassList() {
	m.clearedoutcome_class_list = true
}

// OutcomeClassListCleared reports if the "outcome_class_list" edge to the OutcomeClass entity was cleared.
func (m *OutcomeMeasureMutation) OutcomeClassListCleared() bool {
	return m.clearedoutcome_class_list
}

// RemoveOutcomeClassListIDs removes the "outcome_class_list" edge to the OutcomeClass entity by IDs.
func (m *OutcomeMeasureMutation) RemoveOutcomeClassListIDs(ids ...int) {
	if m.removedoutcome_class_list == nil {
		m.removedoutcome_class_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.outcome_class_list, ids[i])
		m.removedoutcome_class_list[ids[i]] = struct{}{}
	}
}

// RemovedOutcomeClassList returns the removed IDs of the "outcome_class_list" edge to the OutcomeClass entity.
func (m *OutcomeMeasureMutation) RemovedOutcomeClassListIDs() (ids []int) {
	for id := range m.removedoutcome_class_list {
		ids = append(ids, id)
	}
	return
}

// OutcomeClassListIDs returns the "outcome_class_list" edge IDs in the mutation.
func (m *OutcomeMeasureMutation) OutcomeClassListIDs() (ids []int) {
	for id := range m.outcome_class_list {
		ids = append(ids, id)
	}
	return
}

// ResetOutcomeClassList resets all changes to the "outcome_class_list" edge.
func (m *OutcomeMeasureMutation) ResetOutcomeClassList() {
	m.outcome_class_list = nil
	m.clearedoutcome_class_list = false
	m.removedoutcome_class_list = nil
}

// AddOutcomeAnalysisListIDs adds the "outcome_analysis_list" edge to the OutcomeAnalysis entity by ids.
func (m *OutcomeMeasureMutation) AddOutcomeAnalysisListIDs(ids ...int) {
	if m.outcome_analysis_list == nil {
		m.outcome_analysis_list = make(map[int]struct{})
	}
	for i := range ids {
		m.outcome_analysis_list[ids[i]] = struct{}{}
	}
}

// ClearOutcomeAnalysisList clears the "outcome_analysis_list" edge to the OutcomeAnalysis entity.
func (m *OutcomeMeasureMutation) ClearOutcomeAnalysisList() {
	m.clearedoutcome_analysis_list = true
}

// OutcomeAnalysisListCleared reports if the "outcome_analysis_list" edge to the OutcomeAnalysis entity was cleared.
func (m *OutcomeMeasureMutation) OutcomeAnalysisListCleared() bool {
	return m.clearedoutcome_analysis_list
}

// RemoveOutcomeAnalysisListIDs removes the "outcome_analysis_list" edge to the OutcomeAnalysis entity by IDs.
func (m *OutcomeMeasureMutation) RemoveOutcomeAnalysisListIDs(ids ...int) {
	if m.removedoutcome_analysis_list == nil {
		m.removedoutcome_analysis_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.outcome_analysis_list, ids[i])
		m.removedoutcome_analysis_list[ids[i]] = struct{}{}
	}
}

// RemovedOutcomeAnalysisList returns the removed IDs of the "outcome_analysis_list" edge to the OutcomeAnalysis entity.
func (m *OutcomeMeasureMutation) RemovedOutcomeAnalysisListIDs() (ids []int) {
	for id := range m.removedoutcome_analysis_list {
		ids = append(ids, id)
	}
	return
}

// OutcomeAnalysisListIDs returns the "outcome_analysis_list" edge IDs in the mutation.
func (m *OutcomeMeasureMutation) OutcomeAnalysisListIDs() (ids []int) {
	for id := range m.outcome_analysis_list {
		ids = append(ids, id)
	}
	return
}

// ResetOutcomeAnalysisList resets all changes to the "outcome_analysis_list" edge.
func (m *OutcomeMeasureMutation) ResetOutcomeAnalysisList() {
	m.outcome_analysis_list = nil
	m.clearedoutcome_analysis_list = false
	m.removedoutcome_analysis_list = nil
}

// Where appends a list predicates to the OutcomeMeasureMutation builder.
func (m *OutcomeMeasureMutation) Where(ps ...predicate.OutcomeMeasure) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OutcomeMeasureMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OutcomeMeasure).
func (m *OutcomeMeasureMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OutcomeMeasureMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.outcome_measure_type != nil {
		fields = append(fields, outcomemeasure.FieldOutcomeMeasureType)
	}
	if m.outcome_measure_title != nil {
		fields = append(fields, outcomemeasure.FieldOutcomeMeasureTitle)
	}
	if m.outcome_measure_description != nil {
		fields = append(fields, outcomemeasure.FieldOutcomeMeasureDescription)
	}
	if m.outcome_measure_population_description != nil {
		fields = append(fields, outcomemeasure.FieldOutcomeMeasurePopulationDescription)
	}
	if m.outcome_measure_reporting_status != nil {
		fields = append(fields, outcomemeasure.FieldOutcomeMeasureReportingStatus)
	}
	if m.outcome_measure_anticipated_posting_date != nil {
		fields = append(fields, outcomemeasure.FieldOutcomeMeasureAnticipatedPostingDate)
	}
	if m.outcome_measure_param_type != nil {
		fields = append(fields, outcomemeasure.FieldOutcomeMeasureParamType)
	}
	if m.outcome_measure_dispersion_type != nil {
		fields = append(fields, outcomemeasure.FieldOutcomeMeasureDispersionType)
	}
	if m.outcome_measure_unit_of_measure != nil {
		fields = append(fields, outcomemeasure.FieldOutcomeMeasureUnitOfMeasure)
	}
	if m.outcome_measure_calculate_pct != nil {
		fields = append(fields, outcomemeasure.FieldOutcomeMeasureCalculatePct)
	}
	if m.outcome_measure_time_frame != nil {
		fields = append(fields, outcomemeasure.FieldOutcomeMeasureTimeFrame)
	}
	if m.outcome_measure_type_units_analyzed != nil {
		fields = append(fields, outcomemeasure.FieldOutcomeMeasureTypeUnitsAnalyzed)
	}
	if m.outcome_measure_denom_units_selected != nil {
		fields = append(fields, outcomemeasure.FieldOutcomeMeasureDenomUnitsSelected)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OutcomeMeasureMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case outcomemeasure.FieldOutcomeMeasureType:
		return m.OutcomeMeasureType()
	case outcomemeasure.FieldOutcomeMeasureTitle:
		return m.OutcomeMeasureTitle()
	case outcomemeasure.FieldOutcomeMeasureDescription:
		return m.OutcomeMeasureDescription()
	case outcomemeasure.FieldOutcomeMeasurePopulationDescription:
		return m.OutcomeMeasurePopulationDescription()
	case outcomemeasure.FieldOutcomeMeasureReportingStatus:
		return m.OutcomeMeasureReportingStatus()
	case outcomemeasure.FieldOutcomeMeasureAnticipatedPostingDate:
		return m.OutcomeMeasureAnticipatedPostingDate()
	case outcomemeasure.FieldOutcomeMeasureParamType:
		return m.OutcomeMeasureParamType()
	case outcomemeasure.FieldOutcomeMeasureDispersionType:
		return m.OutcomeMeasureDispersionType()
	case outcomemeasure.FieldOutcomeMeasureUnitOfMeasure:
		return m.OutcomeMeasureUnitOfMeasure()
	case outcomemeasure.FieldOutcomeMeasureCalculatePct:
		return m.OutcomeMeasureCalculatePct()
	case outcomemeasure.FieldOutcomeMeasureTimeFrame:
		return m.OutcomeMeasureTimeFrame()
	case outcomemeasure.FieldOutcomeMeasureTypeUnitsAnalyzed:
		return m.OutcomeMeasureTypeUnitsAnalyzed()
	case outcomemeasure.FieldOutcomeMeasureDenomUnitsSelected:
		return m.OutcomeMeasureDenomUnitsSelected()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OutcomeMeasureMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case outcomemeasure.FieldOutcomeMeasureType:
		return m.OldOutcomeMeasureType(ctx)
	case outcomemeasure.FieldOutcomeMeasureTitle:
		return m.OldOutcomeMeasureTitle(ctx)
	case outcomemeasure.FieldOutcomeMeasureDescription:
		return m.OldOutcomeMeasureDescription(ctx)
	case outcomemeasure.FieldOutcomeMeasurePopulationDescription:
		return m.OldOutcomeMeasurePopulationDescription(ctx)
	case outcomemeasure.FieldOutcomeMeasureReportingStatus:
		return m.OldOutcomeMeasureReportingStatus(ctx)
	case outcomemeasure.FieldOutcomeMeasureAnticipatedPostingDate:
		return m.OldOutcomeMeasureAnticipatedPostingDate(ctx)
	case outcomemeasure.FieldOutcomeMeasureParamType:
		return m.OldOutcomeMeasureParamType(ctx)
	case outcomemeasure.FieldOutcomeMeasureDispersionType:
		return m.OldOutcomeMeasureDispersionType(ctx)
	case outcomemeasure.FieldOutcomeMeasureUnitOfMeasure:
		return m.OldOutcomeMeasureUnitOfMeasure(ctx)
	case outcomemeasure.FieldOutcomeMeasureCalculatePct:
		return m.OldOutcomeMeasureCalculatePct(ctx)
	case outcomemeasure.FieldOutcomeMeasureTimeFrame:
		return m.OldOutcomeMeasureTimeFrame(ctx)
	case outcomemeasure.FieldOutcomeMeasureTypeUnitsAnalyzed:
		return m.OldOutcomeMeasureTypeUnitsAnalyzed(ctx)
	case outcomemeasure.FieldOutcomeMeasureDenomUnitsSelected:
		return m.OldOutcomeMeasureDenomUnitsSelected(ctx)
	}
	return nil, fmt.Errorf("unknown OutcomeMeasure field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutcomeMeasureMutation) SetField(name string, value ent.Value) error {
	switch name {
	case outcomemeasure.FieldOutcomeMeasureType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeMeasureType(v)
		return nil
	case outcomemeasure.FieldOutcomeMeasureTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeMeasureTitle(v)
		return nil
	case outcomemeasure.FieldOutcomeMeasureDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeMeasureDescription(v)
		return nil
	case outcomemeasure.FieldOutcomeMeasurePopulationDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeMeasurePopulationDescription(v)
		return nil
	case outcomemeasure.FieldOutcomeMeasureReportingStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeMeasureReportingStatus(v)
		return nil
	case outcomemeasure.FieldOutcomeMeasureAnticipatedPostingDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeMeasureAnticipatedPostingDate(v)
		return nil
	case outcomemeasure.FieldOutcomeMeasureParamType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeMeasureParamType(v)
		return nil
	case outcomemeasure.FieldOutcomeMeasureDispersionType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeMeasureDispersionType(v)
		return nil
	case outcomemeasure.FieldOutcomeMeasureUnitOfMeasure:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeMeasureUnitOfMeasure(v)
		return nil
	case outcomemeasure.FieldOutcomeMeasureCalculatePct:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeMeasureCalculatePct(v)
		return nil
	case outcomemeasure.FieldOutcomeMeasureTimeFrame:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeMeasureTimeFrame(v)
		return nil
	case outcomemeasure.FieldOutcomeMeasureTypeUnitsAnalyzed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeMeasureTypeUnitsAnalyzed(v)
		return nil
	case outcomemeasure.FieldOutcomeMeasureDenomUnitsSelected:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeMeasureDenomUnitsSelected(v)
		return nil
	}
	return fmt.Errorf("unknown OutcomeMeasure field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OutcomeMeasureMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OutcomeMeasureMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutcomeMeasureMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OutcomeMeasure numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OutcomeMeasureMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OutcomeMeasureMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OutcomeMeasureMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OutcomeMeasure nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OutcomeMeasureMutation) ResetField(name string) error {
	switch name {
	case outcomemeasure.FieldOutcomeMeasureType:
		m.ResetOutcomeMeasureType()
		return nil
	case outcomemeasure.FieldOutcomeMeasureTitle:
		m.ResetOutcomeMeasureTitle()
		return nil
	case outcomemeasure.FieldOutcomeMeasureDescription:
		m.ResetOutcomeMeasureDescription()
		return nil
	case outcomemeasure.FieldOutcomeMeasurePopulationDescription:
		m.ResetOutcomeMeasurePopulationDescription()
		return nil
	case outcomemeasure.FieldOutcomeMeasureReportingStatus:
		m.ResetOutcomeMeasureReportingStatus()
		return nil
	case outcomemeasure.FieldOutcomeMeasureAnticipatedPostingDate:
		m.ResetOutcomeMeasureAnticipatedPostingDate()
		return nil
	case outcomemeasure.FieldOutcomeMeasureParamType:
		m.ResetOutcomeMeasureParamType()
		return nil
	case outcomemeasure.FieldOutcomeMeasureDispersionType:
		m.ResetOutcomeMeasureDispersionType()
		return nil
	case outcomemeasure.FieldOutcomeMeasureUnitOfMeasure:
		m.ResetOutcomeMeasureUnitOfMeasure()
		return nil
	case outcomemeasure.FieldOutcomeMeasureCalculatePct:
		m.ResetOutcomeMeasureCalculatePct()
		return nil
	case outcomemeasure.FieldOutcomeMeasureTimeFrame:
		m.ResetOutcomeMeasureTimeFrame()
		return nil
	case outcomemeasure.FieldOutcomeMeasureTypeUnitsAnalyzed:
		m.ResetOutcomeMeasureTypeUnitsAnalyzed()
		return nil
	case outcomemeasure.FieldOutcomeMeasureDenomUnitsSelected:
		m.ResetOutcomeMeasureDenomUnitsSelected()
		return nil
	}
	return fmt.Errorf("unknown OutcomeMeasure field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OutcomeMeasureMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.parent != nil {
		edges = append(edges, outcomemeasure.EdgeParent)
	}
	if m.outcome_group_list != nil {
		edges = append(edges, outcomemeasure.EdgeOutcomeGroupList)
	}
	if m.outcome_overview_list != nil {
		edges = append(edges, outcomemeasure.EdgeOutcomeOverviewList)
	}
	if m.outcome_denom_list != nil {
		edges = append(edges, outcomemeasure.EdgeOutcomeDenomList)
	}
	if m.outcome_class_list != nil {
		edges = append(edges, outcomemeasure.EdgeOutcomeClassList)
	}
	if m.outcome_analysis_list != nil {
		edges = append(edges, outcomemeasure.EdgeOutcomeAnalysisList)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OutcomeMeasureMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case outcomemeasure.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case outcomemeasure.EdgeOutcomeGroupList:
		ids := make([]ent.Value, 0, len(m.outcome_group_list))
		for id := range m.outcome_group_list {
			ids = append(ids, id)
		}
		return ids
	case outcomemeasure.EdgeOutcomeOverviewList:
		ids := make([]ent.Value, 0, len(m.outcome_overview_list))
		for id := range m.outcome_overview_list {
			ids = append(ids, id)
		}
		return ids
	case outcomemeasure.EdgeOutcomeDenomList:
		ids := make([]ent.Value, 0, len(m.outcome_denom_list))
		for id := range m.outcome_denom_list {
			ids = append(ids, id)
		}
		return ids
	case outcomemeasure.EdgeOutcomeClassList:
		ids := make([]ent.Value, 0, len(m.outcome_class_list))
		for id := range m.outcome_class_list {
			ids = append(ids, id)
		}
		return ids
	case outcomemeasure.EdgeOutcomeAnalysisList:
		ids := make([]ent.Value, 0, len(m.outcome_analysis_list))
		for id := range m.outcome_analysis_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OutcomeMeasureMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedoutcome_group_list != nil {
		edges = append(edges, outcomemeasure.EdgeOutcomeGroupList)
	}
	if m.removedoutcome_overview_list != nil {
		edges = append(edges, outcomemeasure.EdgeOutcomeOverviewList)
	}
	if m.removedoutcome_denom_list != nil {
		edges = append(edges, outcomemeasure.EdgeOutcomeDenomList)
	}
	if m.removedoutcome_class_list != nil {
		edges = append(edges, outcomemeasure.EdgeOutcomeClassList)
	}
	if m.removedoutcome_analysis_list != nil {
		edges = append(edges, outcomemeasure.EdgeOutcomeAnalysisList)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OutcomeMeasureMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case outcomemeasure.EdgeOutcomeGroupList:
		ids := make([]ent.Value, 0, len(m.removedoutcome_group_list))
		for id := range m.removedoutcome_group_list {
			ids = append(ids, id)
		}
		return ids
	case outcomemeasure.EdgeOutcomeOverviewList:
		ids := make([]ent.Value, 0, len(m.removedoutcome_overview_list))
		for id := range m.removedoutcome_overview_list {
			ids = append(ids, id)
		}
		return ids
	case outcomemeasure.EdgeOutcomeDenomList:
		ids := make([]ent.Value, 0, len(m.removedoutcome_denom_list))
		for id := range m.removedoutcome_denom_list {
			ids = append(ids, id)
		}
		return ids
	case outcomemeasure.EdgeOutcomeClassList:
		ids := make([]ent.Value, 0, len(m.removedoutcome_class_list))
		for id := range m.removedoutcome_class_list {
			ids = append(ids, id)
		}
		return ids
	case outcomemeasure.EdgeOutcomeAnalysisList:
		ids := make([]ent.Value, 0, len(m.removedoutcome_analysis_list))
		for id := range m.removedoutcome_analysis_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OutcomeMeasureMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedparent {
		edges = append(edges, outcomemeasure.EdgeParent)
	}
	if m.clearedoutcome_group_list {
		edges = append(edges, outcomemeasure.EdgeOutcomeGroupList)
	}
	if m.clearedoutcome_overview_list {
		edges = append(edges, outcomemeasure.EdgeOutcomeOverviewList)
	}
	if m.clearedoutcome_denom_list {
		edges = append(edges, outcomemeasure.EdgeOutcomeDenomList)
	}
	if m.clearedoutcome_class_list {
		edges = append(edges, outcomemeasure.EdgeOutcomeClassList)
	}
	if m.clearedoutcome_analysis_list {
		edges = append(edges, outcomemeasure.EdgeOutcomeAnalysisList)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OutcomeMeasureMutation) EdgeCleared(name string) bool {
	switch name {
	case outcomemeasure.EdgeParent:
		return m.clearedparent
	case outcomemeasure.EdgeOutcomeGroupList:
		return m.clearedoutcome_group_list
	case outcomemeasure.EdgeOutcomeOverviewList:
		return m.clearedoutcome_overview_list
	case outcomemeasure.EdgeOutcomeDenomList:
		return m.clearedoutcome_denom_list
	case outcomemeasure.EdgeOutcomeClassList:
		return m.clearedoutcome_class_list
	case outcomemeasure.EdgeOutcomeAnalysisList:
		return m.clearedoutcome_analysis_list
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OutcomeMeasureMutation) ClearEdge(name string) error {
	switch name {
	case outcomemeasure.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown OutcomeMeasure unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OutcomeMeasureMutation) ResetEdge(name string) error {
	switch name {
	case outcomemeasure.EdgeParent:
		m.ResetParent()
		return nil
	case outcomemeasure.EdgeOutcomeGroupList:
		m.ResetOutcomeGroupList()
		return nil
	case outcomemeasure.EdgeOutcomeOverviewList:
		m.ResetOutcomeOverviewList()
		return nil
	case outcomemeasure.EdgeOutcomeDenomList:
		m.ResetOutcomeDenomList()
		return nil
	case outcomemeasure.EdgeOutcomeClassList:
		m.ResetOutcomeClassList()
		return nil
	case outcomemeasure.EdgeOutcomeAnalysisList:
		m.ResetOutcomeAnalysisList()
		return nil
	}
	return fmt.Errorf("unknown OutcomeMeasure edge %s", name)
}

// OutcomeMeasurementMutation represents an operation that mutates the OutcomeMeasurement nodes in the graph.
type OutcomeMeasurementMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	outcome_measurement_group_id    *string
	outcome_measurement_value       *string
	outcome_measurement_spread      *string
	outcome_measurement_lower_limit *string
	outcome_measurement_upper_limit *string
	outcome_measurement_comment     *string
	clearedFields                   map[string]struct{}
	parent                          *int
	clearedparent                   bool
	done                            bool
	oldValue                        func(context.Context) (*OutcomeMeasurement, error)
	predicates                      []predicate.OutcomeMeasurement
}

var _ ent.Mutation = (*OutcomeMeasurementMutation)(nil)

// outcomemeasurementOption allows management of the mutation configuration using functional options.
type outcomemeasurementOption func(*OutcomeMeasurementMutation)

// newOutcomeMeasurementMutation creates new mutation for the OutcomeMeasurement entity.
func newOutcomeMeasurementMutation(c config, op Op, opts ...outcomemeasurementOption) *OutcomeMeasurementMutation {
	m := &OutcomeMeasurementMutation{
		config:        c,
		op:            op,
		typ:           TypeOutcomeMeasurement,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOutcomeMeasurementID sets the ID field of the mutation.
func withOutcomeMeasurementID(id int) outcomemeasurementOption {
	return func(m *OutcomeMeasurementMutation) {
		var (
			err   error
			once  sync.Once
			value *OutcomeMeasurement
		)
		m.oldValue = func(ctx context.Context) (*OutcomeMeasurement, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OutcomeMeasurement.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOutcomeMeasurement sets the old OutcomeMeasurement of the mutation.
func withOutcomeMeasurement(node *OutcomeMeasurement) outcomemeasurementOption {
	return func(m *OutcomeMeasurementMutation) {
		m.oldValue = func(context.Context) (*OutcomeMeasurement, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OutcomeMeasurementMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OutcomeMeasurementMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OutcomeMeasurementMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OutcomeMeasurementMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OutcomeMeasurement.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOutcomeMeasurementGroupID sets the "outcome_measurement_group_id" field.
func (m *OutcomeMeasurementMutation) SetOutcomeMeasurementGroupID(s string) {
	m.outcome_measurement_group_id = &s
}

// OutcomeMeasurementGroupID returns the value of the "outcome_measurement_group_id" field in the mutation.
func (m *OutcomeMeasurementMutation) OutcomeMeasurementGroupID() (r string, exists bool) {
	v := m.outcome_measurement_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeMeasurementGroupID returns the old "outcome_measurement_group_id" field's value of the OutcomeMeasurement entity.
// If the OutcomeMeasurement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeMeasurementMutation) OldOutcomeMeasurementGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeMeasurementGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeMeasurementGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeMeasurementGroupID: %w", err)
	}
	return oldValue.OutcomeMeasurementGroupID, nil
}

// ResetOutcomeMeasurementGroupID resets all changes to the "outcome_measurement_group_id" field.
func (m *OutcomeMeasurementMutation) ResetOutcomeMeasurementGroupID() {
	m.outcome_measurement_group_id = nil
}

// SetOutcomeMeasurementValue sets the "outcome_measurement_value" field.
func (m *OutcomeMeasurementMutation) SetOutcomeMeasurementValue(s string) {
	m.outcome_measurement_value = &s
}

// OutcomeMeasurementValue returns the value of the "outcome_measurement_value" field in the mutation.
func (m *OutcomeMeasurementMutation) OutcomeMeasurementValue() (r string, exists bool) {
	v := m.outcome_measurement_value
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeMeasurementValue returns the old "outcome_measurement_value" field's value of the OutcomeMeasurement entity.
// If the OutcomeMeasurement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeMeasurementMutation) OldOutcomeMeasurementValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeMeasurementValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeMeasurementValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeMeasurementValue: %w", err)
	}
	return oldValue.OutcomeMeasurementValue, nil
}

// ResetOutcomeMeasurementValue resets all changes to the "outcome_measurement_value" field.
func (m *OutcomeMeasurementMutation) ResetOutcomeMeasurementValue() {
	m.outcome_measurement_value = nil
}

// SetOutcomeMeasurementSpread sets the "outcome_measurement_spread" field.
func (m *OutcomeMeasurementMutation) SetOutcomeMeasurementSpread(s string) {
	m.outcome_measurement_spread = &s
}

// OutcomeMeasurementSpread returns the value of the "outcome_measurement_spread" field in the mutation.
func (m *OutcomeMeasurementMutation) OutcomeMeasurementSpread() (r string, exists bool) {
	v := m.outcome_measurement_spread
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeMeasurementSpread returns the old "outcome_measurement_spread" field's value of the OutcomeMeasurement entity.
// If the OutcomeMeasurement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeMeasurementMutation) OldOutcomeMeasurementSpread(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeMeasurementSpread is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeMeasurementSpread requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeMeasurementSpread: %w", err)
	}
	return oldValue.OutcomeMeasurementSpread, nil
}

// ResetOutcomeMeasurementSpread resets all changes to the "outcome_measurement_spread" field.
func (m *OutcomeMeasurementMutation) ResetOutcomeMeasurementSpread() {
	m.outcome_measurement_spread = nil
}

// SetOutcomeMeasurementLowerLimit sets the "outcome_measurement_lower_limit" field.
func (m *OutcomeMeasurementMutation) SetOutcomeMeasurementLowerLimit(s string) {
	m.outcome_measurement_lower_limit = &s
}

// OutcomeMeasurementLowerLimit returns the value of the "outcome_measurement_lower_limit" field in the mutation.
func (m *OutcomeMeasurementMutation) OutcomeMeasurementLowerLimit() (r string, exists bool) {
	v := m.outcome_measurement_lower_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeMeasurementLowerLimit returns the old "outcome_measurement_lower_limit" field's value of the OutcomeMeasurement entity.
// If the OutcomeMeasurement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeMeasurementMutation) OldOutcomeMeasurementLowerLimit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeMeasurementLowerLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeMeasurementLowerLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeMeasurementLowerLimit: %w", err)
	}
	return oldValue.OutcomeMeasurementLowerLimit, nil
}

// ResetOutcomeMeasurementLowerLimit resets all changes to the "outcome_measurement_lower_limit" field.
func (m *OutcomeMeasurementMutation) ResetOutcomeMeasurementLowerLimit() {
	m.outcome_measurement_lower_limit = nil
}

// SetOutcomeMeasurementUpperLimit sets the "outcome_measurement_upper_limit" field.
func (m *OutcomeMeasurementMutation) SetOutcomeMeasurementUpperLimit(s string) {
	m.outcome_measurement_upper_limit = &s
}

// OutcomeMeasurementUpperLimit returns the value of the "outcome_measurement_upper_limit" field in the mutation.
func (m *OutcomeMeasurementMutation) OutcomeMeasurementUpperLimit() (r string, exists bool) {
	v := m.outcome_measurement_upper_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeMeasurementUpperLimit returns the old "outcome_measurement_upper_limit" field's value of the OutcomeMeasurement entity.
// If the OutcomeMeasurement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeMeasurementMutation) OldOutcomeMeasurementUpperLimit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeMeasurementUpperLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeMeasurementUpperLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeMeasurementUpperLimit: %w", err)
	}
	return oldValue.OutcomeMeasurementUpperLimit, nil
}

// ResetOutcomeMeasurementUpperLimit resets all changes to the "outcome_measurement_upper_limit" field.
func (m *OutcomeMeasurementMutation) ResetOutcomeMeasurementUpperLimit() {
	m.outcome_measurement_upper_limit = nil
}

// SetOutcomeMeasurementComment sets the "outcome_measurement_comment" field.
func (m *OutcomeMeasurementMutation) SetOutcomeMeasurementComment(s string) {
	m.outcome_measurement_comment = &s
}

// OutcomeMeasurementComment returns the value of the "outcome_measurement_comment" field in the mutation.
func (m *OutcomeMeasurementMutation) OutcomeMeasurementComment() (r string, exists bool) {
	v := m.outcome_measurement_comment
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeMeasurementComment returns the old "outcome_measurement_comment" field's value of the OutcomeMeasurement entity.
// If the OutcomeMeasurement object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeMeasurementMutation) OldOutcomeMeasurementComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeMeasurementComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeMeasurementComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeMeasurementComment: %w", err)
	}
	return oldValue.OutcomeMeasurementComment, nil
}

// ResetOutcomeMeasurementComment resets all changes to the "outcome_measurement_comment" field.
func (m *OutcomeMeasurementMutation) ResetOutcomeMeasurementComment() {
	m.outcome_measurement_comment = nil
}

// SetParentID sets the "parent" edge to the OutcomeCategory entity by id.
func (m *OutcomeMeasurementMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the OutcomeCategory entity.
func (m *OutcomeMeasurementMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the OutcomeCategory entity was cleared.
func (m *OutcomeMeasurementMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *OutcomeMeasurementMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *OutcomeMeasurementMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *OutcomeMeasurementMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// Where appends a list predicates to the OutcomeMeasurementMutation builder.
func (m *OutcomeMeasurementMutation) Where(ps ...predicate.OutcomeMeasurement) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OutcomeMeasurementMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OutcomeMeasurement).
func (m *OutcomeMeasurementMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OutcomeMeasurementMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.outcome_measurement_group_id != nil {
		fields = append(fields, outcomemeasurement.FieldOutcomeMeasurementGroupID)
	}
	if m.outcome_measurement_value != nil {
		fields = append(fields, outcomemeasurement.FieldOutcomeMeasurementValue)
	}
	if m.outcome_measurement_spread != nil {
		fields = append(fields, outcomemeasurement.FieldOutcomeMeasurementSpread)
	}
	if m.outcome_measurement_lower_limit != nil {
		fields = append(fields, outcomemeasurement.FieldOutcomeMeasurementLowerLimit)
	}
	if m.outcome_measurement_upper_limit != nil {
		fields = append(fields, outcomemeasurement.FieldOutcomeMeasurementUpperLimit)
	}
	if m.outcome_measurement_comment != nil {
		fields = append(fields, outcomemeasurement.FieldOutcomeMeasurementComment)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OutcomeMeasurementMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case outcomemeasurement.FieldOutcomeMeasurementGroupID:
		return m.OutcomeMeasurementGroupID()
	case outcomemeasurement.FieldOutcomeMeasurementValue:
		return m.OutcomeMeasurementValue()
	case outcomemeasurement.FieldOutcomeMeasurementSpread:
		return m.OutcomeMeasurementSpread()
	case outcomemeasurement.FieldOutcomeMeasurementLowerLimit:
		return m.OutcomeMeasurementLowerLimit()
	case outcomemeasurement.FieldOutcomeMeasurementUpperLimit:
		return m.OutcomeMeasurementUpperLimit()
	case outcomemeasurement.FieldOutcomeMeasurementComment:
		return m.OutcomeMeasurementComment()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OutcomeMeasurementMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case outcomemeasurement.FieldOutcomeMeasurementGroupID:
		return m.OldOutcomeMeasurementGroupID(ctx)
	case outcomemeasurement.FieldOutcomeMeasurementValue:
		return m.OldOutcomeMeasurementValue(ctx)
	case outcomemeasurement.FieldOutcomeMeasurementSpread:
		return m.OldOutcomeMeasurementSpread(ctx)
	case outcomemeasurement.FieldOutcomeMeasurementLowerLimit:
		return m.OldOutcomeMeasurementLowerLimit(ctx)
	case outcomemeasurement.FieldOutcomeMeasurementUpperLimit:
		return m.OldOutcomeMeasurementUpperLimit(ctx)
	case outcomemeasurement.FieldOutcomeMeasurementComment:
		return m.OldOutcomeMeasurementComment(ctx)
	}
	return nil, fmt.Errorf("unknown OutcomeMeasurement field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutcomeMeasurementMutation) SetField(name string, value ent.Value) error {
	switch name {
	case outcomemeasurement.FieldOutcomeMeasurementGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeMeasurementGroupID(v)
		return nil
	case outcomemeasurement.FieldOutcomeMeasurementValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeMeasurementValue(v)
		return nil
	case outcomemeasurement.FieldOutcomeMeasurementSpread:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeMeasurementSpread(v)
		return nil
	case outcomemeasurement.FieldOutcomeMeasurementLowerLimit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeMeasurementLowerLimit(v)
		return nil
	case outcomemeasurement.FieldOutcomeMeasurementUpperLimit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeMeasurementUpperLimit(v)
		return nil
	case outcomemeasurement.FieldOutcomeMeasurementComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeMeasurementComment(v)
		return nil
	}
	return fmt.Errorf("unknown OutcomeMeasurement field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OutcomeMeasurementMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OutcomeMeasurementMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutcomeMeasurementMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OutcomeMeasurement numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OutcomeMeasurementMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OutcomeMeasurementMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OutcomeMeasurementMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OutcomeMeasurement nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OutcomeMeasurementMutation) ResetField(name string) error {
	switch name {
	case outcomemeasurement.FieldOutcomeMeasurementGroupID:
		m.ResetOutcomeMeasurementGroupID()
		return nil
	case outcomemeasurement.FieldOutcomeMeasurementValue:
		m.ResetOutcomeMeasurementValue()
		return nil
	case outcomemeasurement.FieldOutcomeMeasurementSpread:
		m.ResetOutcomeMeasurementSpread()
		return nil
	case outcomemeasurement.FieldOutcomeMeasurementLowerLimit:
		m.ResetOutcomeMeasurementLowerLimit()
		return nil
	case outcomemeasurement.FieldOutcomeMeasurementUpperLimit:
		m.ResetOutcomeMeasurementUpperLimit()
		return nil
	case outcomemeasurement.FieldOutcomeMeasurementComment:
		m.ResetOutcomeMeasurementComment()
		return nil
	}
	return fmt.Errorf("unknown OutcomeMeasurement field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OutcomeMeasurementMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.parent != nil {
		edges = append(edges, outcomemeasurement.EdgeParent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OutcomeMeasurementMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case outcomemeasurement.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OutcomeMeasurementMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OutcomeMeasurementMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OutcomeMeasurementMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparent {
		edges = append(edges, outcomemeasurement.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OutcomeMeasurementMutation) EdgeCleared(name string) bool {
	switch name {
	case outcomemeasurement.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OutcomeMeasurementMutation) ClearEdge(name string) error {
	switch name {
	case outcomemeasurement.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown OutcomeMeasurement unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OutcomeMeasurementMutation) ResetEdge(name string) error {
	switch name {
	case outcomemeasurement.EdgeParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown OutcomeMeasurement edge %s", name)
}

// OutcomeMeasuresModuleMutation represents an operation that mutates the OutcomeMeasuresModule nodes in the graph.
type OutcomeMeasuresModuleMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	clearedFields               map[string]struct{}
	parent                      *int
	clearedparent               bool
	outcome_measure_list        map[int]struct{}
	removedoutcome_measure_list map[int]struct{}
	clearedoutcome_measure_list bool
	done                        bool
	oldValue                    func(context.Context) (*OutcomeMeasuresModule, error)
	predicates                  []predicate.OutcomeMeasuresModule
}

var _ ent.Mutation = (*OutcomeMeasuresModuleMutation)(nil)

// outcomemeasuresmoduleOption allows management of the mutation configuration using functional options.
type outcomemeasuresmoduleOption func(*OutcomeMeasuresModuleMutation)

// newOutcomeMeasuresModuleMutation creates new mutation for the OutcomeMeasuresModule entity.
func newOutcomeMeasuresModuleMutation(c config, op Op, opts ...outcomemeasuresmoduleOption) *OutcomeMeasuresModuleMutation {
	m := &OutcomeMeasuresModuleMutation{
		config:        c,
		op:            op,
		typ:           TypeOutcomeMeasuresModule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOutcomeMeasuresModuleID sets the ID field of the mutation.
func withOutcomeMeasuresModuleID(id int) outcomemeasuresmoduleOption {
	return func(m *OutcomeMeasuresModuleMutation) {
		var (
			err   error
			once  sync.Once
			value *OutcomeMeasuresModule
		)
		m.oldValue = func(ctx context.Context) (*OutcomeMeasuresModule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OutcomeMeasuresModule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOutcomeMeasuresModule sets the old OutcomeMeasuresModule of the mutation.
func withOutcomeMeasuresModule(node *OutcomeMeasuresModule) outcomemeasuresmoduleOption {
	return func(m *OutcomeMeasuresModuleMutation) {
		m.oldValue = func(context.Context) (*OutcomeMeasuresModule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OutcomeMeasuresModuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OutcomeMeasuresModuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OutcomeMeasuresModuleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OutcomeMeasuresModuleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OutcomeMeasuresModule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetParentID sets the "parent" edge to the ResultsDefinition entity by id.
func (m *OutcomeMeasuresModuleMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ResultsDefinition entity.
func (m *OutcomeMeasuresModuleMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ResultsDefinition entity was cleared.
func (m *OutcomeMeasuresModuleMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *OutcomeMeasuresModuleMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *OutcomeMeasuresModuleMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *OutcomeMeasuresModuleMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddOutcomeMeasureListIDs adds the "outcome_measure_list" edge to the OutcomeMeasure entity by ids.
func (m *OutcomeMeasuresModuleMutation) AddOutcomeMeasureListIDs(ids ...int) {
	if m.outcome_measure_list == nil {
		m.outcome_measure_list = make(map[int]struct{})
	}
	for i := range ids {
		m.outcome_measure_list[ids[i]] = struct{}{}
	}
}

// ClearOutcomeMeasureList clears the "outcome_measure_list" edge to the OutcomeMeasure entity.
func (m *OutcomeMeasuresModuleMutation) ClearOutcomeMeasureList() {
	m.clearedoutcome_measure_list = true
}

// OutcomeMeasureListCleared reports if the "outcome_measure_list" edge to the OutcomeMeasure entity was cleared.
func (m *OutcomeMeasuresModuleMutation) OutcomeMeasureListCleared() bool {
	return m.clearedoutcome_measure_list
}

// RemoveOutcomeMeasureListIDs removes the "outcome_measure_list" edge to the OutcomeMeasure entity by IDs.
func (m *OutcomeMeasuresModuleMutation) RemoveOutcomeMeasureListIDs(ids ...int) {
	if m.removedoutcome_measure_list == nil {
		m.removedoutcome_measure_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.outcome_measure_list, ids[i])
		m.removedoutcome_measure_list[ids[i]] = struct{}{}
	}
}

// RemovedOutcomeMeasureList returns the removed IDs of the "outcome_measure_list" edge to the OutcomeMeasure entity.
func (m *OutcomeMeasuresModuleMutation) RemovedOutcomeMeasureListIDs() (ids []int) {
	for id := range m.removedoutcome_measure_list {
		ids = append(ids, id)
	}
	return
}

// OutcomeMeasureListIDs returns the "outcome_measure_list" edge IDs in the mutation.
func (m *OutcomeMeasuresModuleMutation) OutcomeMeasureListIDs() (ids []int) {
	for id := range m.outcome_measure_list {
		ids = append(ids, id)
	}
	return
}

// ResetOutcomeMeasureList resets all changes to the "outcome_measure_list" edge.
func (m *OutcomeMeasuresModuleMutation) ResetOutcomeMeasureList() {
	m.outcome_measure_list = nil
	m.clearedoutcome_measure_list = false
	m.removedoutcome_measure_list = nil
}

// Where appends a list predicates to the OutcomeMeasuresModuleMutation builder.
func (m *OutcomeMeasuresModuleMutation) Where(ps ...predicate.OutcomeMeasuresModule) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OutcomeMeasuresModuleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OutcomeMeasuresModule).
func (m *OutcomeMeasuresModuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OutcomeMeasuresModuleMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OutcomeMeasuresModuleMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OutcomeMeasuresModuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown OutcomeMeasuresModule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutcomeMeasuresModuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OutcomeMeasuresModule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OutcomeMeasuresModuleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OutcomeMeasuresModuleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutcomeMeasuresModuleMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown OutcomeMeasuresModule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OutcomeMeasuresModuleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OutcomeMeasuresModuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OutcomeMeasuresModuleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OutcomeMeasuresModule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OutcomeMeasuresModuleMutation) ResetField(name string) error {
	return fmt.Errorf("unknown OutcomeMeasuresModule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OutcomeMeasuresModuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.parent != nil {
		edges = append(edges, outcomemeasuresmodule.EdgeParent)
	}
	if m.outcome_measure_list != nil {
		edges = append(edges, outcomemeasuresmodule.EdgeOutcomeMeasureList)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OutcomeMeasuresModuleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case outcomemeasuresmodule.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case outcomemeasuresmodule.EdgeOutcomeMeasureList:
		ids := make([]ent.Value, 0, len(m.outcome_measure_list))
		for id := range m.outcome_measure_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OutcomeMeasuresModuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedoutcome_measure_list != nil {
		edges = append(edges, outcomemeasuresmodule.EdgeOutcomeMeasureList)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OutcomeMeasuresModuleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case outcomemeasuresmodule.EdgeOutcomeMeasureList:
		ids := make([]ent.Value, 0, len(m.removedoutcome_measure_list))
		for id := range m.removedoutcome_measure_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OutcomeMeasuresModuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedparent {
		edges = append(edges, outcomemeasuresmodule.EdgeParent)
	}
	if m.clearedoutcome_measure_list {
		edges = append(edges, outcomemeasuresmodule.EdgeOutcomeMeasureList)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OutcomeMeasuresModuleMutation) EdgeCleared(name string) bool {
	switch name {
	case outcomemeasuresmodule.EdgeParent:
		return m.clearedparent
	case outcomemeasuresmodule.EdgeOutcomeMeasureList:
		return m.clearedoutcome_measure_list
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OutcomeMeasuresModuleMutation) ClearEdge(name string) error {
	switch name {
	case outcomemeasuresmodule.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown OutcomeMeasuresModule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OutcomeMeasuresModuleMutation) ResetEdge(name string) error {
	switch name {
	case outcomemeasuresmodule.EdgeParent:
		m.ResetParent()
		return nil
	case outcomemeasuresmodule.EdgeOutcomeMeasureList:
		m.ResetOutcomeMeasureList()
		return nil
	}
	return fmt.Errorf("unknown OutcomeMeasuresModule edge %s", name)
}

// OutcomeOverviewMutation represents an operation that mutates the OutcomeOverview nodes in the graph.
type OutcomeOverviewMutation struct {
	config
	op                                            Op
	typ                                           string
	id                                            *int
	outcome_overview_id                           *string
	outcome_overview_title                        *string
	outcome_overview_description                  *string
	outcome_overview_participants                 *string
	outcome_overview_time_frame                   *string
	outcome_overview_serotype                     *string
	outcome_overview_assay                        *string
	outcome_overview_dose_number                  *int64
	addoutcome_overview_dose_number               *int64
	outcome_overview_value                        *float64
	addoutcome_overview_value                     *float64
	outcome_overview_upper_limit                  *string
	outcome_overview_lower_limit                  *string
	outcome_overview_group_id                     *string
	outcome_overview_ratio                        *string
	outcome_overview_measure_title                *string
	outcome_overview_vaccine                      *string
	outcome_overview_immunocompromised_population *string
	outcome_overview_manufacturer                 *string
	outcome_overview_confidence_interval          *string
	outcome_overview_percent_responders           *float64
	addoutcome_overview_percent_responders        *float64
	outcome_overview_time_frame_weeks             *int64
	addoutcome_overview_time_frame_weeks          *int64
	outcome_overview_dose_description             *string
	outcome_overview_schedule                     *string
	outcome_overview_use_case_code                *string
	clearedFields                                 map[string]struct{}
	parent                                        *int
	clearedparent                                 bool
	done                                          bool
	oldValue                                      func(context.Context) (*OutcomeOverview, error)
	predicates                                    []predicate.OutcomeOverview
}

var _ ent.Mutation = (*OutcomeOverviewMutation)(nil)

// outcomeoverviewOption allows management of the mutation configuration using functional options.
type outcomeoverviewOption func(*OutcomeOverviewMutation)

// newOutcomeOverviewMutation creates new mutation for the OutcomeOverview entity.
func newOutcomeOverviewMutation(c config, op Op, opts ...outcomeoverviewOption) *OutcomeOverviewMutation {
	m := &OutcomeOverviewMutation{
		config:        c,
		op:            op,
		typ:           TypeOutcomeOverview,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOutcomeOverviewID sets the ID field of the mutation.
func withOutcomeOverviewID(id int) outcomeoverviewOption {
	return func(m *OutcomeOverviewMutation) {
		var (
			err   error
			once  sync.Once
			value *OutcomeOverview
		)
		m.oldValue = func(ctx context.Context) (*OutcomeOverview, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OutcomeOverview.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOutcomeOverview sets the old OutcomeOverview of the mutation.
func withOutcomeOverview(node *OutcomeOverview) outcomeoverviewOption {
	return func(m *OutcomeOverviewMutation) {
		m.oldValue = func(context.Context) (*OutcomeOverview, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OutcomeOverviewMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OutcomeOverviewMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OutcomeOverviewMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OutcomeOverviewMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OutcomeOverview.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOutcomeOverviewID sets the "outcome_overview_id" field.
func (m *OutcomeOverviewMutation) SetOutcomeOverviewID(s string) {
	m.outcome_overview_id = &s
}

// OutcomeOverviewID returns the value of the "outcome_overview_id" field in the mutation.
func (m *OutcomeOverviewMutation) OutcomeOverviewID() (r string, exists bool) {
	v := m.outcome_overview_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeOverviewID returns the old "outcome_overview_id" field's value of the OutcomeOverview entity.
// If the OutcomeOverview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeOverviewMutation) OldOutcomeOverviewID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeOverviewID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeOverviewID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeOverviewID: %w", err)
	}
	return oldValue.OutcomeOverviewID, nil
}

// ResetOutcomeOverviewID resets all changes to the "outcome_overview_id" field.
func (m *OutcomeOverviewMutation) ResetOutcomeOverviewID() {
	m.outcome_overview_id = nil
}

// SetOutcomeOverviewTitle sets the "outcome_overview_title" field.
func (m *OutcomeOverviewMutation) SetOutcomeOverviewTitle(s string) {
	m.outcome_overview_title = &s
}

// OutcomeOverviewTitle returns the value of the "outcome_overview_title" field in the mutation.
func (m *OutcomeOverviewMutation) OutcomeOverviewTitle() (r string, exists bool) {
	v := m.outcome_overview_title
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeOverviewTitle returns the old "outcome_overview_title" field's value of the OutcomeOverview entity.
// If the OutcomeOverview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeOverviewMutation) OldOutcomeOverviewTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeOverviewTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeOverviewTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeOverviewTitle: %w", err)
	}
	return oldValue.OutcomeOverviewTitle, nil
}

// ResetOutcomeOverviewTitle resets all changes to the "outcome_overview_title" field.
func (m *OutcomeOverviewMutation) ResetOutcomeOverviewTitle() {
	m.outcome_overview_title = nil
}

// SetOutcomeOverviewDescription sets the "outcome_overview_description" field.
func (m *OutcomeOverviewMutation) SetOutcomeOverviewDescription(s string) {
	m.outcome_overview_description = &s
}

// OutcomeOverviewDescription returns the value of the "outcome_overview_description" field in the mutation.
func (m *OutcomeOverviewMutation) OutcomeOverviewDescription() (r string, exists bool) {
	v := m.outcome_overview_description
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeOverviewDescription returns the old "outcome_overview_description" field's value of the OutcomeOverview entity.
// If the OutcomeOverview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeOverviewMutation) OldOutcomeOverviewDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeOverviewDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeOverviewDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeOverviewDescription: %w", err)
	}
	return oldValue.OutcomeOverviewDescription, nil
}

// ResetOutcomeOverviewDescription resets all changes to the "outcome_overview_description" field.
func (m *OutcomeOverviewMutation) ResetOutcomeOverviewDescription() {
	m.outcome_overview_description = nil
}

// SetOutcomeOverviewParticipants sets the "outcome_overview_participants" field.
func (m *OutcomeOverviewMutation) SetOutcomeOverviewParticipants(s string) {
	m.outcome_overview_participants = &s
}

// OutcomeOverviewParticipants returns the value of the "outcome_overview_participants" field in the mutation.
func (m *OutcomeOverviewMutation) OutcomeOverviewParticipants() (r string, exists bool) {
	v := m.outcome_overview_participants
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeOverviewParticipants returns the old "outcome_overview_participants" field's value of the OutcomeOverview entity.
// If the OutcomeOverview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeOverviewMutation) OldOutcomeOverviewParticipants(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeOverviewParticipants is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeOverviewParticipants requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeOverviewParticipants: %w", err)
	}
	return oldValue.OutcomeOverviewParticipants, nil
}

// ResetOutcomeOverviewParticipants resets all changes to the "outcome_overview_participants" field.
func (m *OutcomeOverviewMutation) ResetOutcomeOverviewParticipants() {
	m.outcome_overview_participants = nil
}

// SetOutcomeOverviewTimeFrame sets the "outcome_overview_time_frame" field.
func (m *OutcomeOverviewMutation) SetOutcomeOverviewTimeFrame(s string) {
	m.outcome_overview_time_frame = &s
}

// OutcomeOverviewTimeFrame returns the value of the "outcome_overview_time_frame" field in the mutation.
func (m *OutcomeOverviewMutation) OutcomeOverviewTimeFrame() (r string, exists bool) {
	v := m.outcome_overview_time_frame
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeOverviewTimeFrame returns the old "outcome_overview_time_frame" field's value of the OutcomeOverview entity.
// If the OutcomeOverview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeOverviewMutation) OldOutcomeOverviewTimeFrame(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeOverviewTimeFrame is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeOverviewTimeFrame requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeOverviewTimeFrame: %w", err)
	}
	return oldValue.OutcomeOverviewTimeFrame, nil
}

// ResetOutcomeOverviewTimeFrame resets all changes to the "outcome_overview_time_frame" field.
func (m *OutcomeOverviewMutation) ResetOutcomeOverviewTimeFrame() {
	m.outcome_overview_time_frame = nil
}

// SetOutcomeOverviewSerotype sets the "outcome_overview_serotype" field.
func (m *OutcomeOverviewMutation) SetOutcomeOverviewSerotype(s string) {
	m.outcome_overview_serotype = &s
}

// OutcomeOverviewSerotype returns the value of the "outcome_overview_serotype" field in the mutation.
func (m *OutcomeOverviewMutation) OutcomeOverviewSerotype() (r string, exists bool) {
	v := m.outcome_overview_serotype
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeOverviewSerotype returns the old "outcome_overview_serotype" field's value of the OutcomeOverview entity.
// If the OutcomeOverview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeOverviewMutation) OldOutcomeOverviewSerotype(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeOverviewSerotype is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeOverviewSerotype requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeOverviewSerotype: %w", err)
	}
	return oldValue.OutcomeOverviewSerotype, nil
}

// ResetOutcomeOverviewSerotype resets all changes to the "outcome_overview_serotype" field.
func (m *OutcomeOverviewMutation) ResetOutcomeOverviewSerotype() {
	m.outcome_overview_serotype = nil
}

// SetOutcomeOverviewAssay sets the "outcome_overview_assay" field.
func (m *OutcomeOverviewMutation) SetOutcomeOverviewAssay(s string) {
	m.outcome_overview_assay = &s
}

// OutcomeOverviewAssay returns the value of the "outcome_overview_assay" field in the mutation.
func (m *OutcomeOverviewMutation) OutcomeOverviewAssay() (r string, exists bool) {
	v := m.outcome_overview_assay
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeOverviewAssay returns the old "outcome_overview_assay" field's value of the OutcomeOverview entity.
// If the OutcomeOverview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeOverviewMutation) OldOutcomeOverviewAssay(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeOverviewAssay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeOverviewAssay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeOverviewAssay: %w", err)
	}
	return oldValue.OutcomeOverviewAssay, nil
}

// ResetOutcomeOverviewAssay resets all changes to the "outcome_overview_assay" field.
func (m *OutcomeOverviewMutation) ResetOutcomeOverviewAssay() {
	m.outcome_overview_assay = nil
}

// SetOutcomeOverviewDoseNumber sets the "outcome_overview_dose_number" field.
func (m *OutcomeOverviewMutation) SetOutcomeOverviewDoseNumber(i int64) {
	m.outcome_overview_dose_number = &i
	m.addoutcome_overview_dose_number = nil
}

// OutcomeOverviewDoseNumber returns the value of the "outcome_overview_dose_number" field in the mutation.
func (m *OutcomeOverviewMutation) OutcomeOverviewDoseNumber() (r int64, exists bool) {
	v := m.outcome_overview_dose_number
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeOverviewDoseNumber returns the old "outcome_overview_dose_number" field's value of the OutcomeOverview entity.
// If the OutcomeOverview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeOverviewMutation) OldOutcomeOverviewDoseNumber(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeOverviewDoseNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeOverviewDoseNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeOverviewDoseNumber: %w", err)
	}
	return oldValue.OutcomeOverviewDoseNumber, nil
}

// AddOutcomeOverviewDoseNumber adds i to the "outcome_overview_dose_number" field.
func (m *OutcomeOverviewMutation) AddOutcomeOverviewDoseNumber(i int64) {
	if m.addoutcome_overview_dose_number != nil {
		*m.addoutcome_overview_dose_number += i
	} else {
		m.addoutcome_overview_dose_number = &i
	}
}

// AddedOutcomeOverviewDoseNumber returns the value that was added to the "outcome_overview_dose_number" field in this mutation.
func (m *OutcomeOverviewMutation) AddedOutcomeOverviewDoseNumber() (r int64, exists bool) {
	v := m.addoutcome_overview_dose_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetOutcomeOverviewDoseNumber resets all changes to the "outcome_overview_dose_number" field.
func (m *OutcomeOverviewMutation) ResetOutcomeOverviewDoseNumber() {
	m.outcome_overview_dose_number = nil
	m.addoutcome_overview_dose_number = nil
}

// SetOutcomeOverviewValue sets the "outcome_overview_value" field.
func (m *OutcomeOverviewMutation) SetOutcomeOverviewValue(f float64) {
	m.outcome_overview_value = &f
	m.addoutcome_overview_value = nil
}

// OutcomeOverviewValue returns the value of the "outcome_overview_value" field in the mutation.
func (m *OutcomeOverviewMutation) OutcomeOverviewValue() (r float64, exists bool) {
	v := m.outcome_overview_value
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeOverviewValue returns the old "outcome_overview_value" field's value of the OutcomeOverview entity.
// If the OutcomeOverview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeOverviewMutation) OldOutcomeOverviewValue(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeOverviewValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeOverviewValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeOverviewValue: %w", err)
	}
	return oldValue.OutcomeOverviewValue, nil
}

// AddOutcomeOverviewValue adds f to the "outcome_overview_value" field.
func (m *OutcomeOverviewMutation) AddOutcomeOverviewValue(f float64) {
	if m.addoutcome_overview_value != nil {
		*m.addoutcome_overview_value += f
	} else {
		m.addoutcome_overview_value = &f
	}
}

// AddedOutcomeOverviewValue returns the value that was added to the "outcome_overview_value" field in this mutation.
func (m *OutcomeOverviewMutation) AddedOutcomeOverviewValue() (r float64, exists bool) {
	v := m.addoutcome_overview_value
	if v == nil {
		return
	}
	return *v, true
}

// ResetOutcomeOverviewValue resets all changes to the "outcome_overview_value" field.
func (m *OutcomeOverviewMutation) ResetOutcomeOverviewValue() {
	m.outcome_overview_value = nil
	m.addoutcome_overview_value = nil
}

// SetOutcomeOverviewUpperLimit sets the "outcome_overview_upper_limit" field.
func (m *OutcomeOverviewMutation) SetOutcomeOverviewUpperLimit(s string) {
	m.outcome_overview_upper_limit = &s
}

// OutcomeOverviewUpperLimit returns the value of the "outcome_overview_upper_limit" field in the mutation.
func (m *OutcomeOverviewMutation) OutcomeOverviewUpperLimit() (r string, exists bool) {
	v := m.outcome_overview_upper_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeOverviewUpperLimit returns the old "outcome_overview_upper_limit" field's value of the OutcomeOverview entity.
// If the OutcomeOverview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeOverviewMutation) OldOutcomeOverviewUpperLimit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeOverviewUpperLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeOverviewUpperLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeOverviewUpperLimit: %w", err)
	}
	return oldValue.OutcomeOverviewUpperLimit, nil
}

// ResetOutcomeOverviewUpperLimit resets all changes to the "outcome_overview_upper_limit" field.
func (m *OutcomeOverviewMutation) ResetOutcomeOverviewUpperLimit() {
	m.outcome_overview_upper_limit = nil
}

// SetOutcomeOverviewLowerLimit sets the "outcome_overview_lower_limit" field.
func (m *OutcomeOverviewMutation) SetOutcomeOverviewLowerLimit(s string) {
	m.outcome_overview_lower_limit = &s
}

// OutcomeOverviewLowerLimit returns the value of the "outcome_overview_lower_limit" field in the mutation.
func (m *OutcomeOverviewMutation) OutcomeOverviewLowerLimit() (r string, exists bool) {
	v := m.outcome_overview_lower_limit
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeOverviewLowerLimit returns the old "outcome_overview_lower_limit" field's value of the OutcomeOverview entity.
// If the OutcomeOverview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeOverviewMutation) OldOutcomeOverviewLowerLimit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeOverviewLowerLimit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeOverviewLowerLimit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeOverviewLowerLimit: %w", err)
	}
	return oldValue.OutcomeOverviewLowerLimit, nil
}

// ResetOutcomeOverviewLowerLimit resets all changes to the "outcome_overview_lower_limit" field.
func (m *OutcomeOverviewMutation) ResetOutcomeOverviewLowerLimit() {
	m.outcome_overview_lower_limit = nil
}

// SetOutcomeOverviewGroupID sets the "outcome_overview_group_id" field.
func (m *OutcomeOverviewMutation) SetOutcomeOverviewGroupID(s string) {
	m.outcome_overview_group_id = &s
}

// OutcomeOverviewGroupID returns the value of the "outcome_overview_group_id" field in the mutation.
func (m *OutcomeOverviewMutation) OutcomeOverviewGroupID() (r string, exists bool) {
	v := m.outcome_overview_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeOverviewGroupID returns the old "outcome_overview_group_id" field's value of the OutcomeOverview entity.
// If the OutcomeOverview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeOverviewMutation) OldOutcomeOverviewGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeOverviewGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeOverviewGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeOverviewGroupID: %w", err)
	}
	return oldValue.OutcomeOverviewGroupID, nil
}

// ResetOutcomeOverviewGroupID resets all changes to the "outcome_overview_group_id" field.
func (m *OutcomeOverviewMutation) ResetOutcomeOverviewGroupID() {
	m.outcome_overview_group_id = nil
}

// SetOutcomeOverviewRatio sets the "outcome_overview_ratio" field.
func (m *OutcomeOverviewMutation) SetOutcomeOverviewRatio(s string) {
	m.outcome_overview_ratio = &s
}

// OutcomeOverviewRatio returns the value of the "outcome_overview_ratio" field in the mutation.
func (m *OutcomeOverviewMutation) OutcomeOverviewRatio() (r string, exists bool) {
	v := m.outcome_overview_ratio
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeOverviewRatio returns the old "outcome_overview_ratio" field's value of the OutcomeOverview entity.
// If the OutcomeOverview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeOverviewMutation) OldOutcomeOverviewRatio(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeOverviewRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeOverviewRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeOverviewRatio: %w", err)
	}
	return oldValue.OutcomeOverviewRatio, nil
}

// ResetOutcomeOverviewRatio resets all changes to the "outcome_overview_ratio" field.
func (m *OutcomeOverviewMutation) ResetOutcomeOverviewRatio() {
	m.outcome_overview_ratio = nil
}

// SetOutcomeOverviewMeasureTitle sets the "outcome_overview_measure_title" field.
func (m *OutcomeOverviewMutation) SetOutcomeOverviewMeasureTitle(s string) {
	m.outcome_overview_measure_title = &s
}

// OutcomeOverviewMeasureTitle returns the value of the "outcome_overview_measure_title" field in the mutation.
func (m *OutcomeOverviewMutation) OutcomeOverviewMeasureTitle() (r string, exists bool) {
	v := m.outcome_overview_measure_title
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeOverviewMeasureTitle returns the old "outcome_overview_measure_title" field's value of the OutcomeOverview entity.
// If the OutcomeOverview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeOverviewMutation) OldOutcomeOverviewMeasureTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeOverviewMeasureTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeOverviewMeasureTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeOverviewMeasureTitle: %w", err)
	}
	return oldValue.OutcomeOverviewMeasureTitle, nil
}

// ResetOutcomeOverviewMeasureTitle resets all changes to the "outcome_overview_measure_title" field.
func (m *OutcomeOverviewMutation) ResetOutcomeOverviewMeasureTitle() {
	m.outcome_overview_measure_title = nil
}

// SetOutcomeOverviewVaccine sets the "outcome_overview_vaccine" field.
func (m *OutcomeOverviewMutation) SetOutcomeOverviewVaccine(s string) {
	m.outcome_overview_vaccine = &s
}

// OutcomeOverviewVaccine returns the value of the "outcome_overview_vaccine" field in the mutation.
func (m *OutcomeOverviewMutation) OutcomeOverviewVaccine() (r string, exists bool) {
	v := m.outcome_overview_vaccine
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeOverviewVaccine returns the old "outcome_overview_vaccine" field's value of the OutcomeOverview entity.
// If the OutcomeOverview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeOverviewMutation) OldOutcomeOverviewVaccine(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeOverviewVaccine is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeOverviewVaccine requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeOverviewVaccine: %w", err)
	}
	return oldValue.OutcomeOverviewVaccine, nil
}

// ResetOutcomeOverviewVaccine resets all changes to the "outcome_overview_vaccine" field.
func (m *OutcomeOverviewMutation) ResetOutcomeOverviewVaccine() {
	m.outcome_overview_vaccine = nil
}

// SetOutcomeOverviewImmunocompromisedPopulation sets the "outcome_overview_immunocompromised_population" field.
func (m *OutcomeOverviewMutation) SetOutcomeOverviewImmunocompromisedPopulation(s string) {
	m.outcome_overview_immunocompromised_population = &s
}

// OutcomeOverviewImmunocompromisedPopulation returns the value of the "outcome_overview_immunocompromised_population" field in the mutation.
func (m *OutcomeOverviewMutation) OutcomeOverviewImmunocompromisedPopulation() (r string, exists bool) {
	v := m.outcome_overview_immunocompromised_population
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeOverviewImmunocompromisedPopulation returns the old "outcome_overview_immunocompromised_population" field's value of the OutcomeOverview entity.
// If the OutcomeOverview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeOverviewMutation) OldOutcomeOverviewImmunocompromisedPopulation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeOverviewImmunocompromisedPopulation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeOverviewImmunocompromisedPopulation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeOverviewImmunocompromisedPopulation: %w", err)
	}
	return oldValue.OutcomeOverviewImmunocompromisedPopulation, nil
}

// ResetOutcomeOverviewImmunocompromisedPopulation resets all changes to the "outcome_overview_immunocompromised_population" field.
func (m *OutcomeOverviewMutation) ResetOutcomeOverviewImmunocompromisedPopulation() {
	m.outcome_overview_immunocompromised_population = nil
}

// SetOutcomeOverviewManufacturer sets the "outcome_overview_manufacturer" field.
func (m *OutcomeOverviewMutation) SetOutcomeOverviewManufacturer(s string) {
	m.outcome_overview_manufacturer = &s
}

// OutcomeOverviewManufacturer returns the value of the "outcome_overview_manufacturer" field in the mutation.
func (m *OutcomeOverviewMutation) OutcomeOverviewManufacturer() (r string, exists bool) {
	v := m.outcome_overview_manufacturer
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeOverviewManufacturer returns the old "outcome_overview_manufacturer" field's value of the OutcomeOverview entity.
// If the OutcomeOverview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeOverviewMutation) OldOutcomeOverviewManufacturer(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeOverviewManufacturer is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeOverviewManufacturer requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeOverviewManufacturer: %w", err)
	}
	return oldValue.OutcomeOverviewManufacturer, nil
}

// ResetOutcomeOverviewManufacturer resets all changes to the "outcome_overview_manufacturer" field.
func (m *OutcomeOverviewMutation) ResetOutcomeOverviewManufacturer() {
	m.outcome_overview_manufacturer = nil
}

// SetOutcomeOverviewConfidenceInterval sets the "outcome_overview_confidence_interval" field.
func (m *OutcomeOverviewMutation) SetOutcomeOverviewConfidenceInterval(s string) {
	m.outcome_overview_confidence_interval = &s
}

// OutcomeOverviewConfidenceInterval returns the value of the "outcome_overview_confidence_interval" field in the mutation.
func (m *OutcomeOverviewMutation) OutcomeOverviewConfidenceInterval() (r string, exists bool) {
	v := m.outcome_overview_confidence_interval
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeOverviewConfidenceInterval returns the old "outcome_overview_confidence_interval" field's value of the OutcomeOverview entity.
// If the OutcomeOverview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeOverviewMutation) OldOutcomeOverviewConfidenceInterval(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeOverviewConfidenceInterval is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeOverviewConfidenceInterval requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeOverviewConfidenceInterval: %w", err)
	}
	return oldValue.OutcomeOverviewConfidenceInterval, nil
}

// ResetOutcomeOverviewConfidenceInterval resets all changes to the "outcome_overview_confidence_interval" field.
func (m *OutcomeOverviewMutation) ResetOutcomeOverviewConfidenceInterval() {
	m.outcome_overview_confidence_interval = nil
}

// SetOutcomeOverviewPercentResponders sets the "outcome_overview_percent_responders" field.
func (m *OutcomeOverviewMutation) SetOutcomeOverviewPercentResponders(f float64) {
	m.outcome_overview_percent_responders = &f
	m.addoutcome_overview_percent_responders = nil
}

// OutcomeOverviewPercentResponders returns the value of the "outcome_overview_percent_responders" field in the mutation.
func (m *OutcomeOverviewMutation) OutcomeOverviewPercentResponders() (r float64, exists bool) {
	v := m.outcome_overview_percent_responders
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeOverviewPercentResponders returns the old "outcome_overview_percent_responders" field's value of the OutcomeOverview entity.
// If the OutcomeOverview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeOverviewMutation) OldOutcomeOverviewPercentResponders(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeOverviewPercentResponders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeOverviewPercentResponders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeOverviewPercentResponders: %w", err)
	}
	return oldValue.OutcomeOverviewPercentResponders, nil
}

// AddOutcomeOverviewPercentResponders adds f to the "outcome_overview_percent_responders" field.
func (m *OutcomeOverviewMutation) AddOutcomeOverviewPercentResponders(f float64) {
	if m.addoutcome_overview_percent_responders != nil {
		*m.addoutcome_overview_percent_responders += f
	} else {
		m.addoutcome_overview_percent_responders = &f
	}
}

// AddedOutcomeOverviewPercentResponders returns the value that was added to the "outcome_overview_percent_responders" field in this mutation.
func (m *OutcomeOverviewMutation) AddedOutcomeOverviewPercentResponders() (r float64, exists bool) {
	v := m.addoutcome_overview_percent_responders
	if v == nil {
		return
	}
	return *v, true
}

// ResetOutcomeOverviewPercentResponders resets all changes to the "outcome_overview_percent_responders" field.
func (m *OutcomeOverviewMutation) ResetOutcomeOverviewPercentResponders() {
	m.outcome_overview_percent_responders = nil
	m.addoutcome_overview_percent_responders = nil
}

// SetOutcomeOverviewTimeFrameWeeks sets the "outcome_overview_time_frame_weeks" field.
func (m *OutcomeOverviewMutation) SetOutcomeOverviewTimeFrameWeeks(i int64) {
	m.outcome_overview_time_frame_weeks = &i
	m.addoutcome_overview_time_frame_weeks = nil
}

// OutcomeOverviewTimeFrameWeeks returns the value of the "outcome_overview_time_frame_weeks" field in the mutation.
func (m *OutcomeOverviewMutation) OutcomeOverviewTimeFrameWeeks() (r int64, exists bool) {
	v := m.outcome_overview_time_frame_weeks
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeOverviewTimeFrameWeeks returns the old "outcome_overview_time_frame_weeks" field's value of the OutcomeOverview entity.
// If the OutcomeOverview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeOverviewMutation) OldOutcomeOverviewTimeFrameWeeks(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeOverviewTimeFrameWeeks is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeOverviewTimeFrameWeeks requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeOverviewTimeFrameWeeks: %w", err)
	}
	return oldValue.OutcomeOverviewTimeFrameWeeks, nil
}

// AddOutcomeOverviewTimeFrameWeeks adds i to the "outcome_overview_time_frame_weeks" field.
func (m *OutcomeOverviewMutation) AddOutcomeOverviewTimeFrameWeeks(i int64) {
	if m.addoutcome_overview_time_frame_weeks != nil {
		*m.addoutcome_overview_time_frame_weeks += i
	} else {
		m.addoutcome_overview_time_frame_weeks = &i
	}
}

// AddedOutcomeOverviewTimeFrameWeeks returns the value that was added to the "outcome_overview_time_frame_weeks" field in this mutation.
func (m *OutcomeOverviewMutation) AddedOutcomeOverviewTimeFrameWeeks() (r int64, exists bool) {
	v := m.addoutcome_overview_time_frame_weeks
	if v == nil {
		return
	}
	return *v, true
}

// ResetOutcomeOverviewTimeFrameWeeks resets all changes to the "outcome_overview_time_frame_weeks" field.
func (m *OutcomeOverviewMutation) ResetOutcomeOverviewTimeFrameWeeks() {
	m.outcome_overview_time_frame_weeks = nil
	m.addoutcome_overview_time_frame_weeks = nil
}

// SetOutcomeOverviewDoseDescription sets the "outcome_overview_dose_description" field.
func (m *OutcomeOverviewMutation) SetOutcomeOverviewDoseDescription(s string) {
	m.outcome_overview_dose_description = &s
}

// OutcomeOverviewDoseDescription returns the value of the "outcome_overview_dose_description" field in the mutation.
func (m *OutcomeOverviewMutation) OutcomeOverviewDoseDescription() (r string, exists bool) {
	v := m.outcome_overview_dose_description
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeOverviewDoseDescription returns the old "outcome_overview_dose_description" field's value of the OutcomeOverview entity.
// If the OutcomeOverview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeOverviewMutation) OldOutcomeOverviewDoseDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeOverviewDoseDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeOverviewDoseDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeOverviewDoseDescription: %w", err)
	}
	return oldValue.OutcomeOverviewDoseDescription, nil
}

// ResetOutcomeOverviewDoseDescription resets all changes to the "outcome_overview_dose_description" field.
func (m *OutcomeOverviewMutation) ResetOutcomeOverviewDoseDescription() {
	m.outcome_overview_dose_description = nil
}

// SetOutcomeOverviewSchedule sets the "outcome_overview_schedule" field.
func (m *OutcomeOverviewMutation) SetOutcomeOverviewSchedule(s string) {
	m.outcome_overview_schedule = &s
}

// OutcomeOverviewSchedule returns the value of the "outcome_overview_schedule" field in the mutation.
func (m *OutcomeOverviewMutation) OutcomeOverviewSchedule() (r string, exists bool) {
	v := m.outcome_overview_schedule
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeOverviewSchedule returns the old "outcome_overview_schedule" field's value of the OutcomeOverview entity.
// If the OutcomeOverview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeOverviewMutation) OldOutcomeOverviewSchedule(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeOverviewSchedule is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeOverviewSchedule requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeOverviewSchedule: %w", err)
	}
	return oldValue.OutcomeOverviewSchedule, nil
}

// ResetOutcomeOverviewSchedule resets all changes to the "outcome_overview_schedule" field.
func (m *OutcomeOverviewMutation) ResetOutcomeOverviewSchedule() {
	m.outcome_overview_schedule = nil
}

// SetOutcomeOverviewUseCaseCode sets the "outcome_overview_use_case_code" field.
func (m *OutcomeOverviewMutation) SetOutcomeOverviewUseCaseCode(s string) {
	m.outcome_overview_use_case_code = &s
}

// OutcomeOverviewUseCaseCode returns the value of the "outcome_overview_use_case_code" field in the mutation.
func (m *OutcomeOverviewMutation) OutcomeOverviewUseCaseCode() (r string, exists bool) {
	v := m.outcome_overview_use_case_code
	if v == nil {
		return
	}
	return *v, true
}

// OldOutcomeOverviewUseCaseCode returns the old "outcome_overview_use_case_code" field's value of the OutcomeOverview entity.
// If the OutcomeOverview object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OutcomeOverviewMutation) OldOutcomeOverviewUseCaseCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOutcomeOverviewUseCaseCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOutcomeOverviewUseCaseCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOutcomeOverviewUseCaseCode: %w", err)
	}
	return oldValue.OutcomeOverviewUseCaseCode, nil
}

// ResetOutcomeOverviewUseCaseCode resets all changes to the "outcome_overview_use_case_code" field.
func (m *OutcomeOverviewMutation) ResetOutcomeOverviewUseCaseCode() {
	m.outcome_overview_use_case_code = nil
}

// SetParentID sets the "parent" edge to the OutcomeMeasure entity by id.
func (m *OutcomeOverviewMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the OutcomeMeasure entity.
func (m *OutcomeOverviewMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the OutcomeMeasure entity was cleared.
func (m *OutcomeOverviewMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *OutcomeOverviewMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *OutcomeOverviewMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *OutcomeOverviewMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// Where appends a list predicates to the OutcomeOverviewMutation builder.
func (m *OutcomeOverviewMutation) Where(ps ...predicate.OutcomeOverview) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *OutcomeOverviewMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (OutcomeOverview).
func (m *OutcomeOverviewMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OutcomeOverviewMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.outcome_overview_id != nil {
		fields = append(fields, outcomeoverview.FieldOutcomeOverviewID)
	}
	if m.outcome_overview_title != nil {
		fields = append(fields, outcomeoverview.FieldOutcomeOverviewTitle)
	}
	if m.outcome_overview_description != nil {
		fields = append(fields, outcomeoverview.FieldOutcomeOverviewDescription)
	}
	if m.outcome_overview_participants != nil {
		fields = append(fields, outcomeoverview.FieldOutcomeOverviewParticipants)
	}
	if m.outcome_overview_time_frame != nil {
		fields = append(fields, outcomeoverview.FieldOutcomeOverviewTimeFrame)
	}
	if m.outcome_overview_serotype != nil {
		fields = append(fields, outcomeoverview.FieldOutcomeOverviewSerotype)
	}
	if m.outcome_overview_assay != nil {
		fields = append(fields, outcomeoverview.FieldOutcomeOverviewAssay)
	}
	if m.outcome_overview_dose_number != nil {
		fields = append(fields, outcomeoverview.FieldOutcomeOverviewDoseNumber)
	}
	if m.outcome_overview_value != nil {
		fields = append(fields, outcomeoverview.FieldOutcomeOverviewValue)
	}
	if m.outcome_overview_upper_limit != nil {
		fields = append(fields, outcomeoverview.FieldOutcomeOverviewUpperLimit)
	}
	if m.outcome_overview_lower_limit != nil {
		fields = append(fields, outcomeoverview.FieldOutcomeOverviewLowerLimit)
	}
	if m.outcome_overview_group_id != nil {
		fields = append(fields, outcomeoverview.FieldOutcomeOverviewGroupID)
	}
	if m.outcome_overview_ratio != nil {
		fields = append(fields, outcomeoverview.FieldOutcomeOverviewRatio)
	}
	if m.outcome_overview_measure_title != nil {
		fields = append(fields, outcomeoverview.FieldOutcomeOverviewMeasureTitle)
	}
	if m.outcome_overview_vaccine != nil {
		fields = append(fields, outcomeoverview.FieldOutcomeOverviewVaccine)
	}
	if m.outcome_overview_immunocompromised_population != nil {
		fields = append(fields, outcomeoverview.FieldOutcomeOverviewImmunocompromisedPopulation)
	}
	if m.outcome_overview_manufacturer != nil {
		fields = append(fields, outcomeoverview.FieldOutcomeOverviewManufacturer)
	}
	if m.outcome_overview_confidence_interval != nil {
		fields = append(fields, outcomeoverview.FieldOutcomeOverviewConfidenceInterval)
	}
	if m.outcome_overview_percent_responders != nil {
		fields = append(fields, outcomeoverview.FieldOutcomeOverviewPercentResponders)
	}
	if m.outcome_overview_time_frame_weeks != nil {
		fields = append(fields, outcomeoverview.FieldOutcomeOverviewTimeFrameWeeks)
	}
	if m.outcome_overview_dose_description != nil {
		fields = append(fields, outcomeoverview.FieldOutcomeOverviewDoseDescription)
	}
	if m.outcome_overview_schedule != nil {
		fields = append(fields, outcomeoverview.FieldOutcomeOverviewSchedule)
	}
	if m.outcome_overview_use_case_code != nil {
		fields = append(fields, outcomeoverview.FieldOutcomeOverviewUseCaseCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OutcomeOverviewMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case outcomeoverview.FieldOutcomeOverviewID:
		return m.OutcomeOverviewID()
	case outcomeoverview.FieldOutcomeOverviewTitle:
		return m.OutcomeOverviewTitle()
	case outcomeoverview.FieldOutcomeOverviewDescription:
		return m.OutcomeOverviewDescription()
	case outcomeoverview.FieldOutcomeOverviewParticipants:
		return m.OutcomeOverviewParticipants()
	case outcomeoverview.FieldOutcomeOverviewTimeFrame:
		return m.OutcomeOverviewTimeFrame()
	case outcomeoverview.FieldOutcomeOverviewSerotype:
		return m.OutcomeOverviewSerotype()
	case outcomeoverview.FieldOutcomeOverviewAssay:
		return m.OutcomeOverviewAssay()
	case outcomeoverview.FieldOutcomeOverviewDoseNumber:
		return m.OutcomeOverviewDoseNumber()
	case outcomeoverview.FieldOutcomeOverviewValue:
		return m.OutcomeOverviewValue()
	case outcomeoverview.FieldOutcomeOverviewUpperLimit:
		return m.OutcomeOverviewUpperLimit()
	case outcomeoverview.FieldOutcomeOverviewLowerLimit:
		return m.OutcomeOverviewLowerLimit()
	case outcomeoverview.FieldOutcomeOverviewGroupID:
		return m.OutcomeOverviewGroupID()
	case outcomeoverview.FieldOutcomeOverviewRatio:
		return m.OutcomeOverviewRatio()
	case outcomeoverview.FieldOutcomeOverviewMeasureTitle:
		return m.OutcomeOverviewMeasureTitle()
	case outcomeoverview.FieldOutcomeOverviewVaccine:
		return m.OutcomeOverviewVaccine()
	case outcomeoverview.FieldOutcomeOverviewImmunocompromisedPopulation:
		return m.OutcomeOverviewImmunocompromisedPopulation()
	case outcomeoverview.FieldOutcomeOverviewManufacturer:
		return m.OutcomeOverviewManufacturer()
	case outcomeoverview.FieldOutcomeOverviewConfidenceInterval:
		return m.OutcomeOverviewConfidenceInterval()
	case outcomeoverview.FieldOutcomeOverviewPercentResponders:
		return m.OutcomeOverviewPercentResponders()
	case outcomeoverview.FieldOutcomeOverviewTimeFrameWeeks:
		return m.OutcomeOverviewTimeFrameWeeks()
	case outcomeoverview.FieldOutcomeOverviewDoseDescription:
		return m.OutcomeOverviewDoseDescription()
	case outcomeoverview.FieldOutcomeOverviewSchedule:
		return m.OutcomeOverviewSchedule()
	case outcomeoverview.FieldOutcomeOverviewUseCaseCode:
		return m.OutcomeOverviewUseCaseCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OutcomeOverviewMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case outcomeoverview.FieldOutcomeOverviewID:
		return m.OldOutcomeOverviewID(ctx)
	case outcomeoverview.FieldOutcomeOverviewTitle:
		return m.OldOutcomeOverviewTitle(ctx)
	case outcomeoverview.FieldOutcomeOverviewDescription:
		return m.OldOutcomeOverviewDescription(ctx)
	case outcomeoverview.FieldOutcomeOverviewParticipants:
		return m.OldOutcomeOverviewParticipants(ctx)
	case outcomeoverview.FieldOutcomeOverviewTimeFrame:
		return m.OldOutcomeOverviewTimeFrame(ctx)
	case outcomeoverview.FieldOutcomeOverviewSerotype:
		return m.OldOutcomeOverviewSerotype(ctx)
	case outcomeoverview.FieldOutcomeOverviewAssay:
		return m.OldOutcomeOverviewAssay(ctx)
	case outcomeoverview.FieldOutcomeOverviewDoseNumber:
		return m.OldOutcomeOverviewDoseNumber(ctx)
	case outcomeoverview.FieldOutcomeOverviewValue:
		return m.OldOutcomeOverviewValue(ctx)
	case outcomeoverview.FieldOutcomeOverviewUpperLimit:
		return m.OldOutcomeOverviewUpperLimit(ctx)
	case outcomeoverview.FieldOutcomeOverviewLowerLimit:
		return m.OldOutcomeOverviewLowerLimit(ctx)
	case outcomeoverview.FieldOutcomeOverviewGroupID:
		return m.OldOutcomeOverviewGroupID(ctx)
	case outcomeoverview.FieldOutcomeOverviewRatio:
		return m.OldOutcomeOverviewRatio(ctx)
	case outcomeoverview.FieldOutcomeOverviewMeasureTitle:
		return m.OldOutcomeOverviewMeasureTitle(ctx)
	case outcomeoverview.FieldOutcomeOverviewVaccine:
		return m.OldOutcomeOverviewVaccine(ctx)
	case outcomeoverview.FieldOutcomeOverviewImmunocompromisedPopulation:
		return m.OldOutcomeOverviewImmunocompromisedPopulation(ctx)
	case outcomeoverview.FieldOutcomeOverviewManufacturer:
		return m.OldOutcomeOverviewManufacturer(ctx)
	case outcomeoverview.FieldOutcomeOverviewConfidenceInterval:
		return m.OldOutcomeOverviewConfidenceInterval(ctx)
	case outcomeoverview.FieldOutcomeOverviewPercentResponders:
		return m.OldOutcomeOverviewPercentResponders(ctx)
	case outcomeoverview.FieldOutcomeOverviewTimeFrameWeeks:
		return m.OldOutcomeOverviewTimeFrameWeeks(ctx)
	case outcomeoverview.FieldOutcomeOverviewDoseDescription:
		return m.OldOutcomeOverviewDoseDescription(ctx)
	case outcomeoverview.FieldOutcomeOverviewSchedule:
		return m.OldOutcomeOverviewSchedule(ctx)
	case outcomeoverview.FieldOutcomeOverviewUseCaseCode:
		return m.OldOutcomeOverviewUseCaseCode(ctx)
	}
	return nil, fmt.Errorf("unknown OutcomeOverview field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutcomeOverviewMutation) SetField(name string, value ent.Value) error {
	switch name {
	case outcomeoverview.FieldOutcomeOverviewID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeOverviewID(v)
		return nil
	case outcomeoverview.FieldOutcomeOverviewTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeOverviewTitle(v)
		return nil
	case outcomeoverview.FieldOutcomeOverviewDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeOverviewDescription(v)
		return nil
	case outcomeoverview.FieldOutcomeOverviewParticipants:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeOverviewParticipants(v)
		return nil
	case outcomeoverview.FieldOutcomeOverviewTimeFrame:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeOverviewTimeFrame(v)
		return nil
	case outcomeoverview.FieldOutcomeOverviewSerotype:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeOverviewSerotype(v)
		return nil
	case outcomeoverview.FieldOutcomeOverviewAssay:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeOverviewAssay(v)
		return nil
	case outcomeoverview.FieldOutcomeOverviewDoseNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeOverviewDoseNumber(v)
		return nil
	case outcomeoverview.FieldOutcomeOverviewValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeOverviewValue(v)
		return nil
	case outcomeoverview.FieldOutcomeOverviewUpperLimit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeOverviewUpperLimit(v)
		return nil
	case outcomeoverview.FieldOutcomeOverviewLowerLimit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeOverviewLowerLimit(v)
		return nil
	case outcomeoverview.FieldOutcomeOverviewGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeOverviewGroupID(v)
		return nil
	case outcomeoverview.FieldOutcomeOverviewRatio:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeOverviewRatio(v)
		return nil
	case outcomeoverview.FieldOutcomeOverviewMeasureTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeOverviewMeasureTitle(v)
		return nil
	case outcomeoverview.FieldOutcomeOverviewVaccine:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeOverviewVaccine(v)
		return nil
	case outcomeoverview.FieldOutcomeOverviewImmunocompromisedPopulation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeOverviewImmunocompromisedPopulation(v)
		return nil
	case outcomeoverview.FieldOutcomeOverviewManufacturer:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeOverviewManufacturer(v)
		return nil
	case outcomeoverview.FieldOutcomeOverviewConfidenceInterval:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeOverviewConfidenceInterval(v)
		return nil
	case outcomeoverview.FieldOutcomeOverviewPercentResponders:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeOverviewPercentResponders(v)
		return nil
	case outcomeoverview.FieldOutcomeOverviewTimeFrameWeeks:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeOverviewTimeFrameWeeks(v)
		return nil
	case outcomeoverview.FieldOutcomeOverviewDoseDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeOverviewDoseDescription(v)
		return nil
	case outcomeoverview.FieldOutcomeOverviewSchedule:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeOverviewSchedule(v)
		return nil
	case outcomeoverview.FieldOutcomeOverviewUseCaseCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOutcomeOverviewUseCaseCode(v)
		return nil
	}
	return fmt.Errorf("unknown OutcomeOverview field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OutcomeOverviewMutation) AddedFields() []string {
	var fields []string
	if m.addoutcome_overview_dose_number != nil {
		fields = append(fields, outcomeoverview.FieldOutcomeOverviewDoseNumber)
	}
	if m.addoutcome_overview_value != nil {
		fields = append(fields, outcomeoverview.FieldOutcomeOverviewValue)
	}
	if m.addoutcome_overview_percent_responders != nil {
		fields = append(fields, outcomeoverview.FieldOutcomeOverviewPercentResponders)
	}
	if m.addoutcome_overview_time_frame_weeks != nil {
		fields = append(fields, outcomeoverview.FieldOutcomeOverviewTimeFrameWeeks)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OutcomeOverviewMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case outcomeoverview.FieldOutcomeOverviewDoseNumber:
		return m.AddedOutcomeOverviewDoseNumber()
	case outcomeoverview.FieldOutcomeOverviewValue:
		return m.AddedOutcomeOverviewValue()
	case outcomeoverview.FieldOutcomeOverviewPercentResponders:
		return m.AddedOutcomeOverviewPercentResponders()
	case outcomeoverview.FieldOutcomeOverviewTimeFrameWeeks:
		return m.AddedOutcomeOverviewTimeFrameWeeks()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OutcomeOverviewMutation) AddField(name string, value ent.Value) error {
	switch name {
	case outcomeoverview.FieldOutcomeOverviewDoseNumber:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutcomeOverviewDoseNumber(v)
		return nil
	case outcomeoverview.FieldOutcomeOverviewValue:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutcomeOverviewValue(v)
		return nil
	case outcomeoverview.FieldOutcomeOverviewPercentResponders:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutcomeOverviewPercentResponders(v)
		return nil
	case outcomeoverview.FieldOutcomeOverviewTimeFrameWeeks:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOutcomeOverviewTimeFrameWeeks(v)
		return nil
	}
	return fmt.Errorf("unknown OutcomeOverview numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OutcomeOverviewMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OutcomeOverviewMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OutcomeOverviewMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OutcomeOverview nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OutcomeOverviewMutation) ResetField(name string) error {
	switch name {
	case outcomeoverview.FieldOutcomeOverviewID:
		m.ResetOutcomeOverviewID()
		return nil
	case outcomeoverview.FieldOutcomeOverviewTitle:
		m.ResetOutcomeOverviewTitle()
		return nil
	case outcomeoverview.FieldOutcomeOverviewDescription:
		m.ResetOutcomeOverviewDescription()
		return nil
	case outcomeoverview.FieldOutcomeOverviewParticipants:
		m.ResetOutcomeOverviewParticipants()
		return nil
	case outcomeoverview.FieldOutcomeOverviewTimeFrame:
		m.ResetOutcomeOverviewTimeFrame()
		return nil
	case outcomeoverview.FieldOutcomeOverviewSerotype:
		m.ResetOutcomeOverviewSerotype()
		return nil
	case outcomeoverview.FieldOutcomeOverviewAssay:
		m.ResetOutcomeOverviewAssay()
		return nil
	case outcomeoverview.FieldOutcomeOverviewDoseNumber:
		m.ResetOutcomeOverviewDoseNumber()
		return nil
	case outcomeoverview.FieldOutcomeOverviewValue:
		m.ResetOutcomeOverviewValue()
		return nil
	case outcomeoverview.FieldOutcomeOverviewUpperLimit:
		m.ResetOutcomeOverviewUpperLimit()
		return nil
	case outcomeoverview.FieldOutcomeOverviewLowerLimit:
		m.ResetOutcomeOverviewLowerLimit()
		return nil
	case outcomeoverview.FieldOutcomeOverviewGroupID:
		m.ResetOutcomeOverviewGroupID()
		return nil
	case outcomeoverview.FieldOutcomeOverviewRatio:
		m.ResetOutcomeOverviewRatio()
		return nil
	case outcomeoverview.FieldOutcomeOverviewMeasureTitle:
		m.ResetOutcomeOverviewMeasureTitle()
		return nil
	case outcomeoverview.FieldOutcomeOverviewVaccine:
		m.ResetOutcomeOverviewVaccine()
		return nil
	case outcomeoverview.FieldOutcomeOverviewImmunocompromisedPopulation:
		m.ResetOutcomeOverviewImmunocompromisedPopulation()
		return nil
	case outcomeoverview.FieldOutcomeOverviewManufacturer:
		m.ResetOutcomeOverviewManufacturer()
		return nil
	case outcomeoverview.FieldOutcomeOverviewConfidenceInterval:
		m.ResetOutcomeOverviewConfidenceInterval()
		return nil
	case outcomeoverview.FieldOutcomeOverviewPercentResponders:
		m.ResetOutcomeOverviewPercentResponders()
		return nil
	case outcomeoverview.FieldOutcomeOverviewTimeFrameWeeks:
		m.ResetOutcomeOverviewTimeFrameWeeks()
		return nil
	case outcomeoverview.FieldOutcomeOverviewDoseDescription:
		m.ResetOutcomeOverviewDoseDescription()
		return nil
	case outcomeoverview.FieldOutcomeOverviewSchedule:
		m.ResetOutcomeOverviewSchedule()
		return nil
	case outcomeoverview.FieldOutcomeOverviewUseCaseCode:
		m.ResetOutcomeOverviewUseCaseCode()
		return nil
	}
	return fmt.Errorf("unknown OutcomeOverview field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OutcomeOverviewMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.parent != nil {
		edges = append(edges, outcomeoverview.EdgeParent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OutcomeOverviewMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case outcomeoverview.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OutcomeOverviewMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OutcomeOverviewMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OutcomeOverviewMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparent {
		edges = append(edges, outcomeoverview.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OutcomeOverviewMutation) EdgeCleared(name string) bool {
	switch name {
	case outcomeoverview.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OutcomeOverviewMutation) ClearEdge(name string) error {
	switch name {
	case outcomeoverview.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown OutcomeOverview unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OutcomeOverviewMutation) ResetEdge(name string) error {
	switch name {
	case outcomeoverview.EdgeParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown OutcomeOverview edge %s", name)
}

// ParticipantFlowModuleMutation represents an operation that mutates the ParticipantFlowModule nodes in the graph.
type ParticipantFlowModuleMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int
	flow_pre_assignment_details *string
	flow_recruitment_details    *string
	flow_type_units_analyzed    *string
	clearedFields               map[string]struct{}
	parent                      *int
	clearedparent               bool
	flow_group_list             map[int]struct{}
	removedflow_group_list      map[int]struct{}
	clearedflow_group_list      bool
	flow_period_list            map[int]struct{}
	removedflow_period_list     map[int]struct{}
	clearedflow_period_list     bool
	done                        bool
	oldValue                    func(context.Context) (*ParticipantFlowModule, error)
	predicates                  []predicate.ParticipantFlowModule
}

var _ ent.Mutation = (*ParticipantFlowModuleMutation)(nil)

// participantflowmoduleOption allows management of the mutation configuration using functional options.
type participantflowmoduleOption func(*ParticipantFlowModuleMutation)

// newParticipantFlowModuleMutation creates new mutation for the ParticipantFlowModule entity.
func newParticipantFlowModuleMutation(c config, op Op, opts ...participantflowmoduleOption) *ParticipantFlowModuleMutation {
	m := &ParticipantFlowModuleMutation{
		config:        c,
		op:            op,
		typ:           TypeParticipantFlowModule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withParticipantFlowModuleID sets the ID field of the mutation.
func withParticipantFlowModuleID(id int) participantflowmoduleOption {
	return func(m *ParticipantFlowModuleMutation) {
		var (
			err   error
			once  sync.Once
			value *ParticipantFlowModule
		)
		m.oldValue = func(ctx context.Context) (*ParticipantFlowModule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ParticipantFlowModule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withParticipantFlowModule sets the old ParticipantFlowModule of the mutation.
func withParticipantFlowModule(node *ParticipantFlowModule) participantflowmoduleOption {
	return func(m *ParticipantFlowModuleMutation) {
		m.oldValue = func(context.Context) (*ParticipantFlowModule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ParticipantFlowModuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ParticipantFlowModuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ParticipantFlowModuleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ParticipantFlowModuleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ParticipantFlowModule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetFlowPreAssignmentDetails sets the "flow_pre_assignment_details" field.
func (m *ParticipantFlowModuleMutation) SetFlowPreAssignmentDetails(s string) {
	m.flow_pre_assignment_details = &s
}

// FlowPreAssignmentDetails returns the value of the "flow_pre_assignment_details" field in the mutation.
func (m *ParticipantFlowModuleMutation) FlowPreAssignmentDetails() (r string, exists bool) {
	v := m.flow_pre_assignment_details
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowPreAssignmentDetails returns the old "flow_pre_assignment_details" field's value of the ParticipantFlowModule entity.
// If the ParticipantFlowModule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParticipantFlowModuleMutation) OldFlowPreAssignmentDetails(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowPreAssignmentDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowPreAssignmentDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowPreAssignmentDetails: %w", err)
	}
	return oldValue.FlowPreAssignmentDetails, nil
}

// ResetFlowPreAssignmentDetails resets all changes to the "flow_pre_assignment_details" field.
func (m *ParticipantFlowModuleMutation) ResetFlowPreAssignmentDetails() {
	m.flow_pre_assignment_details = nil
}

// SetFlowRecruitmentDetails sets the "flow_recruitment_details" field.
func (m *ParticipantFlowModuleMutation) SetFlowRecruitmentDetails(s string) {
	m.flow_recruitment_details = &s
}

// FlowRecruitmentDetails returns the value of the "flow_recruitment_details" field in the mutation.
func (m *ParticipantFlowModuleMutation) FlowRecruitmentDetails() (r string, exists bool) {
	v := m.flow_recruitment_details
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowRecruitmentDetails returns the old "flow_recruitment_details" field's value of the ParticipantFlowModule entity.
// If the ParticipantFlowModule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParticipantFlowModuleMutation) OldFlowRecruitmentDetails(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowRecruitmentDetails is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowRecruitmentDetails requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowRecruitmentDetails: %w", err)
	}
	return oldValue.FlowRecruitmentDetails, nil
}

// ResetFlowRecruitmentDetails resets all changes to the "flow_recruitment_details" field.
func (m *ParticipantFlowModuleMutation) ResetFlowRecruitmentDetails() {
	m.flow_recruitment_details = nil
}

// SetFlowTypeUnitsAnalyzed sets the "flow_type_units_analyzed" field.
func (m *ParticipantFlowModuleMutation) SetFlowTypeUnitsAnalyzed(s string) {
	m.flow_type_units_analyzed = &s
}

// FlowTypeUnitsAnalyzed returns the value of the "flow_type_units_analyzed" field in the mutation.
func (m *ParticipantFlowModuleMutation) FlowTypeUnitsAnalyzed() (r string, exists bool) {
	v := m.flow_type_units_analyzed
	if v == nil {
		return
	}
	return *v, true
}

// OldFlowTypeUnitsAnalyzed returns the old "flow_type_units_analyzed" field's value of the ParticipantFlowModule entity.
// If the ParticipantFlowModule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParticipantFlowModuleMutation) OldFlowTypeUnitsAnalyzed(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFlowTypeUnitsAnalyzed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFlowTypeUnitsAnalyzed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFlowTypeUnitsAnalyzed: %w", err)
	}
	return oldValue.FlowTypeUnitsAnalyzed, nil
}

// ResetFlowTypeUnitsAnalyzed resets all changes to the "flow_type_units_analyzed" field.
func (m *ParticipantFlowModuleMutation) ResetFlowTypeUnitsAnalyzed() {
	m.flow_type_units_analyzed = nil
}

// SetParentID sets the "parent" edge to the ResultsDefinition entity by id.
func (m *ParticipantFlowModuleMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ResultsDefinition entity.
func (m *ParticipantFlowModuleMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ResultsDefinition entity was cleared.
func (m *ParticipantFlowModuleMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *ParticipantFlowModuleMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *ParticipantFlowModuleMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *ParticipantFlowModuleMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddFlowGroupListIDs adds the "flow_group_list" edge to the FlowGroup entity by ids.
func (m *ParticipantFlowModuleMutation) AddFlowGroupListIDs(ids ...int) {
	if m.flow_group_list == nil {
		m.flow_group_list = make(map[int]struct{})
	}
	for i := range ids {
		m.flow_group_list[ids[i]] = struct{}{}
	}
}

// ClearFlowGroupList clears the "flow_group_list" edge to the FlowGroup entity.
func (m *ParticipantFlowModuleMutation) ClearFlowGroupList() {
	m.clearedflow_group_list = true
}

// FlowGroupListCleared reports if the "flow_group_list" edge to the FlowGroup entity was cleared.
func (m *ParticipantFlowModuleMutation) FlowGroupListCleared() bool {
	return m.clearedflow_group_list
}

// RemoveFlowGroupListIDs removes the "flow_group_list" edge to the FlowGroup entity by IDs.
func (m *ParticipantFlowModuleMutation) RemoveFlowGroupListIDs(ids ...int) {
	if m.removedflow_group_list == nil {
		m.removedflow_group_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.flow_group_list, ids[i])
		m.removedflow_group_list[ids[i]] = struct{}{}
	}
}

// RemovedFlowGroupList returns the removed IDs of the "flow_group_list" edge to the FlowGroup entity.
func (m *ParticipantFlowModuleMutation) RemovedFlowGroupListIDs() (ids []int) {
	for id := range m.removedflow_group_list {
		ids = append(ids, id)
	}
	return
}

// FlowGroupListIDs returns the "flow_group_list" edge IDs in the mutation.
func (m *ParticipantFlowModuleMutation) FlowGroupListIDs() (ids []int) {
	for id := range m.flow_group_list {
		ids = append(ids, id)
	}
	return
}

// ResetFlowGroupList resets all changes to the "flow_group_list" edge.
func (m *ParticipantFlowModuleMutation) ResetFlowGroupList() {
	m.flow_group_list = nil
	m.clearedflow_group_list = false
	m.removedflow_group_list = nil
}

// AddFlowPeriodListIDs adds the "flow_period_list" edge to the FlowPeriod entity by ids.
func (m *ParticipantFlowModuleMutation) AddFlowPeriodListIDs(ids ...int) {
	if m.flow_period_list == nil {
		m.flow_period_list = make(map[int]struct{})
	}
	for i := range ids {
		m.flow_period_list[ids[i]] = struct{}{}
	}
}

// ClearFlowPeriodList clears the "flow_period_list" edge to the FlowPeriod entity.
func (m *ParticipantFlowModuleMutation) ClearFlowPeriodList() {
	m.clearedflow_period_list = true
}

// FlowPeriodListCleared reports if the "flow_period_list" edge to the FlowPeriod entity was cleared.
func (m *ParticipantFlowModuleMutation) FlowPeriodListCleared() bool {
	return m.clearedflow_period_list
}

// RemoveFlowPeriodListIDs removes the "flow_period_list" edge to the FlowPeriod entity by IDs.
func (m *ParticipantFlowModuleMutation) RemoveFlowPeriodListIDs(ids ...int) {
	if m.removedflow_period_list == nil {
		m.removedflow_period_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.flow_period_list, ids[i])
		m.removedflow_period_list[ids[i]] = struct{}{}
	}
}

// RemovedFlowPeriodList returns the removed IDs of the "flow_period_list" edge to the FlowPeriod entity.
func (m *ParticipantFlowModuleMutation) RemovedFlowPeriodListIDs() (ids []int) {
	for id := range m.removedflow_period_list {
		ids = append(ids, id)
	}
	return
}

// FlowPeriodListIDs returns the "flow_period_list" edge IDs in the mutation.
func (m *ParticipantFlowModuleMutation) FlowPeriodListIDs() (ids []int) {
	for id := range m.flow_period_list {
		ids = append(ids, id)
	}
	return
}

// ResetFlowPeriodList resets all changes to the "flow_period_list" edge.
func (m *ParticipantFlowModuleMutation) ResetFlowPeriodList() {
	m.flow_period_list = nil
	m.clearedflow_period_list = false
	m.removedflow_period_list = nil
}

// Where appends a list predicates to the ParticipantFlowModuleMutation builder.
func (m *ParticipantFlowModuleMutation) Where(ps ...predicate.ParticipantFlowModule) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ParticipantFlowModuleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ParticipantFlowModule).
func (m *ParticipantFlowModuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ParticipantFlowModuleMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.flow_pre_assignment_details != nil {
		fields = append(fields, participantflowmodule.FieldFlowPreAssignmentDetails)
	}
	if m.flow_recruitment_details != nil {
		fields = append(fields, participantflowmodule.FieldFlowRecruitmentDetails)
	}
	if m.flow_type_units_analyzed != nil {
		fields = append(fields, participantflowmodule.FieldFlowTypeUnitsAnalyzed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ParticipantFlowModuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case participantflowmodule.FieldFlowPreAssignmentDetails:
		return m.FlowPreAssignmentDetails()
	case participantflowmodule.FieldFlowRecruitmentDetails:
		return m.FlowRecruitmentDetails()
	case participantflowmodule.FieldFlowTypeUnitsAnalyzed:
		return m.FlowTypeUnitsAnalyzed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ParticipantFlowModuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case participantflowmodule.FieldFlowPreAssignmentDetails:
		return m.OldFlowPreAssignmentDetails(ctx)
	case participantflowmodule.FieldFlowRecruitmentDetails:
		return m.OldFlowRecruitmentDetails(ctx)
	case participantflowmodule.FieldFlowTypeUnitsAnalyzed:
		return m.OldFlowTypeUnitsAnalyzed(ctx)
	}
	return nil, fmt.Errorf("unknown ParticipantFlowModule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ParticipantFlowModuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case participantflowmodule.FieldFlowPreAssignmentDetails:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowPreAssignmentDetails(v)
		return nil
	case participantflowmodule.FieldFlowRecruitmentDetails:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowRecruitmentDetails(v)
		return nil
	case participantflowmodule.FieldFlowTypeUnitsAnalyzed:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFlowTypeUnitsAnalyzed(v)
		return nil
	}
	return fmt.Errorf("unknown ParticipantFlowModule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ParticipantFlowModuleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ParticipantFlowModuleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ParticipantFlowModuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ParticipantFlowModule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ParticipantFlowModuleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ParticipantFlowModuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ParticipantFlowModuleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ParticipantFlowModule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ParticipantFlowModuleMutation) ResetField(name string) error {
	switch name {
	case participantflowmodule.FieldFlowPreAssignmentDetails:
		m.ResetFlowPreAssignmentDetails()
		return nil
	case participantflowmodule.FieldFlowRecruitmentDetails:
		m.ResetFlowRecruitmentDetails()
		return nil
	case participantflowmodule.FieldFlowTypeUnitsAnalyzed:
		m.ResetFlowTypeUnitsAnalyzed()
		return nil
	}
	return fmt.Errorf("unknown ParticipantFlowModule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ParticipantFlowModuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.parent != nil {
		edges = append(edges, participantflowmodule.EdgeParent)
	}
	if m.flow_group_list != nil {
		edges = append(edges, participantflowmodule.EdgeFlowGroupList)
	}
	if m.flow_period_list != nil {
		edges = append(edges, participantflowmodule.EdgeFlowPeriodList)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ParticipantFlowModuleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case participantflowmodule.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case participantflowmodule.EdgeFlowGroupList:
		ids := make([]ent.Value, 0, len(m.flow_group_list))
		for id := range m.flow_group_list {
			ids = append(ids, id)
		}
		return ids
	case participantflowmodule.EdgeFlowPeriodList:
		ids := make([]ent.Value, 0, len(m.flow_period_list))
		for id := range m.flow_period_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ParticipantFlowModuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedflow_group_list != nil {
		edges = append(edges, participantflowmodule.EdgeFlowGroupList)
	}
	if m.removedflow_period_list != nil {
		edges = append(edges, participantflowmodule.EdgeFlowPeriodList)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ParticipantFlowModuleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case participantflowmodule.EdgeFlowGroupList:
		ids := make([]ent.Value, 0, len(m.removedflow_group_list))
		for id := range m.removedflow_group_list {
			ids = append(ids, id)
		}
		return ids
	case participantflowmodule.EdgeFlowPeriodList:
		ids := make([]ent.Value, 0, len(m.removedflow_period_list))
		for id := range m.removedflow_period_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ParticipantFlowModuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedparent {
		edges = append(edges, participantflowmodule.EdgeParent)
	}
	if m.clearedflow_group_list {
		edges = append(edges, participantflowmodule.EdgeFlowGroupList)
	}
	if m.clearedflow_period_list {
		edges = append(edges, participantflowmodule.EdgeFlowPeriodList)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ParticipantFlowModuleMutation) EdgeCleared(name string) bool {
	switch name {
	case participantflowmodule.EdgeParent:
		return m.clearedparent
	case participantflowmodule.EdgeFlowGroupList:
		return m.clearedflow_group_list
	case participantflowmodule.EdgeFlowPeriodList:
		return m.clearedflow_period_list
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ParticipantFlowModuleMutation) ClearEdge(name string) error {
	switch name {
	case participantflowmodule.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown ParticipantFlowModule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ParticipantFlowModuleMutation) ResetEdge(name string) error {
	switch name {
	case participantflowmodule.EdgeParent:
		m.ResetParent()
		return nil
	case participantflowmodule.EdgeFlowGroupList:
		m.ResetFlowGroupList()
		return nil
	case participantflowmodule.EdgeFlowPeriodList:
		m.ResetFlowPeriodList()
		return nil
	}
	return fmt.Errorf("unknown ParticipantFlowModule edge %s", name)
}

// PointOfContactMutation represents an operation that mutates the PointOfContact nodes in the graph.
type PointOfContactMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	point_of_contact_title        *string
	point_of_contact_organization *string
	point_of_contact_email        *string
	point_of_contact_phone        *string
	point_of_contact_phone_ext    *string
	clearedFields                 map[string]struct{}
	parent                        *int
	clearedparent                 bool
	done                          bool
	oldValue                      func(context.Context) (*PointOfContact, error)
	predicates                    []predicate.PointOfContact
}

var _ ent.Mutation = (*PointOfContactMutation)(nil)

// pointofcontactOption allows management of the mutation configuration using functional options.
type pointofcontactOption func(*PointOfContactMutation)

// newPointOfContactMutation creates new mutation for the PointOfContact entity.
func newPointOfContactMutation(c config, op Op, opts ...pointofcontactOption) *PointOfContactMutation {
	m := &PointOfContactMutation{
		config:        c,
		op:            op,
		typ:           TypePointOfContact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPointOfContactID sets the ID field of the mutation.
func withPointOfContactID(id int) pointofcontactOption {
	return func(m *PointOfContactMutation) {
		var (
			err   error
			once  sync.Once
			value *PointOfContact
		)
		m.oldValue = func(ctx context.Context) (*PointOfContact, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PointOfContact.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPointOfContact sets the old PointOfContact of the mutation.
func withPointOfContact(node *PointOfContact) pointofcontactOption {
	return func(m *PointOfContactMutation) {
		m.oldValue = func(context.Context) (*PointOfContact, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PointOfContactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PointOfContactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PointOfContactMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PointOfContactMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PointOfContact.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPointOfContactTitle sets the "point_of_contact_title" field.
func (m *PointOfContactMutation) SetPointOfContactTitle(s string) {
	m.point_of_contact_title = &s
}

// PointOfContactTitle returns the value of the "point_of_contact_title" field in the mutation.
func (m *PointOfContactMutation) PointOfContactTitle() (r string, exists bool) {
	v := m.point_of_contact_title
	if v == nil {
		return
	}
	return *v, true
}

// OldPointOfContactTitle returns the old "point_of_contact_title" field's value of the PointOfContact entity.
// If the PointOfContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointOfContactMutation) OldPointOfContactTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPointOfContactTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPointOfContactTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPointOfContactTitle: %w", err)
	}
	return oldValue.PointOfContactTitle, nil
}

// ResetPointOfContactTitle resets all changes to the "point_of_contact_title" field.
func (m *PointOfContactMutation) ResetPointOfContactTitle() {
	m.point_of_contact_title = nil
}

// SetPointOfContactOrganization sets the "point_of_contact_organization" field.
func (m *PointOfContactMutation) SetPointOfContactOrganization(s string) {
	m.point_of_contact_organization = &s
}

// PointOfContactOrganization returns the value of the "point_of_contact_organization" field in the mutation.
func (m *PointOfContactMutation) PointOfContactOrganization() (r string, exists bool) {
	v := m.point_of_contact_organization
	if v == nil {
		return
	}
	return *v, true
}

// OldPointOfContactOrganization returns the old "point_of_contact_organization" field's value of the PointOfContact entity.
// If the PointOfContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointOfContactMutation) OldPointOfContactOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPointOfContactOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPointOfContactOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPointOfContactOrganization: %w", err)
	}
	return oldValue.PointOfContactOrganization, nil
}

// ResetPointOfContactOrganization resets all changes to the "point_of_contact_organization" field.
func (m *PointOfContactMutation) ResetPointOfContactOrganization() {
	m.point_of_contact_organization = nil
}

// SetPointOfContactEmail sets the "point_of_contact_email" field.
func (m *PointOfContactMutation) SetPointOfContactEmail(s string) {
	m.point_of_contact_email = &s
}

// PointOfContactEmail returns the value of the "point_of_contact_email" field in the mutation.
func (m *PointOfContactMutation) PointOfContactEmail() (r string, exists bool) {
	v := m.point_of_contact_email
	if v == nil {
		return
	}
	return *v, true
}

// OldPointOfContactEmail returns the old "point_of_contact_email" field's value of the PointOfContact entity.
// If the PointOfContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointOfContactMutation) OldPointOfContactEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPointOfContactEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPointOfContactEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPointOfContactEmail: %w", err)
	}
	return oldValue.PointOfContactEmail, nil
}

// ResetPointOfContactEmail resets all changes to the "point_of_contact_email" field.
func (m *PointOfContactMutation) ResetPointOfContactEmail() {
	m.point_of_contact_email = nil
}

// SetPointOfContactPhone sets the "point_of_contact_phone" field.
func (m *PointOfContactMutation) SetPointOfContactPhone(s string) {
	m.point_of_contact_phone = &s
}

// PointOfContactPhone returns the value of the "point_of_contact_phone" field in the mutation.
func (m *PointOfContactMutation) PointOfContactPhone() (r string, exists bool) {
	v := m.point_of_contact_phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPointOfContactPhone returns the old "point_of_contact_phone" field's value of the PointOfContact entity.
// If the PointOfContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointOfContactMutation) OldPointOfContactPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPointOfContactPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPointOfContactPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPointOfContactPhone: %w", err)
	}
	return oldValue.PointOfContactPhone, nil
}

// ResetPointOfContactPhone resets all changes to the "point_of_contact_phone" field.
func (m *PointOfContactMutation) ResetPointOfContactPhone() {
	m.point_of_contact_phone = nil
}

// SetPointOfContactPhoneExt sets the "point_of_contact_phone_ext" field.
func (m *PointOfContactMutation) SetPointOfContactPhoneExt(s string) {
	m.point_of_contact_phone_ext = &s
}

// PointOfContactPhoneExt returns the value of the "point_of_contact_phone_ext" field in the mutation.
func (m *PointOfContactMutation) PointOfContactPhoneExt() (r string, exists bool) {
	v := m.point_of_contact_phone_ext
	if v == nil {
		return
	}
	return *v, true
}

// OldPointOfContactPhoneExt returns the old "point_of_contact_phone_ext" field's value of the PointOfContact entity.
// If the PointOfContact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PointOfContactMutation) OldPointOfContactPhoneExt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPointOfContactPhoneExt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPointOfContactPhoneExt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPointOfContactPhoneExt: %w", err)
	}
	return oldValue.PointOfContactPhoneExt, nil
}

// ResetPointOfContactPhoneExt resets all changes to the "point_of_contact_phone_ext" field.
func (m *PointOfContactMutation) ResetPointOfContactPhoneExt() {
	m.point_of_contact_phone_ext = nil
}

// SetParentID sets the "parent" edge to the MoreInfoModule entity by id.
func (m *PointOfContactMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the MoreInfoModule entity.
func (m *PointOfContactMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the MoreInfoModule entity was cleared.
func (m *PointOfContactMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *PointOfContactMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *PointOfContactMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *PointOfContactMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// Where appends a list predicates to the PointOfContactMutation builder.
func (m *PointOfContactMutation) Where(ps ...predicate.PointOfContact) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *PointOfContactMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (PointOfContact).
func (m *PointOfContactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PointOfContactMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.point_of_contact_title != nil {
		fields = append(fields, pointofcontact.FieldPointOfContactTitle)
	}
	if m.point_of_contact_organization != nil {
		fields = append(fields, pointofcontact.FieldPointOfContactOrganization)
	}
	if m.point_of_contact_email != nil {
		fields = append(fields, pointofcontact.FieldPointOfContactEmail)
	}
	if m.point_of_contact_phone != nil {
		fields = append(fields, pointofcontact.FieldPointOfContactPhone)
	}
	if m.point_of_contact_phone_ext != nil {
		fields = append(fields, pointofcontact.FieldPointOfContactPhoneExt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PointOfContactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pointofcontact.FieldPointOfContactTitle:
		return m.PointOfContactTitle()
	case pointofcontact.FieldPointOfContactOrganization:
		return m.PointOfContactOrganization()
	case pointofcontact.FieldPointOfContactEmail:
		return m.PointOfContactEmail()
	case pointofcontact.FieldPointOfContactPhone:
		return m.PointOfContactPhone()
	case pointofcontact.FieldPointOfContactPhoneExt:
		return m.PointOfContactPhoneExt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PointOfContactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pointofcontact.FieldPointOfContactTitle:
		return m.OldPointOfContactTitle(ctx)
	case pointofcontact.FieldPointOfContactOrganization:
		return m.OldPointOfContactOrganization(ctx)
	case pointofcontact.FieldPointOfContactEmail:
		return m.OldPointOfContactEmail(ctx)
	case pointofcontact.FieldPointOfContactPhone:
		return m.OldPointOfContactPhone(ctx)
	case pointofcontact.FieldPointOfContactPhoneExt:
		return m.OldPointOfContactPhoneExt(ctx)
	}
	return nil, fmt.Errorf("unknown PointOfContact field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PointOfContactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pointofcontact.FieldPointOfContactTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPointOfContactTitle(v)
		return nil
	case pointofcontact.FieldPointOfContactOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPointOfContactOrganization(v)
		return nil
	case pointofcontact.FieldPointOfContactEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPointOfContactEmail(v)
		return nil
	case pointofcontact.FieldPointOfContactPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPointOfContactPhone(v)
		return nil
	case pointofcontact.FieldPointOfContactPhoneExt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPointOfContactPhoneExt(v)
		return nil
	}
	return fmt.Errorf("unknown PointOfContact field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PointOfContactMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PointOfContactMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PointOfContactMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PointOfContact numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PointOfContactMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PointOfContactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PointOfContactMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PointOfContact nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PointOfContactMutation) ResetField(name string) error {
	switch name {
	case pointofcontact.FieldPointOfContactTitle:
		m.ResetPointOfContactTitle()
		return nil
	case pointofcontact.FieldPointOfContactOrganization:
		m.ResetPointOfContactOrganization()
		return nil
	case pointofcontact.FieldPointOfContactEmail:
		m.ResetPointOfContactEmail()
		return nil
	case pointofcontact.FieldPointOfContactPhone:
		m.ResetPointOfContactPhone()
		return nil
	case pointofcontact.FieldPointOfContactPhoneExt:
		m.ResetPointOfContactPhoneExt()
		return nil
	}
	return fmt.Errorf("unknown PointOfContact field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PointOfContactMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.parent != nil {
		edges = append(edges, pointofcontact.EdgeParent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PointOfContactMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pointofcontact.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PointOfContactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PointOfContactMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PointOfContactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparent {
		edges = append(edges, pointofcontact.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PointOfContactMutation) EdgeCleared(name string) bool {
	switch name {
	case pointofcontact.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PointOfContactMutation) ClearEdge(name string) error {
	switch name {
	case pointofcontact.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown PointOfContact unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PointOfContactMutation) ResetEdge(name string) error {
	switch name {
	case pointofcontact.EdgeParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown PointOfContact edge %s", name)
}

// ResultsDefinitionMutation represents an operation that mutates the ResultsDefinition nodes in the graph.
type ResultsDefinitionMutation struct {
	config
	op                                     Op
	typ                                    string
	id                                     *int
	clearedFields                          map[string]struct{}
	parent                                 *int
	clearedparent                          bool
	participant_flow_module                *int
	clearedparticipant_flow_module         bool
	baseline_characteristics_module        *int
	clearedbaseline_characteristics_module bool
	outcome_measures_module                *int
	clearedoutcome_measures_module         bool
	adverse_events_module                  *int
	clearedadverse_events_module           bool
	more_info_module                       *int
	clearedmore_info_module                bool
	done                                   bool
	oldValue                               func(context.Context) (*ResultsDefinition, error)
	predicates                             []predicate.ResultsDefinition
}

var _ ent.Mutation = (*ResultsDefinitionMutation)(nil)

// resultsdefinitionOption allows management of the mutation configuration using functional options.
type resultsdefinitionOption func(*ResultsDefinitionMutation)

// newResultsDefinitionMutation creates new mutation for the ResultsDefinition entity.
func newResultsDefinitionMutation(c config, op Op, opts ...resultsdefinitionOption) *ResultsDefinitionMutation {
	m := &ResultsDefinitionMutation{
		config:        c,
		op:            op,
		typ:           TypeResultsDefinition,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withResultsDefinitionID sets the ID field of the mutation.
func withResultsDefinitionID(id int) resultsdefinitionOption {
	return func(m *ResultsDefinitionMutation) {
		var (
			err   error
			once  sync.Once
			value *ResultsDefinition
		)
		m.oldValue = func(ctx context.Context) (*ResultsDefinition, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ResultsDefinition.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withResultsDefinition sets the old ResultsDefinition of the mutation.
func withResultsDefinition(node *ResultsDefinition) resultsdefinitionOption {
	return func(m *ResultsDefinitionMutation) {
		m.oldValue = func(context.Context) (*ResultsDefinition, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ResultsDefinitionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ResultsDefinitionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ResultsDefinitionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ResultsDefinitionMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ResultsDefinition.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetParentID sets the "parent" edge to the ClinicalTrial entity by id.
func (m *ResultsDefinitionMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ClinicalTrial entity.
func (m *ResultsDefinitionMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ClinicalTrial entity was cleared.
func (m *ResultsDefinitionMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *ResultsDefinitionMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *ResultsDefinitionMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *ResultsDefinitionMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// SetParticipantFlowModuleID sets the "participant_flow_module" edge to the ParticipantFlowModule entity by id.
func (m *ResultsDefinitionMutation) SetParticipantFlowModuleID(id int) {
	m.participant_flow_module = &id
}

// ClearParticipantFlowModule clears the "participant_flow_module" edge to the ParticipantFlowModule entity.
func (m *ResultsDefinitionMutation) ClearParticipantFlowModule() {
	m.clearedparticipant_flow_module = true
}

// ParticipantFlowModuleCleared reports if the "participant_flow_module" edge to the ParticipantFlowModule entity was cleared.
func (m *ResultsDefinitionMutation) ParticipantFlowModuleCleared() bool {
	return m.clearedparticipant_flow_module
}

// ParticipantFlowModuleID returns the "participant_flow_module" edge ID in the mutation.
func (m *ResultsDefinitionMutation) ParticipantFlowModuleID() (id int, exists bool) {
	if m.participant_flow_module != nil {
		return *m.participant_flow_module, true
	}
	return
}

// ParticipantFlowModuleIDs returns the "participant_flow_module" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParticipantFlowModuleID instead. It exists only for internal usage by the builders.
func (m *ResultsDefinitionMutation) ParticipantFlowModuleIDs() (ids []int) {
	if id := m.participant_flow_module; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParticipantFlowModule resets all changes to the "participant_flow_module" edge.
func (m *ResultsDefinitionMutation) ResetParticipantFlowModule() {
	m.participant_flow_module = nil
	m.clearedparticipant_flow_module = false
}

// SetBaselineCharacteristicsModuleID sets the "baseline_characteristics_module" edge to the BaselineCharacteristicsModule entity by id.
func (m *ResultsDefinitionMutation) SetBaselineCharacteristicsModuleID(id int) {
	m.baseline_characteristics_module = &id
}

// ClearBaselineCharacteristicsModule clears the "baseline_characteristics_module" edge to the BaselineCharacteristicsModule entity.
func (m *ResultsDefinitionMutation) ClearBaselineCharacteristicsModule() {
	m.clearedbaseline_characteristics_module = true
}

// BaselineCharacteristicsModuleCleared reports if the "baseline_characteristics_module" edge to the BaselineCharacteristicsModule entity was cleared.
func (m *ResultsDefinitionMutation) BaselineCharacteristicsModuleCleared() bool {
	return m.clearedbaseline_characteristics_module
}

// BaselineCharacteristicsModuleID returns the "baseline_characteristics_module" edge ID in the mutation.
func (m *ResultsDefinitionMutation) BaselineCharacteristicsModuleID() (id int, exists bool) {
	if m.baseline_characteristics_module != nil {
		return *m.baseline_characteristics_module, true
	}
	return
}

// BaselineCharacteristicsModuleIDs returns the "baseline_characteristics_module" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BaselineCharacteristicsModuleID instead. It exists only for internal usage by the builders.
func (m *ResultsDefinitionMutation) BaselineCharacteristicsModuleIDs() (ids []int) {
	if id := m.baseline_characteristics_module; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBaselineCharacteristicsModule resets all changes to the "baseline_characteristics_module" edge.
func (m *ResultsDefinitionMutation) ResetBaselineCharacteristicsModule() {
	m.baseline_characteristics_module = nil
	m.clearedbaseline_characteristics_module = false
}

// SetOutcomeMeasuresModuleID sets the "outcome_measures_module" edge to the OutcomeMeasuresModule entity by id.
func (m *ResultsDefinitionMutation) SetOutcomeMeasuresModuleID(id int) {
	m.outcome_measures_module = &id
}

// ClearOutcomeMeasuresModule clears the "outcome_measures_module" edge to the OutcomeMeasuresModule entity.
func (m *ResultsDefinitionMutation) ClearOutcomeMeasuresModule() {
	m.clearedoutcome_measures_module = true
}

// OutcomeMeasuresModuleCleared reports if the "outcome_measures_module" edge to the OutcomeMeasuresModule entity was cleared.
func (m *ResultsDefinitionMutation) OutcomeMeasuresModuleCleared() bool {
	return m.clearedoutcome_measures_module
}

// OutcomeMeasuresModuleID returns the "outcome_measures_module" edge ID in the mutation.
func (m *ResultsDefinitionMutation) OutcomeMeasuresModuleID() (id int, exists bool) {
	if m.outcome_measures_module != nil {
		return *m.outcome_measures_module, true
	}
	return
}

// OutcomeMeasuresModuleIDs returns the "outcome_measures_module" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OutcomeMeasuresModuleID instead. It exists only for internal usage by the builders.
func (m *ResultsDefinitionMutation) OutcomeMeasuresModuleIDs() (ids []int) {
	if id := m.outcome_measures_module; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOutcomeMeasuresModule resets all changes to the "outcome_measures_module" edge.
func (m *ResultsDefinitionMutation) ResetOutcomeMeasuresModule() {
	m.outcome_measures_module = nil
	m.clearedoutcome_measures_module = false
}

// SetAdverseEventsModuleID sets the "adverse_events_module" edge to the AdverseEventsModule entity by id.
func (m *ResultsDefinitionMutation) SetAdverseEventsModuleID(id int) {
	m.adverse_events_module = &id
}

// ClearAdverseEventsModule clears the "adverse_events_module" edge to the AdverseEventsModule entity.
func (m *ResultsDefinitionMutation) ClearAdverseEventsModule() {
	m.clearedadverse_events_module = true
}

// AdverseEventsModuleCleared reports if the "adverse_events_module" edge to the AdverseEventsModule entity was cleared.
func (m *ResultsDefinitionMutation) AdverseEventsModuleCleared() bool {
	return m.clearedadverse_events_module
}

// AdverseEventsModuleID returns the "adverse_events_module" edge ID in the mutation.
func (m *ResultsDefinitionMutation) AdverseEventsModuleID() (id int, exists bool) {
	if m.adverse_events_module != nil {
		return *m.adverse_events_module, true
	}
	return
}

// AdverseEventsModuleIDs returns the "adverse_events_module" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdverseEventsModuleID instead. It exists only for internal usage by the builders.
func (m *ResultsDefinitionMutation) AdverseEventsModuleIDs() (ids []int) {
	if id := m.adverse_events_module; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdverseEventsModule resets all changes to the "adverse_events_module" edge.
func (m *ResultsDefinitionMutation) ResetAdverseEventsModule() {
	m.adverse_events_module = nil
	m.clearedadverse_events_module = false
}

// SetMoreInfoModuleID sets the "more_info_module" edge to the MoreInfoModule entity by id.
func (m *ResultsDefinitionMutation) SetMoreInfoModuleID(id int) {
	m.more_info_module = &id
}

// ClearMoreInfoModule clears the "more_info_module" edge to the MoreInfoModule entity.
func (m *ResultsDefinitionMutation) ClearMoreInfoModule() {
	m.clearedmore_info_module = true
}

// MoreInfoModuleCleared reports if the "more_info_module" edge to the MoreInfoModule entity was cleared.
func (m *ResultsDefinitionMutation) MoreInfoModuleCleared() bool {
	return m.clearedmore_info_module
}

// MoreInfoModuleID returns the "more_info_module" edge ID in the mutation.
func (m *ResultsDefinitionMutation) MoreInfoModuleID() (id int, exists bool) {
	if m.more_info_module != nil {
		return *m.more_info_module, true
	}
	return
}

// MoreInfoModuleIDs returns the "more_info_module" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MoreInfoModuleID instead. It exists only for internal usage by the builders.
func (m *ResultsDefinitionMutation) MoreInfoModuleIDs() (ids []int) {
	if id := m.more_info_module; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMoreInfoModule resets all changes to the "more_info_module" edge.
func (m *ResultsDefinitionMutation) ResetMoreInfoModule() {
	m.more_info_module = nil
	m.clearedmore_info_module = false
}

// Where appends a list predicates to the ResultsDefinitionMutation builder.
func (m *ResultsDefinitionMutation) Where(ps ...predicate.ResultsDefinition) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ResultsDefinitionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ResultsDefinition).
func (m *ResultsDefinitionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ResultsDefinitionMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ResultsDefinitionMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ResultsDefinitionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown ResultsDefinition field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResultsDefinitionMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ResultsDefinition field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ResultsDefinitionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ResultsDefinitionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ResultsDefinitionMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown ResultsDefinition numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ResultsDefinitionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ResultsDefinitionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ResultsDefinitionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ResultsDefinition nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ResultsDefinitionMutation) ResetField(name string) error {
	return fmt.Errorf("unknown ResultsDefinition field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ResultsDefinitionMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.parent != nil {
		edges = append(edges, resultsdefinition.EdgeParent)
	}
	if m.participant_flow_module != nil {
		edges = append(edges, resultsdefinition.EdgeParticipantFlowModule)
	}
	if m.baseline_characteristics_module != nil {
		edges = append(edges, resultsdefinition.EdgeBaselineCharacteristicsModule)
	}
	if m.outcome_measures_module != nil {
		edges = append(edges, resultsdefinition.EdgeOutcomeMeasuresModule)
	}
	if m.adverse_events_module != nil {
		edges = append(edges, resultsdefinition.EdgeAdverseEventsModule)
	}
	if m.more_info_module != nil {
		edges = append(edges, resultsdefinition.EdgeMoreInfoModule)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ResultsDefinitionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case resultsdefinition.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case resultsdefinition.EdgeParticipantFlowModule:
		if id := m.participant_flow_module; id != nil {
			return []ent.Value{*id}
		}
	case resultsdefinition.EdgeBaselineCharacteristicsModule:
		if id := m.baseline_characteristics_module; id != nil {
			return []ent.Value{*id}
		}
	case resultsdefinition.EdgeOutcomeMeasuresModule:
		if id := m.outcome_measures_module; id != nil {
			return []ent.Value{*id}
		}
	case resultsdefinition.EdgeAdverseEventsModule:
		if id := m.adverse_events_module; id != nil {
			return []ent.Value{*id}
		}
	case resultsdefinition.EdgeMoreInfoModule:
		if id := m.more_info_module; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ResultsDefinitionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ResultsDefinitionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ResultsDefinitionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedparent {
		edges = append(edges, resultsdefinition.EdgeParent)
	}
	if m.clearedparticipant_flow_module {
		edges = append(edges, resultsdefinition.EdgeParticipantFlowModule)
	}
	if m.clearedbaseline_characteristics_module {
		edges = append(edges, resultsdefinition.EdgeBaselineCharacteristicsModule)
	}
	if m.clearedoutcome_measures_module {
		edges = append(edges, resultsdefinition.EdgeOutcomeMeasuresModule)
	}
	if m.clearedadverse_events_module {
		edges = append(edges, resultsdefinition.EdgeAdverseEventsModule)
	}
	if m.clearedmore_info_module {
		edges = append(edges, resultsdefinition.EdgeMoreInfoModule)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ResultsDefinitionMutation) EdgeCleared(name string) bool {
	switch name {
	case resultsdefinition.EdgeParent:
		return m.clearedparent
	case resultsdefinition.EdgeParticipantFlowModule:
		return m.clearedparticipant_flow_module
	case resultsdefinition.EdgeBaselineCharacteristicsModule:
		return m.clearedbaseline_characteristics_module
	case resultsdefinition.EdgeOutcomeMeasuresModule:
		return m.clearedoutcome_measures_module
	case resultsdefinition.EdgeAdverseEventsModule:
		return m.clearedadverse_events_module
	case resultsdefinition.EdgeMoreInfoModule:
		return m.clearedmore_info_module
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ResultsDefinitionMutation) ClearEdge(name string) error {
	switch name {
	case resultsdefinition.EdgeParent:
		m.ClearParent()
		return nil
	case resultsdefinition.EdgeParticipantFlowModule:
		m.ClearParticipantFlowModule()
		return nil
	case resultsdefinition.EdgeBaselineCharacteristicsModule:
		m.ClearBaselineCharacteristicsModule()
		return nil
	case resultsdefinition.EdgeOutcomeMeasuresModule:
		m.ClearOutcomeMeasuresModule()
		return nil
	case resultsdefinition.EdgeAdverseEventsModule:
		m.ClearAdverseEventsModule()
		return nil
	case resultsdefinition.EdgeMoreInfoModule:
		m.ClearMoreInfoModule()
		return nil
	}
	return fmt.Errorf("unknown ResultsDefinition unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ResultsDefinitionMutation) ResetEdge(name string) error {
	switch name {
	case resultsdefinition.EdgeParent:
		m.ResetParent()
		return nil
	case resultsdefinition.EdgeParticipantFlowModule:
		m.ResetParticipantFlowModule()
		return nil
	case resultsdefinition.EdgeBaselineCharacteristicsModule:
		m.ResetBaselineCharacteristicsModule()
		return nil
	case resultsdefinition.EdgeOutcomeMeasuresModule:
		m.ResetOutcomeMeasuresModule()
		return nil
	case resultsdefinition.EdgeAdverseEventsModule:
		m.ResetAdverseEventsModule()
		return nil
	case resultsdefinition.EdgeMoreInfoModule:
		m.ResetMoreInfoModule()
		return nil
	}
	return fmt.Errorf("unknown ResultsDefinition edge %s", name)
}

// ScheduleMutation represents an operation that mutates the Schedule nodes in the graph.
type ScheduleMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Schedule, error)
	predicates    []predicate.Schedule
}

var _ ent.Mutation = (*ScheduleMutation)(nil)

// scheduleOption allows management of the mutation configuration using functional options.
type scheduleOption func(*ScheduleMutation)

// newScheduleMutation creates new mutation for the Schedule entity.
func newScheduleMutation(c config, op Op, opts ...scheduleOption) *ScheduleMutation {
	m := &ScheduleMutation{
		config:        c,
		op:            op,
		typ:           TypeSchedule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withScheduleID sets the ID field of the mutation.
func withScheduleID(id int) scheduleOption {
	return func(m *ScheduleMutation) {
		var (
			err   error
			once  sync.Once
			value *Schedule
		)
		m.oldValue = func(ctx context.Context) (*Schedule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Schedule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSchedule sets the old Schedule of the mutation.
func withSchedule(node *Schedule) scheduleOption {
	return func(m *ScheduleMutation) {
		m.oldValue = func(context.Context) (*Schedule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ScheduleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ScheduleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ScheduleMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ScheduleMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Schedule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ScheduleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ScheduleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Schedule entity.
// If the Schedule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ScheduleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ScheduleMutation) ResetName() {
	m.name = nil
}

// Where appends a list predicates to the ScheduleMutation builder.
func (m *ScheduleMutation) Where(ps ...predicate.Schedule) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ScheduleMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Schedule).
func (m *ScheduleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ScheduleMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, schedule.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ScheduleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case schedule.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ScheduleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case schedule.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Schedule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case schedule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Schedule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ScheduleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ScheduleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ScheduleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Schedule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ScheduleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ScheduleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ScheduleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Schedule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ScheduleMutation) ResetField(name string) error {
	switch name {
	case schedule.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Schedule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ScheduleMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ScheduleMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ScheduleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ScheduleMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ScheduleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ScheduleMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ScheduleMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Schedule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ScheduleMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Schedule edge %s", name)
}

// SeriousEventMutation represents an operation that mutates the SeriousEvent nodes in the graph.
type SeriousEventMutation struct {
	config
	op                              Op
	typ                             string
	id                              *int
	serious_event_term              *string
	serious_event_organ_system      *string
	serious_event_source_vocabulary *string
	serious_event_assessment_type   *string
	serious_event_notes             *string
	clearedFields                   map[string]struct{}
	parent                          *int
	clearedparent                   bool
	serious_event_stats_list        map[int]struct{}
	removedserious_event_stats_list map[int]struct{}
	clearedserious_event_stats_list bool
	done                            bool
	oldValue                        func(context.Context) (*SeriousEvent, error)
	predicates                      []predicate.SeriousEvent
}

var _ ent.Mutation = (*SeriousEventMutation)(nil)

// seriouseventOption allows management of the mutation configuration using functional options.
type seriouseventOption func(*SeriousEventMutation)

// newSeriousEventMutation creates new mutation for the SeriousEvent entity.
func newSeriousEventMutation(c config, op Op, opts ...seriouseventOption) *SeriousEventMutation {
	m := &SeriousEventMutation{
		config:        c,
		op:            op,
		typ:           TypeSeriousEvent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSeriousEventID sets the ID field of the mutation.
func withSeriousEventID(id int) seriouseventOption {
	return func(m *SeriousEventMutation) {
		var (
			err   error
			once  sync.Once
			value *SeriousEvent
		)
		m.oldValue = func(ctx context.Context) (*SeriousEvent, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SeriousEvent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSeriousEvent sets the old SeriousEvent of the mutation.
func withSeriousEvent(node *SeriousEvent) seriouseventOption {
	return func(m *SeriousEventMutation) {
		m.oldValue = func(context.Context) (*SeriousEvent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SeriousEventMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SeriousEventMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SeriousEventMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SeriousEventMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SeriousEvent.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSeriousEventTerm sets the "serious_event_term" field.
func (m *SeriousEventMutation) SetSeriousEventTerm(s string) {
	m.serious_event_term = &s
}

// SeriousEventTerm returns the value of the "serious_event_term" field in the mutation.
func (m *SeriousEventMutation) SeriousEventTerm() (r string, exists bool) {
	v := m.serious_event_term
	if v == nil {
		return
	}
	return *v, true
}

// OldSeriousEventTerm returns the old "serious_event_term" field's value of the SeriousEvent entity.
// If the SeriousEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriousEventMutation) OldSeriousEventTerm(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeriousEventTerm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeriousEventTerm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeriousEventTerm: %w", err)
	}
	return oldValue.SeriousEventTerm, nil
}

// ResetSeriousEventTerm resets all changes to the "serious_event_term" field.
func (m *SeriousEventMutation) ResetSeriousEventTerm() {
	m.serious_event_term = nil
}

// SetSeriousEventOrganSystem sets the "serious_event_organ_system" field.
func (m *SeriousEventMutation) SetSeriousEventOrganSystem(s string) {
	m.serious_event_organ_system = &s
}

// SeriousEventOrganSystem returns the value of the "serious_event_organ_system" field in the mutation.
func (m *SeriousEventMutation) SeriousEventOrganSystem() (r string, exists bool) {
	v := m.serious_event_organ_system
	if v == nil {
		return
	}
	return *v, true
}

// OldSeriousEventOrganSystem returns the old "serious_event_organ_system" field's value of the SeriousEvent entity.
// If the SeriousEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriousEventMutation) OldSeriousEventOrganSystem(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeriousEventOrganSystem is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeriousEventOrganSystem requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeriousEventOrganSystem: %w", err)
	}
	return oldValue.SeriousEventOrganSystem, nil
}

// ResetSeriousEventOrganSystem resets all changes to the "serious_event_organ_system" field.
func (m *SeriousEventMutation) ResetSeriousEventOrganSystem() {
	m.serious_event_organ_system = nil
}

// SetSeriousEventSourceVocabulary sets the "serious_event_source_vocabulary" field.
func (m *SeriousEventMutation) SetSeriousEventSourceVocabulary(s string) {
	m.serious_event_source_vocabulary = &s
}

// SeriousEventSourceVocabulary returns the value of the "serious_event_source_vocabulary" field in the mutation.
func (m *SeriousEventMutation) SeriousEventSourceVocabulary() (r string, exists bool) {
	v := m.serious_event_source_vocabulary
	if v == nil {
		return
	}
	return *v, true
}

// OldSeriousEventSourceVocabulary returns the old "serious_event_source_vocabulary" field's value of the SeriousEvent entity.
// If the SeriousEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriousEventMutation) OldSeriousEventSourceVocabulary(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeriousEventSourceVocabulary is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeriousEventSourceVocabulary requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeriousEventSourceVocabulary: %w", err)
	}
	return oldValue.SeriousEventSourceVocabulary, nil
}

// ResetSeriousEventSourceVocabulary resets all changes to the "serious_event_source_vocabulary" field.
func (m *SeriousEventMutation) ResetSeriousEventSourceVocabulary() {
	m.serious_event_source_vocabulary = nil
}

// SetSeriousEventAssessmentType sets the "serious_event_assessment_type" field.
func (m *SeriousEventMutation) SetSeriousEventAssessmentType(s string) {
	m.serious_event_assessment_type = &s
}

// SeriousEventAssessmentType returns the value of the "serious_event_assessment_type" field in the mutation.
func (m *SeriousEventMutation) SeriousEventAssessmentType() (r string, exists bool) {
	v := m.serious_event_assessment_type
	if v == nil {
		return
	}
	return *v, true
}

// OldSeriousEventAssessmentType returns the old "serious_event_assessment_type" field's value of the SeriousEvent entity.
// If the SeriousEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriousEventMutation) OldSeriousEventAssessmentType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeriousEventAssessmentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeriousEventAssessmentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeriousEventAssessmentType: %w", err)
	}
	return oldValue.SeriousEventAssessmentType, nil
}

// ResetSeriousEventAssessmentType resets all changes to the "serious_event_assessment_type" field.
func (m *SeriousEventMutation) ResetSeriousEventAssessmentType() {
	m.serious_event_assessment_type = nil
}

// SetSeriousEventNotes sets the "serious_event_notes" field.
func (m *SeriousEventMutation) SetSeriousEventNotes(s string) {
	m.serious_event_notes = &s
}

// SeriousEventNotes returns the value of the "serious_event_notes" field in the mutation.
func (m *SeriousEventMutation) SeriousEventNotes() (r string, exists bool) {
	v := m.serious_event_notes
	if v == nil {
		return
	}
	return *v, true
}

// OldSeriousEventNotes returns the old "serious_event_notes" field's value of the SeriousEvent entity.
// If the SeriousEvent object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriousEventMutation) OldSeriousEventNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeriousEventNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeriousEventNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeriousEventNotes: %w", err)
	}
	return oldValue.SeriousEventNotes, nil
}

// ResetSeriousEventNotes resets all changes to the "serious_event_notes" field.
func (m *SeriousEventMutation) ResetSeriousEventNotes() {
	m.serious_event_notes = nil
}

// SetParentID sets the "parent" edge to the AdverseEventsModule entity by id.
func (m *SeriousEventMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the AdverseEventsModule entity.
func (m *SeriousEventMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the AdverseEventsModule entity was cleared.
func (m *SeriousEventMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *SeriousEventMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *SeriousEventMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *SeriousEventMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddSeriousEventStatsListIDs adds the "serious_event_stats_list" edge to the SeriousEventStats entity by ids.
func (m *SeriousEventMutation) AddSeriousEventStatsListIDs(ids ...int) {
	if m.serious_event_stats_list == nil {
		m.serious_event_stats_list = make(map[int]struct{})
	}
	for i := range ids {
		m.serious_event_stats_list[ids[i]] = struct{}{}
	}
}

// ClearSeriousEventStatsList clears the "serious_event_stats_list" edge to the SeriousEventStats entity.
func (m *SeriousEventMutation) ClearSeriousEventStatsList() {
	m.clearedserious_event_stats_list = true
}

// SeriousEventStatsListCleared reports if the "serious_event_stats_list" edge to the SeriousEventStats entity was cleared.
func (m *SeriousEventMutation) SeriousEventStatsListCleared() bool {
	return m.clearedserious_event_stats_list
}

// RemoveSeriousEventStatsListIDs removes the "serious_event_stats_list" edge to the SeriousEventStats entity by IDs.
func (m *SeriousEventMutation) RemoveSeriousEventStatsListIDs(ids ...int) {
	if m.removedserious_event_stats_list == nil {
		m.removedserious_event_stats_list = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.serious_event_stats_list, ids[i])
		m.removedserious_event_stats_list[ids[i]] = struct{}{}
	}
}

// RemovedSeriousEventStatsList returns the removed IDs of the "serious_event_stats_list" edge to the SeriousEventStats entity.
func (m *SeriousEventMutation) RemovedSeriousEventStatsListIDs() (ids []int) {
	for id := range m.removedserious_event_stats_list {
		ids = append(ids, id)
	}
	return
}

// SeriousEventStatsListIDs returns the "serious_event_stats_list" edge IDs in the mutation.
func (m *SeriousEventMutation) SeriousEventStatsListIDs() (ids []int) {
	for id := range m.serious_event_stats_list {
		ids = append(ids, id)
	}
	return
}

// ResetSeriousEventStatsList resets all changes to the "serious_event_stats_list" edge.
func (m *SeriousEventMutation) ResetSeriousEventStatsList() {
	m.serious_event_stats_list = nil
	m.clearedserious_event_stats_list = false
	m.removedserious_event_stats_list = nil
}

// Where appends a list predicates to the SeriousEventMutation builder.
func (m *SeriousEventMutation) Where(ps ...predicate.SeriousEvent) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SeriousEventMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SeriousEvent).
func (m *SeriousEventMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SeriousEventMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.serious_event_term != nil {
		fields = append(fields, seriousevent.FieldSeriousEventTerm)
	}
	if m.serious_event_organ_system != nil {
		fields = append(fields, seriousevent.FieldSeriousEventOrganSystem)
	}
	if m.serious_event_source_vocabulary != nil {
		fields = append(fields, seriousevent.FieldSeriousEventSourceVocabulary)
	}
	if m.serious_event_assessment_type != nil {
		fields = append(fields, seriousevent.FieldSeriousEventAssessmentType)
	}
	if m.serious_event_notes != nil {
		fields = append(fields, seriousevent.FieldSeriousEventNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SeriousEventMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case seriousevent.FieldSeriousEventTerm:
		return m.SeriousEventTerm()
	case seriousevent.FieldSeriousEventOrganSystem:
		return m.SeriousEventOrganSystem()
	case seriousevent.FieldSeriousEventSourceVocabulary:
		return m.SeriousEventSourceVocabulary()
	case seriousevent.FieldSeriousEventAssessmentType:
		return m.SeriousEventAssessmentType()
	case seriousevent.FieldSeriousEventNotes:
		return m.SeriousEventNotes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SeriousEventMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case seriousevent.FieldSeriousEventTerm:
		return m.OldSeriousEventTerm(ctx)
	case seriousevent.FieldSeriousEventOrganSystem:
		return m.OldSeriousEventOrganSystem(ctx)
	case seriousevent.FieldSeriousEventSourceVocabulary:
		return m.OldSeriousEventSourceVocabulary(ctx)
	case seriousevent.FieldSeriousEventAssessmentType:
		return m.OldSeriousEventAssessmentType(ctx)
	case seriousevent.FieldSeriousEventNotes:
		return m.OldSeriousEventNotes(ctx)
	}
	return nil, fmt.Errorf("unknown SeriousEvent field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeriousEventMutation) SetField(name string, value ent.Value) error {
	switch name {
	case seriousevent.FieldSeriousEventTerm:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeriousEventTerm(v)
		return nil
	case seriousevent.FieldSeriousEventOrganSystem:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeriousEventOrganSystem(v)
		return nil
	case seriousevent.FieldSeriousEventSourceVocabulary:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeriousEventSourceVocabulary(v)
		return nil
	case seriousevent.FieldSeriousEventAssessmentType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeriousEventAssessmentType(v)
		return nil
	case seriousevent.FieldSeriousEventNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeriousEventNotes(v)
		return nil
	}
	return fmt.Errorf("unknown SeriousEvent field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SeriousEventMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SeriousEventMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeriousEventMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SeriousEvent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SeriousEventMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SeriousEventMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SeriousEventMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SeriousEvent nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SeriousEventMutation) ResetField(name string) error {
	switch name {
	case seriousevent.FieldSeriousEventTerm:
		m.ResetSeriousEventTerm()
		return nil
	case seriousevent.FieldSeriousEventOrganSystem:
		m.ResetSeriousEventOrganSystem()
		return nil
	case seriousevent.FieldSeriousEventSourceVocabulary:
		m.ResetSeriousEventSourceVocabulary()
		return nil
	case seriousevent.FieldSeriousEventAssessmentType:
		m.ResetSeriousEventAssessmentType()
		return nil
	case seriousevent.FieldSeriousEventNotes:
		m.ResetSeriousEventNotes()
		return nil
	}
	return fmt.Errorf("unknown SeriousEvent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SeriousEventMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.parent != nil {
		edges = append(edges, seriousevent.EdgeParent)
	}
	if m.serious_event_stats_list != nil {
		edges = append(edges, seriousevent.EdgeSeriousEventStatsList)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SeriousEventMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case seriousevent.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case seriousevent.EdgeSeriousEventStatsList:
		ids := make([]ent.Value, 0, len(m.serious_event_stats_list))
		for id := range m.serious_event_stats_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SeriousEventMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedserious_event_stats_list != nil {
		edges = append(edges, seriousevent.EdgeSeriousEventStatsList)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SeriousEventMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case seriousevent.EdgeSeriousEventStatsList:
		ids := make([]ent.Value, 0, len(m.removedserious_event_stats_list))
		for id := range m.removedserious_event_stats_list {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SeriousEventMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedparent {
		edges = append(edges, seriousevent.EdgeParent)
	}
	if m.clearedserious_event_stats_list {
		edges = append(edges, seriousevent.EdgeSeriousEventStatsList)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SeriousEventMutation) EdgeCleared(name string) bool {
	switch name {
	case seriousevent.EdgeParent:
		return m.clearedparent
	case seriousevent.EdgeSeriousEventStatsList:
		return m.clearedserious_event_stats_list
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SeriousEventMutation) ClearEdge(name string) error {
	switch name {
	case seriousevent.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown SeriousEvent unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SeriousEventMutation) ResetEdge(name string) error {
	switch name {
	case seriousevent.EdgeParent:
		m.ResetParent()
		return nil
	case seriousevent.EdgeSeriousEventStatsList:
		m.ResetSeriousEventStatsList()
		return nil
	}
	return fmt.Errorf("unknown SeriousEvent edge %s", name)
}

// SeriousEventStatsMutation represents an operation that mutates the SeriousEventStats nodes in the graph.
type SeriousEventStatsMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	serious_event_stats_group_id     *string
	serious_event_stats_num_events   *string
	serious_event_stats_num_affected *string
	serious_event_stats_num_at_risk  *string
	clearedFields                    map[string]struct{}
	parent                           *int
	clearedparent                    bool
	done                             bool
	oldValue                         func(context.Context) (*SeriousEventStats, error)
	predicates                       []predicate.SeriousEventStats
}

var _ ent.Mutation = (*SeriousEventStatsMutation)(nil)

// seriouseventstatsOption allows management of the mutation configuration using functional options.
type seriouseventstatsOption func(*SeriousEventStatsMutation)

// newSeriousEventStatsMutation creates new mutation for the SeriousEventStats entity.
func newSeriousEventStatsMutation(c config, op Op, opts ...seriouseventstatsOption) *SeriousEventStatsMutation {
	m := &SeriousEventStatsMutation{
		config:        c,
		op:            op,
		typ:           TypeSeriousEventStats,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSeriousEventStatsID sets the ID field of the mutation.
func withSeriousEventStatsID(id int) seriouseventstatsOption {
	return func(m *SeriousEventStatsMutation) {
		var (
			err   error
			once  sync.Once
			value *SeriousEventStats
		)
		m.oldValue = func(ctx context.Context) (*SeriousEventStats, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SeriousEventStats.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSeriousEventStats sets the old SeriousEventStats of the mutation.
func withSeriousEventStats(node *SeriousEventStats) seriouseventstatsOption {
	return func(m *SeriousEventStatsMutation) {
		m.oldValue = func(context.Context) (*SeriousEventStats, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SeriousEventStatsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SeriousEventStatsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SeriousEventStatsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SeriousEventStatsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SeriousEventStats.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSeriousEventStatsGroupID sets the "serious_event_stats_group_id" field.
func (m *SeriousEventStatsMutation) SetSeriousEventStatsGroupID(s string) {
	m.serious_event_stats_group_id = &s
}

// SeriousEventStatsGroupID returns the value of the "serious_event_stats_group_id" field in the mutation.
func (m *SeriousEventStatsMutation) SeriousEventStatsGroupID() (r string, exists bool) {
	v := m.serious_event_stats_group_id
	if v == nil {
		return
	}
	return *v, true
}

// OldSeriousEventStatsGroupID returns the old "serious_event_stats_group_id" field's value of the SeriousEventStats entity.
// If the SeriousEventStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriousEventStatsMutation) OldSeriousEventStatsGroupID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeriousEventStatsGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeriousEventStatsGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeriousEventStatsGroupID: %w", err)
	}
	return oldValue.SeriousEventStatsGroupID, nil
}

// ResetSeriousEventStatsGroupID resets all changes to the "serious_event_stats_group_id" field.
func (m *SeriousEventStatsMutation) ResetSeriousEventStatsGroupID() {
	m.serious_event_stats_group_id = nil
}

// SetSeriousEventStatsNumEvents sets the "serious_event_stats_num_events" field.
func (m *SeriousEventStatsMutation) SetSeriousEventStatsNumEvents(s string) {
	m.serious_event_stats_num_events = &s
}

// SeriousEventStatsNumEvents returns the value of the "serious_event_stats_num_events" field in the mutation.
func (m *SeriousEventStatsMutation) SeriousEventStatsNumEvents() (r string, exists bool) {
	v := m.serious_event_stats_num_events
	if v == nil {
		return
	}
	return *v, true
}

// OldSeriousEventStatsNumEvents returns the old "serious_event_stats_num_events" field's value of the SeriousEventStats entity.
// If the SeriousEventStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriousEventStatsMutation) OldSeriousEventStatsNumEvents(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeriousEventStatsNumEvents is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeriousEventStatsNumEvents requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeriousEventStatsNumEvents: %w", err)
	}
	return oldValue.SeriousEventStatsNumEvents, nil
}

// ResetSeriousEventStatsNumEvents resets all changes to the "serious_event_stats_num_events" field.
func (m *SeriousEventStatsMutation) ResetSeriousEventStatsNumEvents() {
	m.serious_event_stats_num_events = nil
}

// SetSeriousEventStatsNumAffected sets the "serious_event_stats_num_affected" field.
func (m *SeriousEventStatsMutation) SetSeriousEventStatsNumAffected(s string) {
	m.serious_event_stats_num_affected = &s
}

// SeriousEventStatsNumAffected returns the value of the "serious_event_stats_num_affected" field in the mutation.
func (m *SeriousEventStatsMutation) SeriousEventStatsNumAffected() (r string, exists bool) {
	v := m.serious_event_stats_num_affected
	if v == nil {
		return
	}
	return *v, true
}

// OldSeriousEventStatsNumAffected returns the old "serious_event_stats_num_affected" field's value of the SeriousEventStats entity.
// If the SeriousEventStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriousEventStatsMutation) OldSeriousEventStatsNumAffected(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeriousEventStatsNumAffected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeriousEventStatsNumAffected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeriousEventStatsNumAffected: %w", err)
	}
	return oldValue.SeriousEventStatsNumAffected, nil
}

// ResetSeriousEventStatsNumAffected resets all changes to the "serious_event_stats_num_affected" field.
func (m *SeriousEventStatsMutation) ResetSeriousEventStatsNumAffected() {
	m.serious_event_stats_num_affected = nil
}

// SetSeriousEventStatsNumAtRisk sets the "serious_event_stats_num_at_risk" field.
func (m *SeriousEventStatsMutation) SetSeriousEventStatsNumAtRisk(s string) {
	m.serious_event_stats_num_at_risk = &s
}

// SeriousEventStatsNumAtRisk returns the value of the "serious_event_stats_num_at_risk" field in the mutation.
func (m *SeriousEventStatsMutation) SeriousEventStatsNumAtRisk() (r string, exists bool) {
	v := m.serious_event_stats_num_at_risk
	if v == nil {
		return
	}
	return *v, true
}

// OldSeriousEventStatsNumAtRisk returns the old "serious_event_stats_num_at_risk" field's value of the SeriousEventStats entity.
// If the SeriousEventStats object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeriousEventStatsMutation) OldSeriousEventStatsNumAtRisk(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeriousEventStatsNumAtRisk is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeriousEventStatsNumAtRisk requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeriousEventStatsNumAtRisk: %w", err)
	}
	return oldValue.SeriousEventStatsNumAtRisk, nil
}

// ResetSeriousEventStatsNumAtRisk resets all changes to the "serious_event_stats_num_at_risk" field.
func (m *SeriousEventStatsMutation) ResetSeriousEventStatsNumAtRisk() {
	m.serious_event_stats_num_at_risk = nil
}

// SetParentID sets the "parent" edge to the SeriousEvent entity by id.
func (m *SeriousEventStatsMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the SeriousEvent entity.
func (m *SeriousEventStatsMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the SeriousEvent entity was cleared.
func (m *SeriousEventStatsMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *SeriousEventStatsMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *SeriousEventStatsMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *SeriousEventStatsMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// Where appends a list predicates to the SeriousEventStatsMutation builder.
func (m *SeriousEventStatsMutation) Where(ps ...predicate.SeriousEventStats) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *SeriousEventStatsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SeriousEventStats).
func (m *SeriousEventStatsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SeriousEventStatsMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.serious_event_stats_group_id != nil {
		fields = append(fields, seriouseventstats.FieldSeriousEventStatsGroupID)
	}
	if m.serious_event_stats_num_events != nil {
		fields = append(fields, seriouseventstats.FieldSeriousEventStatsNumEvents)
	}
	if m.serious_event_stats_num_affected != nil {
		fields = append(fields, seriouseventstats.FieldSeriousEventStatsNumAffected)
	}
	if m.serious_event_stats_num_at_risk != nil {
		fields = append(fields, seriouseventstats.FieldSeriousEventStatsNumAtRisk)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SeriousEventStatsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case seriouseventstats.FieldSeriousEventStatsGroupID:
		return m.SeriousEventStatsGroupID()
	case seriouseventstats.FieldSeriousEventStatsNumEvents:
		return m.SeriousEventStatsNumEvents()
	case seriouseventstats.FieldSeriousEventStatsNumAffected:
		return m.SeriousEventStatsNumAffected()
	case seriouseventstats.FieldSeriousEventStatsNumAtRisk:
		return m.SeriousEventStatsNumAtRisk()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SeriousEventStatsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case seriouseventstats.FieldSeriousEventStatsGroupID:
		return m.OldSeriousEventStatsGroupID(ctx)
	case seriouseventstats.FieldSeriousEventStatsNumEvents:
		return m.OldSeriousEventStatsNumEvents(ctx)
	case seriouseventstats.FieldSeriousEventStatsNumAffected:
		return m.OldSeriousEventStatsNumAffected(ctx)
	case seriouseventstats.FieldSeriousEventStatsNumAtRisk:
		return m.OldSeriousEventStatsNumAtRisk(ctx)
	}
	return nil, fmt.Errorf("unknown SeriousEventStats field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeriousEventStatsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case seriouseventstats.FieldSeriousEventStatsGroupID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeriousEventStatsGroupID(v)
		return nil
	case seriouseventstats.FieldSeriousEventStatsNumEvents:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeriousEventStatsNumEvents(v)
		return nil
	case seriouseventstats.FieldSeriousEventStatsNumAffected:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeriousEventStatsNumAffected(v)
		return nil
	case seriouseventstats.FieldSeriousEventStatsNumAtRisk:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeriousEventStatsNumAtRisk(v)
		return nil
	}
	return fmt.Errorf("unknown SeriousEventStats field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SeriousEventStatsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SeriousEventStatsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeriousEventStatsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SeriousEventStats numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SeriousEventStatsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SeriousEventStatsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SeriousEventStatsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SeriousEventStats nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SeriousEventStatsMutation) ResetField(name string) error {
	switch name {
	case seriouseventstats.FieldSeriousEventStatsGroupID:
		m.ResetSeriousEventStatsGroupID()
		return nil
	case seriouseventstats.FieldSeriousEventStatsNumEvents:
		m.ResetSeriousEventStatsNumEvents()
		return nil
	case seriouseventstats.FieldSeriousEventStatsNumAffected:
		m.ResetSeriousEventStatsNumAffected()
		return nil
	case seriouseventstats.FieldSeriousEventStatsNumAtRisk:
		m.ResetSeriousEventStatsNumAtRisk()
		return nil
	}
	return fmt.Errorf("unknown SeriousEventStats field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SeriousEventStatsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.parent != nil {
		edges = append(edges, seriouseventstats.EdgeParent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SeriousEventStatsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case seriouseventstats.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SeriousEventStatsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SeriousEventStatsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SeriousEventStatsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparent {
		edges = append(edges, seriouseventstats.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SeriousEventStatsMutation) EdgeCleared(name string) bool {
	switch name {
	case seriouseventstats.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SeriousEventStatsMutation) ClearEdge(name string) error {
	switch name {
	case seriouseventstats.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown SeriousEventStats unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SeriousEventStatsMutation) ResetEdge(name string) error {
	switch name {
	case seriouseventstats.EdgeParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown SeriousEventStats edge %s", name)
}

// StudyEligibilityMutation represents an operation that mutates the StudyEligibility nodes in the graph.
type StudyEligibilityMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	_EligibilityCriteria *string
	_HealthyVolunteers   *string
	_Gender              *string
	_MinimumAge          *string
	_MaximumAge          *string
	_StdAgeList          *string
	_Ethnicity           *string
	clearedFields        map[string]struct{}
	parent               *int
	clearedparent        bool
	done                 bool
	oldValue             func(context.Context) (*StudyEligibility, error)
	predicates           []predicate.StudyEligibility
}

var _ ent.Mutation = (*StudyEligibilityMutation)(nil)

// studyeligibilityOption allows management of the mutation configuration using functional options.
type studyeligibilityOption func(*StudyEligibilityMutation)

// newStudyEligibilityMutation creates new mutation for the StudyEligibility entity.
func newStudyEligibilityMutation(c config, op Op, opts ...studyeligibilityOption) *StudyEligibilityMutation {
	m := &StudyEligibilityMutation{
		config:        c,
		op:            op,
		typ:           TypeStudyEligibility,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStudyEligibilityID sets the ID field of the mutation.
func withStudyEligibilityID(id int) studyeligibilityOption {
	return func(m *StudyEligibilityMutation) {
		var (
			err   error
			once  sync.Once
			value *StudyEligibility
		)
		m.oldValue = func(ctx context.Context) (*StudyEligibility, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StudyEligibility.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStudyEligibility sets the old StudyEligibility of the mutation.
func withStudyEligibility(node *StudyEligibility) studyeligibilityOption {
	return func(m *StudyEligibilityMutation) {
		m.oldValue = func(context.Context) (*StudyEligibility, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StudyEligibilityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StudyEligibilityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StudyEligibilityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StudyEligibilityMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StudyEligibility.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEligibilityCriteria sets the "EligibilityCriteria" field.
func (m *StudyEligibilityMutation) SetEligibilityCriteria(s string) {
	m._EligibilityCriteria = &s
}

// EligibilityCriteria returns the value of the "EligibilityCriteria" field in the mutation.
func (m *StudyEligibilityMutation) EligibilityCriteria() (r string, exists bool) {
	v := m._EligibilityCriteria
	if v == nil {
		return
	}
	return *v, true
}

// OldEligibilityCriteria returns the old "EligibilityCriteria" field's value of the StudyEligibility entity.
// If the StudyEligibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudyEligibilityMutation) OldEligibilityCriteria(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEligibilityCriteria is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEligibilityCriteria requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEligibilityCriteria: %w", err)
	}
	return oldValue.EligibilityCriteria, nil
}

// ResetEligibilityCriteria resets all changes to the "EligibilityCriteria" field.
func (m *StudyEligibilityMutation) ResetEligibilityCriteria() {
	m._EligibilityCriteria = nil
}

// SetHealthyVolunteers sets the "HealthyVolunteers" field.
func (m *StudyEligibilityMutation) SetHealthyVolunteers(s string) {
	m._HealthyVolunteers = &s
}

// HealthyVolunteers returns the value of the "HealthyVolunteers" field in the mutation.
func (m *StudyEligibilityMutation) HealthyVolunteers() (r string, exists bool) {
	v := m._HealthyVolunteers
	if v == nil {
		return
	}
	return *v, true
}

// OldHealthyVolunteers returns the old "HealthyVolunteers" field's value of the StudyEligibility entity.
// If the StudyEligibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudyEligibilityMutation) OldHealthyVolunteers(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHealthyVolunteers is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHealthyVolunteers requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHealthyVolunteers: %w", err)
	}
	return oldValue.HealthyVolunteers, nil
}

// ResetHealthyVolunteers resets all changes to the "HealthyVolunteers" field.
func (m *StudyEligibilityMutation) ResetHealthyVolunteers() {
	m._HealthyVolunteers = nil
}

// SetGender sets the "Gender" field.
func (m *StudyEligibilityMutation) SetGender(s string) {
	m._Gender = &s
}

// Gender returns the value of the "Gender" field in the mutation.
func (m *StudyEligibilityMutation) Gender() (r string, exists bool) {
	v := m._Gender
	if v == nil {
		return
	}
	return *v, true
}

// OldGender returns the old "Gender" field's value of the StudyEligibility entity.
// If the StudyEligibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudyEligibilityMutation) OldGender(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGender is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGender requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGender: %w", err)
	}
	return oldValue.Gender, nil
}

// ResetGender resets all changes to the "Gender" field.
func (m *StudyEligibilityMutation) ResetGender() {
	m._Gender = nil
}

// SetMinimumAge sets the "MinimumAge" field.
func (m *StudyEligibilityMutation) SetMinimumAge(s string) {
	m._MinimumAge = &s
}

// MinimumAge returns the value of the "MinimumAge" field in the mutation.
func (m *StudyEligibilityMutation) MinimumAge() (r string, exists bool) {
	v := m._MinimumAge
	if v == nil {
		return
	}
	return *v, true
}

// OldMinimumAge returns the old "MinimumAge" field's value of the StudyEligibility entity.
// If the StudyEligibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudyEligibilityMutation) OldMinimumAge(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinimumAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinimumAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinimumAge: %w", err)
	}
	return oldValue.MinimumAge, nil
}

// ResetMinimumAge resets all changes to the "MinimumAge" field.
func (m *StudyEligibilityMutation) ResetMinimumAge() {
	m._MinimumAge = nil
}

// SetMaximumAge sets the "MaximumAge" field.
func (m *StudyEligibilityMutation) SetMaximumAge(s string) {
	m._MaximumAge = &s
}

// MaximumAge returns the value of the "MaximumAge" field in the mutation.
func (m *StudyEligibilityMutation) MaximumAge() (r string, exists bool) {
	v := m._MaximumAge
	if v == nil {
		return
	}
	return *v, true
}

// OldMaximumAge returns the old "MaximumAge" field's value of the StudyEligibility entity.
// If the StudyEligibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudyEligibilityMutation) OldMaximumAge(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaximumAge is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaximumAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaximumAge: %w", err)
	}
	return oldValue.MaximumAge, nil
}

// ResetMaximumAge resets all changes to the "MaximumAge" field.
func (m *StudyEligibilityMutation) ResetMaximumAge() {
	m._MaximumAge = nil
}

// SetStdAgeList sets the "StdAgeList" field.
func (m *StudyEligibilityMutation) SetStdAgeList(s string) {
	m._StdAgeList = &s
}

// StdAgeList returns the value of the "StdAgeList" field in the mutation.
func (m *StudyEligibilityMutation) StdAgeList() (r string, exists bool) {
	v := m._StdAgeList
	if v == nil {
		return
	}
	return *v, true
}

// OldStdAgeList returns the old "StdAgeList" field's value of the StudyEligibility entity.
// If the StudyEligibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudyEligibilityMutation) OldStdAgeList(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStdAgeList is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStdAgeList requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStdAgeList: %w", err)
	}
	return oldValue.StdAgeList, nil
}

// ResetStdAgeList resets all changes to the "StdAgeList" field.
func (m *StudyEligibilityMutation) ResetStdAgeList() {
	m._StdAgeList = nil
}

// SetEthnicity sets the "Ethnicity" field.
func (m *StudyEligibilityMutation) SetEthnicity(s string) {
	m._Ethnicity = &s
}

// Ethnicity returns the value of the "Ethnicity" field in the mutation.
func (m *StudyEligibilityMutation) Ethnicity() (r string, exists bool) {
	v := m._Ethnicity
	if v == nil {
		return
	}
	return *v, true
}

// OldEthnicity returns the old "Ethnicity" field's value of the StudyEligibility entity.
// If the StudyEligibility object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudyEligibilityMutation) OldEthnicity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEthnicity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEthnicity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEthnicity: %w", err)
	}
	return oldValue.Ethnicity, nil
}

// ResetEthnicity resets all changes to the "Ethnicity" field.
func (m *StudyEligibilityMutation) ResetEthnicity() {
	m._Ethnicity = nil
}

// SetParentID sets the "parent" edge to the ClinicalTrial entity by id.
func (m *StudyEligibilityMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ClinicalTrial entity.
func (m *StudyEligibilityMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ClinicalTrial entity was cleared.
func (m *StudyEligibilityMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *StudyEligibilityMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *StudyEligibilityMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *StudyEligibilityMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// Where appends a list predicates to the StudyEligibilityMutation builder.
func (m *StudyEligibilityMutation) Where(ps ...predicate.StudyEligibility) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StudyEligibilityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (StudyEligibility).
func (m *StudyEligibilityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StudyEligibilityMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m._EligibilityCriteria != nil {
		fields = append(fields, studyeligibility.FieldEligibilityCriteria)
	}
	if m._HealthyVolunteers != nil {
		fields = append(fields, studyeligibility.FieldHealthyVolunteers)
	}
	if m._Gender != nil {
		fields = append(fields, studyeligibility.FieldGender)
	}
	if m._MinimumAge != nil {
		fields = append(fields, studyeligibility.FieldMinimumAge)
	}
	if m._MaximumAge != nil {
		fields = append(fields, studyeligibility.FieldMaximumAge)
	}
	if m._StdAgeList != nil {
		fields = append(fields, studyeligibility.FieldStdAgeList)
	}
	if m._Ethnicity != nil {
		fields = append(fields, studyeligibility.FieldEthnicity)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StudyEligibilityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case studyeligibility.FieldEligibilityCriteria:
		return m.EligibilityCriteria()
	case studyeligibility.FieldHealthyVolunteers:
		return m.HealthyVolunteers()
	case studyeligibility.FieldGender:
		return m.Gender()
	case studyeligibility.FieldMinimumAge:
		return m.MinimumAge()
	case studyeligibility.FieldMaximumAge:
		return m.MaximumAge()
	case studyeligibility.FieldStdAgeList:
		return m.StdAgeList()
	case studyeligibility.FieldEthnicity:
		return m.Ethnicity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StudyEligibilityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case studyeligibility.FieldEligibilityCriteria:
		return m.OldEligibilityCriteria(ctx)
	case studyeligibility.FieldHealthyVolunteers:
		return m.OldHealthyVolunteers(ctx)
	case studyeligibility.FieldGender:
		return m.OldGender(ctx)
	case studyeligibility.FieldMinimumAge:
		return m.OldMinimumAge(ctx)
	case studyeligibility.FieldMaximumAge:
		return m.OldMaximumAge(ctx)
	case studyeligibility.FieldStdAgeList:
		return m.OldStdAgeList(ctx)
	case studyeligibility.FieldEthnicity:
		return m.OldEthnicity(ctx)
	}
	return nil, fmt.Errorf("unknown StudyEligibility field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudyEligibilityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case studyeligibility.FieldEligibilityCriteria:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEligibilityCriteria(v)
		return nil
	case studyeligibility.FieldHealthyVolunteers:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHealthyVolunteers(v)
		return nil
	case studyeligibility.FieldGender:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGender(v)
		return nil
	case studyeligibility.FieldMinimumAge:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinimumAge(v)
		return nil
	case studyeligibility.FieldMaximumAge:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaximumAge(v)
		return nil
	case studyeligibility.FieldStdAgeList:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStdAgeList(v)
		return nil
	case studyeligibility.FieldEthnicity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEthnicity(v)
		return nil
	}
	return fmt.Errorf("unknown StudyEligibility field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StudyEligibilityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StudyEligibilityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudyEligibilityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StudyEligibility numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StudyEligibilityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StudyEligibilityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StudyEligibilityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown StudyEligibility nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StudyEligibilityMutation) ResetField(name string) error {
	switch name {
	case studyeligibility.FieldEligibilityCriteria:
		m.ResetEligibilityCriteria()
		return nil
	case studyeligibility.FieldHealthyVolunteers:
		m.ResetHealthyVolunteers()
		return nil
	case studyeligibility.FieldGender:
		m.ResetGender()
		return nil
	case studyeligibility.FieldMinimumAge:
		m.ResetMinimumAge()
		return nil
	case studyeligibility.FieldMaximumAge:
		m.ResetMaximumAge()
		return nil
	case studyeligibility.FieldStdAgeList:
		m.ResetStdAgeList()
		return nil
	case studyeligibility.FieldEthnicity:
		m.ResetEthnicity()
		return nil
	}
	return fmt.Errorf("unknown StudyEligibility field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StudyEligibilityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.parent != nil {
		edges = append(edges, studyeligibility.EdgeParent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StudyEligibilityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case studyeligibility.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StudyEligibilityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StudyEligibilityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StudyEligibilityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparent {
		edges = append(edges, studyeligibility.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StudyEligibilityMutation) EdgeCleared(name string) bool {
	switch name {
	case studyeligibility.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StudyEligibilityMutation) ClearEdge(name string) error {
	switch name {
	case studyeligibility.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown StudyEligibility unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StudyEligibilityMutation) ResetEdge(name string) error {
	switch name {
	case studyeligibility.EdgeParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown StudyEligibility edge %s", name)
}

// StudyLocationMutation represents an operation that mutates the StudyLocation nodes in the graph.
type StudyLocationMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	_LocationFacility      *string
	_LocationCity          *string
	_LocationCountry       *string
	_LocationCountryCode   *string
	_LocationContinentName *string
	_LocationContinentCode *string
	clearedFields          map[string]struct{}
	parent                 *int
	clearedparent          bool
	done                   bool
	oldValue               func(context.Context) (*StudyLocation, error)
	predicates             []predicate.StudyLocation
}

var _ ent.Mutation = (*StudyLocationMutation)(nil)

// studylocationOption allows management of the mutation configuration using functional options.
type studylocationOption func(*StudyLocationMutation)

// newStudyLocationMutation creates new mutation for the StudyLocation entity.
func newStudyLocationMutation(c config, op Op, opts ...studylocationOption) *StudyLocationMutation {
	m := &StudyLocationMutation{
		config:        c,
		op:            op,
		typ:           TypeStudyLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStudyLocationID sets the ID field of the mutation.
func withStudyLocationID(id int) studylocationOption {
	return func(m *StudyLocationMutation) {
		var (
			err   error
			once  sync.Once
			value *StudyLocation
		)
		m.oldValue = func(ctx context.Context) (*StudyLocation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StudyLocation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStudyLocation sets the old StudyLocation of the mutation.
func withStudyLocation(node *StudyLocation) studylocationOption {
	return func(m *StudyLocationMutation) {
		m.oldValue = func(context.Context) (*StudyLocation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StudyLocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StudyLocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StudyLocationMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StudyLocationMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StudyLocation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLocationFacility sets the "LocationFacility" field.
func (m *StudyLocationMutation) SetLocationFacility(s string) {
	m._LocationFacility = &s
}

// LocationFacility returns the value of the "LocationFacility" field in the mutation.
func (m *StudyLocationMutation) LocationFacility() (r string, exists bool) {
	v := m._LocationFacility
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationFacility returns the old "LocationFacility" field's value of the StudyLocation entity.
// If the StudyLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudyLocationMutation) OldLocationFacility(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationFacility is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationFacility requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationFacility: %w", err)
	}
	return oldValue.LocationFacility, nil
}

// ResetLocationFacility resets all changes to the "LocationFacility" field.
func (m *StudyLocationMutation) ResetLocationFacility() {
	m._LocationFacility = nil
}

// SetLocationCity sets the "LocationCity" field.
func (m *StudyLocationMutation) SetLocationCity(s string) {
	m._LocationCity = &s
}

// LocationCity returns the value of the "LocationCity" field in the mutation.
func (m *StudyLocationMutation) LocationCity() (r string, exists bool) {
	v := m._LocationCity
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationCity returns the old "LocationCity" field's value of the StudyLocation entity.
// If the StudyLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudyLocationMutation) OldLocationCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationCity: %w", err)
	}
	return oldValue.LocationCity, nil
}

// ResetLocationCity resets all changes to the "LocationCity" field.
func (m *StudyLocationMutation) ResetLocationCity() {
	m._LocationCity = nil
}

// SetLocationCountry sets the "LocationCountry" field.
func (m *StudyLocationMutation) SetLocationCountry(s string) {
	m._LocationCountry = &s
}

// LocationCountry returns the value of the "LocationCountry" field in the mutation.
func (m *StudyLocationMutation) LocationCountry() (r string, exists bool) {
	v := m._LocationCountry
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationCountry returns the old "LocationCountry" field's value of the StudyLocation entity.
// If the StudyLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudyLocationMutation) OldLocationCountry(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationCountry: %w", err)
	}
	return oldValue.LocationCountry, nil
}

// ResetLocationCountry resets all changes to the "LocationCountry" field.
func (m *StudyLocationMutation) ResetLocationCountry() {
	m._LocationCountry = nil
}

// SetLocationCountryCode sets the "LocationCountryCode" field.
func (m *StudyLocationMutation) SetLocationCountryCode(s string) {
	m._LocationCountryCode = &s
}

// LocationCountryCode returns the value of the "LocationCountryCode" field in the mutation.
func (m *StudyLocationMutation) LocationCountryCode() (r string, exists bool) {
	v := m._LocationCountryCode
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationCountryCode returns the old "LocationCountryCode" field's value of the StudyLocation entity.
// If the StudyLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudyLocationMutation) OldLocationCountryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationCountryCode: %w", err)
	}
	return oldValue.LocationCountryCode, nil
}

// ResetLocationCountryCode resets all changes to the "LocationCountryCode" field.
func (m *StudyLocationMutation) ResetLocationCountryCode() {
	m._LocationCountryCode = nil
}

// SetLocationContinentName sets the "LocationContinentName" field.
func (m *StudyLocationMutation) SetLocationContinentName(s string) {
	m._LocationContinentName = &s
}

// LocationContinentName returns the value of the "LocationContinentName" field in the mutation.
func (m *StudyLocationMutation) LocationContinentName() (r string, exists bool) {
	v := m._LocationContinentName
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationContinentName returns the old "LocationContinentName" field's value of the StudyLocation entity.
// If the StudyLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudyLocationMutation) OldLocationContinentName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationContinentName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationContinentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationContinentName: %w", err)
	}
	return oldValue.LocationContinentName, nil
}

// ResetLocationContinentName resets all changes to the "LocationContinentName" field.
func (m *StudyLocationMutation) ResetLocationContinentName() {
	m._LocationContinentName = nil
}

// SetLocationContinentCode sets the "LocationContinentCode" field.
func (m *StudyLocationMutation) SetLocationContinentCode(s string) {
	m._LocationContinentCode = &s
}

// LocationContinentCode returns the value of the "LocationContinentCode" field in the mutation.
func (m *StudyLocationMutation) LocationContinentCode() (r string, exists bool) {
	v := m._LocationContinentCode
	if v == nil {
		return
	}
	return *v, true
}

// OldLocationContinentCode returns the old "LocationContinentCode" field's value of the StudyLocation entity.
// If the StudyLocation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudyLocationMutation) OldLocationContinentCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocationContinentCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocationContinentCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocationContinentCode: %w", err)
	}
	return oldValue.LocationContinentCode, nil
}

// ResetLocationContinentCode resets all changes to the "LocationContinentCode" field.
func (m *StudyLocationMutation) ResetLocationContinentCode() {
	m._LocationContinentCode = nil
}

// SetParentID sets the "parent" edge to the ClinicalTrial entity by id.
func (m *StudyLocationMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the ClinicalTrial entity.
func (m *StudyLocationMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the ClinicalTrial entity was cleared.
func (m *StudyLocationMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *StudyLocationMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *StudyLocationMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *StudyLocationMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// Where appends a list predicates to the StudyLocationMutation builder.
func (m *StudyLocationMutation) Where(ps ...predicate.StudyLocation) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StudyLocationMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (StudyLocation).
func (m *StudyLocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StudyLocationMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m._LocationFacility != nil {
		fields = append(fields, studylocation.FieldLocationFacility)
	}
	if m._LocationCity != nil {
		fields = append(fields, studylocation.FieldLocationCity)
	}
	if m._LocationCountry != nil {
		fields = append(fields, studylocation.FieldLocationCountry)
	}
	if m._LocationCountryCode != nil {
		fields = append(fields, studylocation.FieldLocationCountryCode)
	}
	if m._LocationContinentName != nil {
		fields = append(fields, studylocation.FieldLocationContinentName)
	}
	if m._LocationContinentCode != nil {
		fields = append(fields, studylocation.FieldLocationContinentCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StudyLocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case studylocation.FieldLocationFacility:
		return m.LocationFacility()
	case studylocation.FieldLocationCity:
		return m.LocationCity()
	case studylocation.FieldLocationCountry:
		return m.LocationCountry()
	case studylocation.FieldLocationCountryCode:
		return m.LocationCountryCode()
	case studylocation.FieldLocationContinentName:
		return m.LocationContinentName()
	case studylocation.FieldLocationContinentCode:
		return m.LocationContinentCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StudyLocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case studylocation.FieldLocationFacility:
		return m.OldLocationFacility(ctx)
	case studylocation.FieldLocationCity:
		return m.OldLocationCity(ctx)
	case studylocation.FieldLocationCountry:
		return m.OldLocationCountry(ctx)
	case studylocation.FieldLocationCountryCode:
		return m.OldLocationCountryCode(ctx)
	case studylocation.FieldLocationContinentName:
		return m.OldLocationContinentName(ctx)
	case studylocation.FieldLocationContinentCode:
		return m.OldLocationContinentCode(ctx)
	}
	return nil, fmt.Errorf("unknown StudyLocation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudyLocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case studylocation.FieldLocationFacility:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationFacility(v)
		return nil
	case studylocation.FieldLocationCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationCity(v)
		return nil
	case studylocation.FieldLocationCountry:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationCountry(v)
		return nil
	case studylocation.FieldLocationCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationCountryCode(v)
		return nil
	case studylocation.FieldLocationContinentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationContinentName(v)
		return nil
	case studylocation.FieldLocationContinentCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocationContinentCode(v)
		return nil
	}
	return fmt.Errorf("unknown StudyLocation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StudyLocationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StudyLocationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudyLocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown StudyLocation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StudyLocationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StudyLocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StudyLocationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown StudyLocation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StudyLocationMutation) ResetField(name string) error {
	switch name {
	case studylocation.FieldLocationFacility:
		m.ResetLocationFacility()
		return nil
	case studylocation.FieldLocationCity:
		m.ResetLocationCity()
		return nil
	case studylocation.FieldLocationCountry:
		m.ResetLocationCountry()
		return nil
	case studylocation.FieldLocationCountryCode:
		m.ResetLocationCountryCode()
		return nil
	case studylocation.FieldLocationContinentName:
		m.ResetLocationContinentName()
		return nil
	case studylocation.FieldLocationContinentCode:
		m.ResetLocationContinentCode()
		return nil
	}
	return fmt.Errorf("unknown StudyLocation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StudyLocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.parent != nil {
		edges = append(edges, studylocation.EdgeParent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StudyLocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case studylocation.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StudyLocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StudyLocationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StudyLocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparent {
		edges = append(edges, studylocation.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StudyLocationMutation) EdgeCleared(name string) bool {
	switch name {
	case studylocation.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StudyLocationMutation) ClearEdge(name string) error {
	switch name {
	case studylocation.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown StudyLocation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StudyLocationMutation) ResetEdge(name string) error {
	switch name {
	case studylocation.EdgeParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown StudyLocation edge %s", name)
}

// TaskMutation represents an operation that mutates the Task nodes in the graph.
type TaskMutation struct {
	config
	op            Op
	typ           string
	id            *string
	owner         *string
	text          *string
	status        *task.Status
	created_at    *time.Time
	updated_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Task, error)
	predicates    []predicate.Task
}

var _ ent.Mutation = (*TaskMutation)(nil)

// taskOption allows management of the mutation configuration using functional options.
type taskOption func(*TaskMutation)

// newTaskMutation creates new mutation for the Task entity.
func newTaskMutation(c config, op Op, opts ...taskOption) *TaskMutation {
	m := &TaskMutation{
		config:        c,
		op:            op,
		typ:           TypeTask,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskID sets the ID field of the mutation.
func withTaskID(id string) taskOption {
	return func(m *TaskMutation) {
		var (
			err   error
			once  sync.Once
			value *Task
		)
		m.oldValue = func(ctx context.Context) (*Task, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Task.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTask sets the old Task of the mutation.
func withTask(node *Task) taskOption {
	return func(m *TaskMutation) {
		m.oldValue = func(context.Context) (*Task, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Task entities.
func (m *TaskMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TaskMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Task.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetOwner sets the "owner" field.
func (m *TaskMutation) SetOwner(s string) {
	m.owner = &s
}

// Owner returns the value of the "owner" field in the mutation.
func (m *TaskMutation) Owner() (r string, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwner returns the old "owner" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldOwner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwner: %w", err)
	}
	return oldValue.Owner, nil
}

// ResetOwner resets all changes to the "owner" field.
func (m *TaskMutation) ResetOwner() {
	m.owner = nil
}

// SetText sets the "text" field.
func (m *TaskMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *TaskMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *TaskMutation) ResetText() {
	m.text = nil
}

// SetStatus sets the "status" field.
func (m *TaskMutation) SetStatus(t task.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TaskMutation) Status() (r task.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldStatus(ctx context.Context) (v task.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *TaskMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[task.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *TaskMutation) StatusCleared() bool {
	_, ok := m.clearedFields[task.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *TaskMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, task.FieldStatus)
}

// SetCreatedAt sets the "created_at" field.
func (m *TaskMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TaskMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TaskMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TaskMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TaskMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Task entity.
// If the Task object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TaskMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// Where appends a list predicates to the TaskMutation builder.
func (m *TaskMutation) Where(ps ...predicate.Task) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TaskMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Task).
func (m *TaskMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.owner != nil {
		fields = append(fields, task.FieldOwner)
	}
	if m.text != nil {
		fields = append(fields, task.FieldText)
	}
	if m.status != nil {
		fields = append(fields, task.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, task.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, task.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case task.FieldOwner:
		return m.Owner()
	case task.FieldText:
		return m.Text()
	case task.FieldStatus:
		return m.Status()
	case task.FieldCreatedAt:
		return m.CreatedAt()
	case task.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case task.FieldOwner:
		return m.OldOwner(ctx)
	case task.FieldText:
		return m.OldText(ctx)
	case task.FieldStatus:
		return m.OldStatus(ctx)
	case task.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case task.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Task field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) SetField(name string, value ent.Value) error {
	switch name {
	case task.FieldOwner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwner(v)
		return nil
	case task.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case task.FieldStatus:
		v, ok := value.(task.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case task.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case task.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Task numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(task.FieldStatus) {
		fields = append(fields, task.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskMutation) ClearField(name string) error {
	switch name {
	case task.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Task nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskMutation) ResetField(name string) error {
	switch name {
	case task.FieldOwner:
		m.ResetOwner()
		return nil
	case task.FieldText:
		m.ResetText()
		return nil
	case task.FieldStatus:
		m.ResetStatus()
		return nil
	case task.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case task.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Task field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Task unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Task edge %s", name)
}

// UseCaseMutation represents an operation that mutates the UseCase nodes in the graph.
type UseCaseMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	use_case_name        *string
	use_case_description *string
	use_case_code        *string
	clearedFields        map[string]struct{}
	done                 bool
	oldValue             func(context.Context) (*UseCase, error)
	predicates           []predicate.UseCase
}

var _ ent.Mutation = (*UseCaseMutation)(nil)

// usecaseOption allows management of the mutation configuration using functional options.
type usecaseOption func(*UseCaseMutation)

// newUseCaseMutation creates new mutation for the UseCase entity.
func newUseCaseMutation(c config, op Op, opts ...usecaseOption) *UseCaseMutation {
	m := &UseCaseMutation{
		config:        c,
		op:            op,
		typ:           TypeUseCase,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUseCaseID sets the ID field of the mutation.
func withUseCaseID(id int) usecaseOption {
	return func(m *UseCaseMutation) {
		var (
			err   error
			once  sync.Once
			value *UseCase
		)
		m.oldValue = func(ctx context.Context) (*UseCase, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UseCase.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUseCase sets the old UseCase of the mutation.
func withUseCase(node *UseCase) usecaseOption {
	return func(m *UseCaseMutation) {
		m.oldValue = func(context.Context) (*UseCase, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UseCaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UseCaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UseCaseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UseCaseMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UseCase.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUseCaseName sets the "use_case_name" field.
func (m *UseCaseMutation) SetUseCaseName(s string) {
	m.use_case_name = &s
}

// UseCaseName returns the value of the "use_case_name" field in the mutation.
func (m *UseCaseMutation) UseCaseName() (r string, exists bool) {
	v := m.use_case_name
	if v == nil {
		return
	}
	return *v, true
}

// OldUseCaseName returns the old "use_case_name" field's value of the UseCase entity.
// If the UseCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UseCaseMutation) OldUseCaseName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseCaseName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseCaseName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseCaseName: %w", err)
	}
	return oldValue.UseCaseName, nil
}

// ResetUseCaseName resets all changes to the "use_case_name" field.
func (m *UseCaseMutation) ResetUseCaseName() {
	m.use_case_name = nil
}

// SetUseCaseDescription sets the "use_case_description" field.
func (m *UseCaseMutation) SetUseCaseDescription(s string) {
	m.use_case_description = &s
}

// UseCaseDescription returns the value of the "use_case_description" field in the mutation.
func (m *UseCaseMutation) UseCaseDescription() (r string, exists bool) {
	v := m.use_case_description
	if v == nil {
		return
	}
	return *v, true
}

// OldUseCaseDescription returns the old "use_case_description" field's value of the UseCase entity.
// If the UseCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UseCaseMutation) OldUseCaseDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseCaseDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseCaseDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseCaseDescription: %w", err)
	}
	return oldValue.UseCaseDescription, nil
}

// ResetUseCaseDescription resets all changes to the "use_case_description" field.
func (m *UseCaseMutation) ResetUseCaseDescription() {
	m.use_case_description = nil
}

// SetUseCaseCode sets the "use_case_code" field.
func (m *UseCaseMutation) SetUseCaseCode(s string) {
	m.use_case_code = &s
}

// UseCaseCode returns the value of the "use_case_code" field in the mutation.
func (m *UseCaseMutation) UseCaseCode() (r string, exists bool) {
	v := m.use_case_code
	if v == nil {
		return
	}
	return *v, true
}

// OldUseCaseCode returns the old "use_case_code" field's value of the UseCase entity.
// If the UseCase object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UseCaseMutation) OldUseCaseCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseCaseCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseCaseCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseCaseCode: %w", err)
	}
	return oldValue.UseCaseCode, nil
}

// ResetUseCaseCode resets all changes to the "use_case_code" field.
func (m *UseCaseMutation) ResetUseCaseCode() {
	m.use_case_code = nil
}

// Where appends a list predicates to the UseCaseMutation builder.
func (m *UseCaseMutation) Where(ps ...predicate.UseCase) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UseCaseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UseCase).
func (m *UseCaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UseCaseMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.use_case_name != nil {
		fields = append(fields, usecase.FieldUseCaseName)
	}
	if m.use_case_description != nil {
		fields = append(fields, usecase.FieldUseCaseDescription)
	}
	if m.use_case_code != nil {
		fields = append(fields, usecase.FieldUseCaseCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UseCaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usecase.FieldUseCaseName:
		return m.UseCaseName()
	case usecase.FieldUseCaseDescription:
		return m.UseCaseDescription()
	case usecase.FieldUseCaseCode:
		return m.UseCaseCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UseCaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case usecase.FieldUseCaseName:
		return m.OldUseCaseName(ctx)
	case usecase.FieldUseCaseDescription:
		return m.OldUseCaseDescription(ctx)
	case usecase.FieldUseCaseCode:
		return m.OldUseCaseCode(ctx)
	}
	return nil, fmt.Errorf("unknown UseCase field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UseCaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usecase.FieldUseCaseName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseCaseName(v)
		return nil
	case usecase.FieldUseCaseDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseCaseDescription(v)
		return nil
	case usecase.FieldUseCaseCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseCaseCode(v)
		return nil
	}
	return fmt.Errorf("unknown UseCase field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UseCaseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UseCaseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UseCaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UseCase numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UseCaseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UseCaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UseCaseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UseCase nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UseCaseMutation) ResetField(name string) error {
	switch name {
	case usecase.FieldUseCaseName:
		m.ResetUseCaseName()
		return nil
	case usecase.FieldUseCaseDescription:
		m.ResetUseCaseDescription()
		return nil
	case usecase.FieldUseCaseCode:
		m.ResetUseCaseCode()
		return nil
	}
	return fmt.Errorf("unknown UseCase field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UseCaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UseCaseMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UseCaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UseCaseMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UseCaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UseCaseMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UseCaseMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UseCase unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UseCaseMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UseCase edge %s", name)
}

// VaccineMutation represents an operation that mutates the Vaccine nodes in the graph.
type VaccineMutation struct {
	config
	op            Op
	typ           string
	id            *int
	vaccine_name  *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Vaccine, error)
	predicates    []predicate.Vaccine
}

var _ ent.Mutation = (*VaccineMutation)(nil)

// vaccineOption allows management of the mutation configuration using functional options.
type vaccineOption func(*VaccineMutation)

// newVaccineMutation creates new mutation for the Vaccine entity.
func newVaccineMutation(c config, op Op, opts ...vaccineOption) *VaccineMutation {
	m := &VaccineMutation{
		config:        c,
		op:            op,
		typ:           TypeVaccine,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withVaccineID sets the ID field of the mutation.
func withVaccineID(id int) vaccineOption {
	return func(m *VaccineMutation) {
		var (
			err   error
			once  sync.Once
			value *Vaccine
		)
		m.oldValue = func(ctx context.Context) (*Vaccine, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Vaccine.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withVaccine sets the old Vaccine of the mutation.
func withVaccine(node *Vaccine) vaccineOption {
	return func(m *VaccineMutation) {
		m.oldValue = func(context.Context) (*Vaccine, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m VaccineMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m VaccineMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("models: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *VaccineMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *VaccineMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Vaccine.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetVaccineName sets the "vaccine_name" field.
func (m *VaccineMutation) SetVaccineName(s string) {
	m.vaccine_name = &s
}

// VaccineName returns the value of the "vaccine_name" field in the mutation.
func (m *VaccineMutation) VaccineName() (r string, exists bool) {
	v := m.vaccine_name
	if v == nil {
		return
	}
	return *v, true
}

// OldVaccineName returns the old "vaccine_name" field's value of the Vaccine entity.
// If the Vaccine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *VaccineMutation) OldVaccineName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVaccineName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVaccineName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVaccineName: %w", err)
	}
	return oldValue.VaccineName, nil
}

// ResetVaccineName resets all changes to the "vaccine_name" field.
func (m *VaccineMutation) ResetVaccineName() {
	m.vaccine_name = nil
}

// Where appends a list predicates to the VaccineMutation builder.
func (m *VaccineMutation) Where(ps ...predicate.Vaccine) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *VaccineMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Vaccine).
func (m *VaccineMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *VaccineMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.vaccine_name != nil {
		fields = append(fields, vaccine.FieldVaccineName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *VaccineMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case vaccine.FieldVaccineName:
		return m.VaccineName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *VaccineMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case vaccine.FieldVaccineName:
		return m.OldVaccineName(ctx)
	}
	return nil, fmt.Errorf("unknown Vaccine field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VaccineMutation) SetField(name string, value ent.Value) error {
	switch name {
	case vaccine.FieldVaccineName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVaccineName(v)
		return nil
	}
	return fmt.Errorf("unknown Vaccine field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *VaccineMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *VaccineMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *VaccineMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Vaccine numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *VaccineMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *VaccineMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *VaccineMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Vaccine nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *VaccineMutation) ResetField(name string) error {
	switch name {
	case vaccine.FieldVaccineName:
		m.ResetVaccineName()
		return nil
	}
	return fmt.Errorf("unknown Vaccine field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *VaccineMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *VaccineMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *VaccineMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *VaccineMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *VaccineMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *VaccineMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *VaccineMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Vaccine unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *VaccineMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Vaccine edge %s", name)
}
